{"title": "ITRACE: AN IMPLICIT TRUST INFERENCE METHOD FOR TRUST-AWARE COLLABORATIVE FILTERING", "authors": "Xu He; Bin Liu; Ke-Jia Chen", "pub_date": "2017-08-15", "abstract": "The growth of Internet commerce has stimulated the use of collaborative filtering (CF) algorithms as recommender systems. A CF algorithm recommends items of interest to the target user by leveraging the votes given by other similar users. In a standard CF framework, it is assumed that the credibility of every voting user is exactly the same with respect to the target user. This assumption is not satisfied and may lead to misleading recommendations in practice. A natural countermeasure is to design a trust-aware CF algorithm, which can take account of the difference in the credibilities of the voting users when performing CF. To this end, this paper presents a trust inference approach, which can predict the implicit trust of the target user on every voting user from a sparse explicit trust matrix. Then an improved CF algorithm termed iTrace is proposed, which employs both the explicit and the predicted implicit trust to provide recommendations. An empirical evaluation on a public dataset demonstrates that the proposed algorithm provides a significant improvement in recommendation quality in terms of mean absolute error.", "sections": [{"heading": "INTRODUCTION", "text": "With the massive growth of the internet and the emergence of electronic commerce over the last decades, recommender system (RecSys) has become an indispensable technique to mitigate the problem of information overload for users. The aim of RecSys is to provide target users with high quality, personalized recommendations, and to help them find items \u22c6 Correspondence author: Bin Liu (Email: bins@ieee.org). This work was partly supported by the National Natural Science Foundation (NSF) of China under grant No. 61571238, China Postdoctoral Science Foundation under grant Nos. 2015M580455 and 2016T90483, the Six Talents Peak Foundation of Jiangsu Province under grant No. XYDXXJS-CXTD-006 and the Scientific and Technological Support Project (Society) of Jiangsu Province under grant No. BE2016776.\n(e.g., books, movies, news, music, etc.) of interest from a plethora of available choices [1].\nCollaborative filtering (CF) seems to be one of the most well-known and commonly used techniques to build a Rec-Sys [2][3][4]. The underlying idea of CF is that users with similar preferences in the past are likely to favor the same items (e.g., books, movies, news, music, etc.) in the future. The CF method is easy to implement. A typical CF method predicts the rating value user u gives to item i as follows [2]:\nr u,i = ru + v\u2208U w(u, v)(r v,i -rv ) v\u2208U |w(u, v)| ,(1)\nwhere U denotes a set of K neighbors of u who rated item i (also called u \u2032 s voting users in what follows), ru the average rating of user u for all the items rated by u, and w(u, v) the weight assigned to user v \u2032 s vote when she recommends items to u. In a standard CF framework, the weight w(u, v) is set as a similarity measure between users u and v, denoted by sim(u, v), and the neighbors of u are those most similar to u who co-rated item i with u. In order to compute the similarity between users, a variety of similarity measures have been proposed, such as Pearson correlation, cosine vector similarity, Spearman correlation, entropy-based uncertainty, and meansquare difference. It is reported that Pearson correlation performs better than the others [5,6]. The Pearson correlation coefficient is used here, defined as follows [3,7] sim\n(u, v) = i\u2208I (r u,i -ru )(r v,i -rv ) i\u2208I (r u,i -ru ) 2 i\u2208I (r v,i -rv ) 2 , (2\n) where I denotes the set of items that users u and v have corated.\nIn practical applications, users in general only rate a small portion of items, but accurate recommendations are expected for the cold users who rate only a few items. This raises two inherent obstacles to obtain satisfactory recommending quality, namely data sparsity and cold start [8][9][10][11]. In principle, this is caused by the lack of sufficient and reliable elements in U and/or I to calculate Eqns.( 1) and (2). A possible solution to get around this is to incorporate trust relationships into the CF framework, resulting in the trust based or trust-aware CF (TaCF) [8][9][10][12][13][14]. The underlying intuition supporting the working of trust-aware recommender systems (TaRS) is that users often accept advice from trustworthy friends in real life on topics they are not expert in. So it is reasonable to expect that considering trust relationship among users may bring in benefits in generating recommendations. Furthermore, trust can be propagated over a network of users, hence TaRS can overcome the data sparsity and cold start problems, from which traditional CF methods suffer, at least in concept.\nA practical issue to be considered when designing a TaCF algorithm is that the explicit trust information is usually much more sparse than the users' ratings. A trust propagation model along with an effective implicit trust inference method is desirable to overcome the above limitation. To this end, this paper presents an applicable implicit trust inference method, based on which an improved CF algorithm termed iTrace (i.e., Implicit TRust-Aware Collaborative filtEring) is proposed.", "publication_ref": ["b0", "b1", "b2", "b3", "b1", "b4", "b5", "b2", "b6", "b7", "b8", "b9", "b10", "b1", "b7", "b8", "b9", "b11", "b12", "b13"], "figure_ref": [], "table_ref": []}, {"heading": "THE PROPOSED ITRACE ALGORITHM", "text": "In this section, we present the iTrace algorithm followed by an analysis of its connections to existent related work.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Algorithm Design", "text": "An architecture of the iTrace algorithm is shown in Fig. 1. The inputs include an N \u00d7 N explicit trust matrix and an N \u00d7 M rating matrix, denoted in what follows by T e and R, respectively. N and M denote the numbers of the users and of the items, respectively. In contrast with a standard CF algorithm, iTrace leverages much more information except user similarity for prediction of user rating. Such additional information is represented by a trust matrix, denoted by T in what follows, which is estimated by an implicit trust inference module that takes T e as input. The details on the implicit trust inference module are presented in Sec.2.2. A working flow of the iTrace algorithm for predicting user u's rating value on item i is summarized as follows.\n1. Calculate the similarity metrics between u and the other users who rated i using Eqn.(2).\n2. Select the top K users who are most similar to u as u's voting users.\n3. Estimate the trust of u on every voting user, using the implicit trust inference method presented in Sec. 2.2.\n4. Predict user u's rating value on item i as follows\nr u,i = ru + v\u2208U f (sim(u, v), t(u, v))(r v,i -rv ) v\u2208U |f (sim(u, v), t(u, v))| ,(3)\nwhere t(u, v) is the estimated trust of u on v, obtained from Step 3. The function f plays a role of integrating user similarity and trust in rating prediction.\nWe consider two different forms of the function f in our algorithm. The first one, termed incremental weighting (IW) here, is specified as follows\nf (sim(u, v), t(u, v)) = sim(u, v) t(u, v) j\u2208U sim(u, j) t(u, j) .(4)\nThe standard CF framework corresponds to a special case in which t(u, i) = t(u, j) for \u2200i, j \u2208 U . The other form of f under consideration, termed linear weighting (LW) here, is\nf (sim(u, v), t(u, v)) = \u03b1sim(u, v) j\u2208U sim(u, j) + (1 -\u03b1) t(u, v) j\u2208U t(u, j) ,(5)\nwhere 0 \u2264 \u03b1 \u2264 1 denotes the linear weighting coefficient. The standard CF algorithm then corresponds to the case in which \u03b1 = 1. Through the analysis on Eqns.( 4) and ( 5), we see that the standard CF framework totally neglects the impact of the user trust. We show that in this paper, by taking into account of user trust, the iTrace algorithm can provide more accurate recommendations compared with the standard CF method. Through evaluation on a public dataset, we also demonstrate that Eqn.( 4) is preferable to Eqn. (5) in Sec.3.\nThe design of the implicit trust inference procedure, which is involved at Step 3 as shown above, creates a difference between the proposed iTrace algorithm and the other existing TaCF methods. The connections to related work in the literature are presented in Sec.2.3. We describe in detail the implicit trust inference procedure in the next subsection.", "publication_ref": ["b4"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Implicit Trust Inference", "text": "This module takes as input an N \u00d7 N sparse explicit trust matrix T e , and exploits trust propagation in order to predict, Fig. 2: 4 typical example cases under consideration for predicting user u's trust on user v. A solid line with an arrow pointing from i to j is associated with the event that t e (i, j) takes value 1. A dotted line with an arrow pointing from i to j indicates a missing value of t e (i, j) and that there exists an implicit trust of i on j, which can be inferred from T e . The lightning symbol in the 4th sub-figure indicates a cut-off of the trust information flow.\nfor every user, how much she could trust every other user. In this way, it outputs an estimated trust matrix T , the (i, j)th cell t(i, j) (if present) of which represents how much the ith user trusts the jth user. The input matrix T e has a very limited number of cells that take value 1 and all the other cells are empty with missing values. If the (i, j)th cell of T e , denoted by t e (i, j), takes value 1, it means that user i has expressed a trust statement that she trusts user j. It is worth noting that, in practical applications, the available trust data, represented as matrix T e here, would always be very sparse. This is so because no user can reasonably interact with every other user and then issue a trust statement about them.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Four categories of trust information flow patterns", "text": "We categorize the patterns of the trust information flow from user u to v into 4 complementary classes. For each class, we show a typical example in Fig. 2. The 1st sub-figure corresponds to the case in which t e (u, v) = 1. If t e (i, j) = 1, then j is called an explicit trustee of i. The 2nd sub-figure exemplifies the case in which v is not an explicit trustee of u but u and v have common explicit trustee(s). The 3rd sub-figure exemplifies the case in which v is not an explicit trustee of u, u and v have no common explicit trustee but there is at least one trust propagation path from u to v. A trust propagation path from i to j is defined by a series of user pairs {p m , p m+1 }, m = 1, . . . , M -1, M \u2208 N, which satisfies p 1 = i, p M = j, and t(p m , p m+1 ) > 0, \u2200m \u2208 {1, . . . , M -1}. This model indicates that, if user i trusts another user k to some extent and user k trusts user j to some extent, then there will be a trust propagation path from i to j. Note that this model conforms to the transitivity property of the concept of trust [9,15,16]. The 4th sub-figure is associated with the case that there is no trust propagation path from u to v.", "publication_ref": ["b8", "b14", "b15"], "figure_ref": [], "table_ref": []}, {"heading": "Trust inference procedures", "text": "First we initialize T to be a zero matrix. Given a pair of users, u and v, we first determine which one of the 4 categories presented above the pattern of the trust information flow from u to v belongs to. If it belongs to the 1st category, set t(u, v) = 1. If it belongs to the 2nd category, we estimate t(u, v) as follows\nt(u, v) = |S(u) S(v)| |S(u) S(v)| ,(6)\nwhere S(i) denotes the set of i's explicit trustees. For the case shown in the 2nd sub-figure of Fig. 2, we then have t(u, v) = 2/3. Now we focus on the case in which the pattern of the trust information flow from u to v belongs to the 3rd category. We consider every user pair {i, j} that belongs to any one of the aforementioned two categories and estimate t(i, j) correspondingly. Then we exploit trust propagation over the trust network defined by T to estimate t for user pairs associated with the 3rd category. We treat the trust matrix T as a weighted directed graph G, in which the nodes denote the users and the weight of an edge denotes the trust of the starting vertex on the end vertex. For a pair of users, say u and v, there may be multiple paths originating from u and ending at v, as exemplified in the 3rd sub-figure of Fig. 2. To compute t(u, v), we first build up a reciprocal trust matrix Tr , whose (i, j)th cell tr (i, j) = 1/ t(i, j) if t(i, j) > 0; otherwise, set tr (i, j) = \u221e. We treat the reciprocal trust matrix as a weighted directed graph G r . An exemplary show of the transformation from G to G r is presented in Fig. 3. Then we consider a shortest path problem [17], which aims to find the shortest path from u to v, denoted by SP r (u, v), in G r . The Dijkstra's algorithm [18] is employed here to find SP r (u, v).\nThen we set t(u, v) as follows\nt(u, v) = 1 M \u00d7 L(SP r (u, v)) ,(7)\nwhere L(\u2022) and M denote the length of a path and the number of nodes except the starting node included in the shortest path, respectively. For the sake of clarity, consider the case shown in the right graph of Fig. 3, for which the shortest path from u\nto v, SP r (u, v), is u \u2192 k \u2192 v, L(SP r (u, v)) = tr (u, k) + tr (k, v) = 4, M = 2 and thus t(u, v) = 1/8.\nIf the pattern of the trust information flow from u to v does not belong to any of the above mentioned categories, it then must belong to the 4th category, for which we set t(u, v) = 0. It is worth noting that, given T , the computation of t(u, v) for all cases included in the 1st, 3rd and 4th categories can be unified by a single formula as follows\nt(u, v) = 1 M \u00d7 M-1 m=1 1 t(pm,pm+1) , (8\n)\nwhere  8), we can infer that, provided all the other conditions are the same, the bigger the value of M is or the smaller the value of t(p m , p m+1 ) is, the smaller the value of t(u, v) will be, and vice versa. The above effect is consistent with our intuitive understanding of the property of transitivity in the trust type relationships between a pair of users.\np 1 = u, p M = v and p 1 \u2192 p 2 \u2192 . . . \u2192 p M is the shortest path in G r from u to v.", "publication_ref": ["b16", "b17"], "figure_ref": ["fig_1", "fig_1"], "table_ref": []}, {"heading": "Connections to related work", "text": "The iTrace algorithm proposed here finds connections to several existent TaCF methods in the literature. The algorithm architecture of iTrace falls within a generic TaCF framework presented in [9], while the implicit inference procedure of iTrace presented here is unique. In a variety of existent TaCF methods [16,[19][20][21][22], the trust score is derived from the user rating data. To this regard, trust inference and the computation of user similarity are performed based on exactly the same information source. In contrast with the aforementioned work, the iTrace algorithm employs not only the user rating data but also data other than user rating, namely the explicit user trust data. Since the explicit trust data and the rating data are processed independently, the iTrace has the advantage of making full use of two complementary views in rating prediction. Furthermore, since the trust inference procedure can be performed offline prior to calculation of user similarity, the computation time of the iTrace for online rating predictions is similar to traditional CF methods. The iTrace algorithm also finds connections to our previous work on trust modeling in the context of wireless sensor networks [23][24][25]. Although the same term trust is used, its physical meaning is different. In iTrace, the term trust represents a classical social relationship among users, while in [23][24][25], it is an artificially designed concept related to abnormal sensory behaviors caused by sensor faults.\nTo our knowledge, the most similar work to our algorithm is a trust based CF method presented in [26], which has come to our attention only recently. In contrast with [26], we provide a new and more efficient way for readers to understand the shortest path based formulation of the trust inference problem by identifying four categories of trust information flow patterns and unifying three of them by a single formula, namely Eqn. (8). In addition, we consider two different ways, namely IW and LW as specified by Eqns.( 4) and ( 5), respectively, for fusion of trust and similarity; while in [26], only one way, i.e., LW, is considered. Further, the iTrace algorithm leverages the property of trust value attenuation in the trust propagation process by adding a penalization item M to the denominator of Eqn.( 7), while the method in [26] does not take into account of such attenuation effect. Finally, through a public open dataset, we demonstrate that our iTrace algorithm outperforms the method proposed in [26].", "publication_ref": ["b8", "b15", "b18", "b19", "b20", "b21", "b22", "b23", "b24", "b22", "b23", "b24", "b25", "b25", "b7", "b25", "b25", "b25"], "figure_ref": [], "table_ref": []}, {"heading": "PERFORMANCE EVALUATION", "text": "In this section, we present experimental results, which show that the proposed iTrace algorithm outperforms existing competitor methods. We conducted empirical performance evaluations on the public dataset Filmtrust [27].", "publication_ref": ["b26"], "figure_ref": [], "table_ref": []}, {"heading": "About the dataset", "text": "The Filmtrust dataset consists of a N \u00d7M rating matrix R and an N \u00d7 N explicit trust matrix T e , associated with N = 1508 users and M = 2071 movie items. The (i, j)th cell of R is filled with user i's rating on item j if it exists; otherwise it is empty. A total number of 35416 ratings are included in R, whose values are between 0.5 and 4; and the empty cells of R are missing values to be predicted. The matrix T e is sparse in that only 1642 cells of it are filled with value 1 associated with a set of trust statements and the other cells are empty, corresponding to missing values to be predicted.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Experiment setting", "text": "The comparison methods include the traditional CF algorithm, which uses the Pearson correlation as the similarity measure, an explicit trust based TaCF (called E-TaCF for short in what follows) and a Dijkstra's algorithm based TaCF (termed D-TaCF for short in what follows) proposed in [26]. The traditional CF is included here as a baseline for performance comparison. The E-TaCF algorithm can be regarded as a simplified version of iTrace that discards the whole implicit trust inference procedure, namely, it sets T straightforward to be T e prior to the calculation of Eqn. (3). We consider two types of E-TaCF, E-TaCF-I and E-TaCF-II, corresponding to the usage of Eqn.(4) and of Eqn. (5), respectively, for fusion of similarity and trust. The missing values in T e are filled with 0 when performing E-TaCF. This E-TaCF algorithm is included here in order to demonstrate the value of the proposed implicit trust procedure. The D-TaCF is involved here as it is the most similar method in the literature to our iTrace algorithm. For iTrace and E-TaCF, we consider the IW and LW weighting mechanisms both, corresponding to Eqns.( 4) and ( 5), respectively, and the aim is to investigate which one is better for use. Apart from Eqn. (7), we also considered another way to calculate t(u, v) by\nt(u, v) = 1/L(SP r (u, v)). (9\n)\nThe purpose is to demonstrate that taking account of the attenuation feature of trust via Eqn.( 7) is beneficial for improving accuracy in recommendations. To summarize, we considered in total 4 types of iTrace as shown in Table 1. ", "publication_ref": ["b25", "b2", "b4", "b6"], "figure_ref": [], "table_ref": ["tab_1"]}, {"heading": "Experiment results", "text": "In our experiment, the number of voting users K takes values in {5, 10, 15, 20, 25, 30, 35, 40, 45}, and for every K value, a cross validation type test for every comparison method is performed. We partition the sample of rating data into two complementary subsets, perform the user similarity analysis on one subset, which occupies 80% of the whole dataset, hiding the other 20% ratings and trying to predict them. The predicted rating is then compared with the real rating and the difference (in absolute value) is the prediction error. The mean absolute error (MAE) is adopted as the performance measure.\nTo reduce variability, we perform 5 rounds of the above operations using different partitions for each algorithm, and the prediction results are averaged over the rounds. For the sake of fairness in comparison, we try different \u03b1 values and then select the optimal value 0.3 for use for iTrace-III and iTrace-IV.\nThe comparison result, in terms of averaged MAE per rating prediction, is presented in Fig. 4. It is shown that trust based methods outperform the traditional CF significantly and that the iTrace-I algorithm beats all the other competitors. It also indicates that Eqn.( 4) is preferable to Eqn. (5) and Eqn.( 7) is preferable to Eqn. (9) for use in implementing iTrace. Note that, since the implicit trust inference procedure is performed offline, the computation time of iTrace for online rating prediction is similar to the traditional CF method. ", "publication_ref": ["b4", "b8"], "figure_ref": ["fig_2"], "table_ref": []}, {"heading": "CONCLUSIONS", "text": "In this paper, we proposed an improved CF algorithm termed iTrace, which is featured by an embedded powerful implicit trust inference method. This method can estimate the implicit trust relationship between a pair of users based on available but very limited explicit trust information among users. The result from an extensive experiment on a public dataset demonstrates the superiority of our algorithm to existent competitors. Future work lies in using the proposed technique to analyze more datasets. How to model and employ more social interactions among users and the temporal dynamics in the users' rating behaviors to improve CF is also a promising topic for future investigation.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Recommender systems", "journal": "Communications of the ACM", "year": "1997", "authors": "P Resnick; H R Varian"}, {"ref_id": "b1", "title": "Item-based collaborative filtering recommendation algorithms", "journal": "", "year": "2001", "authors": "B Sarwar; G Karypis; J Konstan; J Riedl"}, {"ref_id": "b2", "title": "Evaluating collaborative filtering recommender systems", "journal": "ACM Transactions on Information Systems", "year": "2004", "authors": "J L Herlocker; J A Konstan; L G Terveen; J T Riedl"}, {"ref_id": "b3", "title": "Advances in collaborative filtering", "journal": "Springer", "year": "2015", "authors": "Y Koren; R Bell"}, {"ref_id": "b4", "title": "An algorithmic framework for performing collaborative filtering", "journal": "ACM", "year": "1999", "authors": "J L Herlocker; J A Konstan; A Borchers; J Riedl"}, {"ref_id": "b5", "title": "Empirical analysis of predictive algorithms for collaborative filtering", "journal": "Morgan Kaufmann Publishers Inc", "year": "1998", "authors": "J S Breese; D Heckerman; C Kadie"}, {"ref_id": "b6", "title": "Unifying user-based and item-based collaborative filtering approaches by similarity fusion", "journal": "ACM", "year": "2006", "authors": "J Wang; A P De; M J Vries;  Reinders"}, {"ref_id": "b7", "title": "Merging trust in collaborative filtering to alleviate data sparsity and cold start", "journal": "Knowledge-Based Systems", "year": "2014", "authors": "G Guo; J Zhang; D Thalmann"}, {"ref_id": "b8", "title": "Trust-aware collaborative filtering for recommender systems", "journal": "Springer", "year": "2008", "authors": "P Massa; P Avesani"}, {"ref_id": "b9", "title": "Trust-aware recommender systems", "journal": "ACM", "year": "2007", "authors": ""}, {"ref_id": "b10", "title": "Recommender systems handbook", "journal": "Springer", "year": "2015", "authors": "F Ricci; L Rokach; B Shapira; P B Kantor"}, {"ref_id": "b11", "title": "Trust in recommender systems", "journal": "ACM", "year": "2005", "authors": "J O'donovan; B Smyth"}, {"ref_id": "b12", "title": "Improving recommendation accuracy by clustering social networks with trust", "journal": "Recommender Systems & the Social Web", "year": "2009", "authors": "T Dubois; J Golbeck; J Kleint; A Srinivasan"}, {"ref_id": "b13", "title": "Improving recommendation accuracy by combining trust communities and collaborative filtering", "journal": "ACM", "year": "2014", "authors": "X Ma; H Lu; Z Gan"}, {"ref_id": "b14", "title": "Trust and transitivity: how trust-transfer works", "journal": "", "year": "2012", "authors": "R Falcone; C Castelfranchi"}, {"ref_id": "b15", "title": "Alleviating the sparsity problem of collaborative filtering using trust inferences", "journal": "Trust Management", "year": "2005", "authors": "M Papagelis; D Plexousakis; T Kutsuras"}, {"ref_id": "b16", "title": "Faster algorithms for the shortest path problem", "journal": "Journal of the ACM", "year": "1990", "authors": "R K Ahuja; K Mehlhorn; J Orlin; R E Tarjan"}, {"ref_id": "b17", "title": "Dijkstras shortest path algorithm", "journal": "Journal of Formalized Mathematics", "year": "2003", "authors": "J.-C Chen"}, {"ref_id": "b18", "title": "Supporting trust in virtual communities", "journal": "IEEE", "year": "2000", "authors": "A Abdul-Rahman; S Hailes"}, {"ref_id": "b19", "title": "Trust-based collaborative filtering", "journal": "Springer", "year": "2008", "authors": "N Lathia; S Hailes; L Capra"}, {"ref_id": "b20", "title": "Using trust in collaborative filtering recommendation", "journal": "Springer", "year": "2007", "authors": "C.-S Hwang; Y.-P Chen"}, {"ref_id": "b21", "title": "A model of trust derivation from evidence for use in recommendation systems", "journal": "", "year": "2004", "authors": "G Pitsilis; L F Marshall"}, {"ref_id": "b22", "title": "Toward reliable data analysis for internet of things by bayesian dynamic modeling and computation", "journal": "IEEE", "year": "2015", "authors": "B Liu; Z Xu; J Chen; G Yang"}, {"ref_id": "b23", "title": "Online fault-tolerant dynamic event region detection in sensor networks via trust model", "journal": "IEEE", "year": "2017", "authors": "J Wang; B Liu"}, {"ref_id": "b24", "title": "State space model based trust evaluation over wireless sensor networks: An iterative particle filter approach", "journal": "The Journal of Engineering", "year": "2017", "authors": "B Liu; S Cheng"}, {"ref_id": "b25", "title": "Trust-based collaborative filtering algorithm in social network", "journal": "IEEE", "year": "2016", "authors": "X Chen; Y Guo; Y Yang; Z Mi"}, {"ref_id": "b26", "title": "Filmtrust: Movie recommendations using trust in web-based social networks", "journal": "", "year": "2006", "authors": "J Golbeck; J Hendler"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Fig. 1 :1Fig. 1: Architecture of the iTrace algorithm. The inputs of the algorithm include an N \u00d7 N explicit trust matrix and an N \u00d7 M rating matrix. N and M denote the number of the users and of the items, respectively.", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Fig. 3 :3Fig. 3: An example show of the transformation from a weighted directed graph (the left panel) to its reciprocal counterpart graph (the right panel). The edge weight in the right graph is the reciprocal of the weight in the left graph.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Fig. 4 :4Fig. 4: Averaged MAE per rating prediction.", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "4 types of the iTrace algorithm under consideration", "figure_data": "iTrace-I iTrace-II iTrace-III iTrace-IVchoice for fEqn.(4)Eqn.(4)Eqn.(5)Eqn.(5)choice for t(u, v)Eqn.(7)Eqn.(9)Eqn.(7)Eqn.(9)"}], "formulas": [{"formula_id": "formula_0", "formula_text": "r u,i = ru + v\u2208U w(u, v)(r v,i -rv ) v\u2208U |w(u, v)| ,(1)", "formula_coordinates": [1.0, 358.2, 364.29, 200.84, 26.05]}, {"formula_id": "formula_1", "formula_text": "(u, v) = i\u2208I (r u,i -ru )(r v,i -rv ) i\u2208I (r u,i -ru ) 2 i\u2208I (r v,i -rv ) 2 , (2", "formula_coordinates": [1.0, 334.98, 571.65, 220.15, 27.01]}, {"formula_id": "formula_2", "formula_text": "r u,i = ru + v\u2208U f (sim(u, v), t(u, v))(r v,i -rv ) v\u2208U |f (sim(u, v), t(u, v))| ,(3)", "formula_coordinates": [2.0, 344.76, 242.73, 214.28, 37.96]}, {"formula_id": "formula_3", "formula_text": "f (sim(u, v), t(u, v)) = sim(u, v) t(u, v) j\u2208U sim(u, j) t(u, j) .(4)", "formula_coordinates": [2.0, 341.28, 368.85, 217.76, 28.09]}, {"formula_id": "formula_4", "formula_text": "f (sim(u, v), t(u, v)) = \u03b1sim(u, v) j\u2208U sim(u, j) + (1 -\u03b1) t(u, v) j\u2208U t(u, j) ,(5)", "formula_coordinates": [2.0, 318.0, 449.01, 241.04, 37.96]}, {"formula_id": "formula_5", "formula_text": "t(u, v) = |S(u) S(v)| |S(u) S(v)| ,(6)", "formula_coordinates": [3.0, 386.28, 278.97, 172.76, 23.64]}, {"formula_id": "formula_6", "formula_text": "t(u, v) = 1 M \u00d7 L(SP r (u, v)) ,(7)", "formula_coordinates": [3.0, 375.72, 587.85, 183.32, 23.89]}, {"formula_id": "formula_7", "formula_text": "to v, SP r (u, v), is u \u2192 k \u2192 v, L(SP r (u, v)) = tr (u, k) + tr (k, v) = 4, M = 2 and thus t(u, v) = 1/8.", "formula_coordinates": [3.0, 315.24, 664.05, 243.78, 23.76]}, {"formula_id": "formula_8", "formula_text": "t(u, v) = 1 M \u00d7 M-1 m=1 1 t(pm,pm+1) , (8", "formula_coordinates": [4.0, 104.88, 282.21, 189.49, 27.57]}, {"formula_id": "formula_9", "formula_text": ")", "formula_coordinates": [4.0, 294.37, 289.67, 3.91, 8.91]}, {"formula_id": "formula_10", "formula_text": "p 1 = u, p M = v and p 1 \u2192 p 2 \u2192 . . . \u2192 p M is the shortest path in G r from u to v.", "formula_coordinates": [4.0, 54.48, 321.45, 243.75, 22.33]}, {"formula_id": "formula_11", "formula_text": "t(u, v) = 1/L(SP r (u, v)). (9", "formula_coordinates": [5.0, 122.52, 236.13, 171.85, 12.25]}, {"formula_id": "formula_12", "formula_text": ")", "formula_coordinates": [5.0, 294.37, 238.78, 3.91, 8.91]}], "doi": ""}
