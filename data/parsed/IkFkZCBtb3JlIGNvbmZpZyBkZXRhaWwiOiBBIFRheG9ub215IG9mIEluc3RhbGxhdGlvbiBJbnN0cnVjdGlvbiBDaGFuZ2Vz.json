{"title": "\"Add more config detail\": A Taxonomy of Installation Instruction Changes", "authors": "Haoyu Gao; Christoph Treude; Mansooreh Zahedi", "pub_date": "", "abstract": "README files play an important role in providing installation-related instructions to software users and are widely used in open source software systems on platforms such as GitHub. However, these files often suffer from various documentation issues, leading to challenges in comprehension and potential errors in content. Despite their significance, there is a lack of systematic understanding regarding the documentation efforts invested in README files, especially in the context of installation-related instructions, which are crucial for users to start with a software project. To fill the research gap, we conducted a qualitative study, investigating 400 GitHub repositories with 1,163 README commits that focused on updates in installation-related sections. Our research revealed six major categories of changes in the README commits, namely pre-installation instructions, installation instructions, post-installation instructions, help information updates, document presentation, and external resource management. We further provide detailed insights into modification behaviours and offer examples of these updates. Based on our findings, we propose a README template tailored to cover the installation-related sections for documentation maintainers to reference when updating documents. We further validate this template by conducting an online survey, identifying that documentation readers find the augmented documents based on our template are generally of better quality. We further provide recommendations to practitioners for maintaining their README files, as well as motivations for future research directions. These recommendations and research directions encompass completeness, correctness and up-to-dateness, and information presentation consideration. The proposed research directions span the development of automated documentation tools and empirical studies to enhance comprehension of the needs of documentation users.", "sections": [{"heading": "INTRODUCTION", "text": "Good software documentation serves as a vital source of information for different stakeholders involved in software systems. In particular, README files are among the first software documents that users, such as other developers and end-users, and newcomers encounter when accessing an Open Source Software (OSS) project, leaving them with a crucial first impression and providing them with an introductory overview of the project [1], [2]. At the time of this study, GitHub, the most popular open source code platform, hosts more than 372 million repositories, 1 underscoring the high demand for maintaining high quality README files.\nOne of the most common types of content in GitHub README files is related to basic instructions (e.g., project installation guide) [1]. A well-written \"How\" section could alleviate the effort for developers and users, especially newcomers, to get hands-on with the projects. In fact, overcoming the challenge of setting up an environment is one of the hurdles for newcomers to contribute to OSS projects [3].\nHowever, software tutorials that focus on installing software tools, configuring virtual computing environments, and other related continuous deployment processes have been found to not be executable in more than half of the cases investigated by related work [4]. Furthermore, previous empirical studies identified inappropriate installation instructions, outdated content, and content clarity as frequently appearing documentation issues [5], [6]. These factors collectively constitute the impediments for both de-1. http://web.archive.org/web/20230424004513/https://en. wikipedia.org/wiki/GitHub velopers and project users to effectively use the software repositories.\nAlthough previous studies have pinpointed software documentation issues, particularly in installation-related topics [5], [6], [7], their analyses were broad in scope, with the aim of synthesising different aspects of documentation issues from surveys or software documents. In contrast, documentation updates provide a new perspective consisting of the modifications and two states: before and after the modification. In fact, increased documentation activities and efforts have demonstrated their efficacy in improving the popularity of and encouraging the participation in GitHub projects [8]. Considering the documentation issues and the benefits of investing efforts to maintain high-quality documentation, knowledge of the practices of the README file efforts becomes essential. This knowledge not only can provide practitioners with recommendations, but can also provide researchers with insight for the development of automated documentation tools. However, empirical evidence to support practices related to software documentation efforts remains scarce.\nIn this work, we conducted an empirical study to qualitatively analyse README file modification activities in installation-related topics to fill the research gap. We mined GitHub repositories from GHArchive 2 that were active between 2015-01-01 and 2023-02-28, applying stringent filters on different features for the repositories, resulting in 12,908 projects. We examined a statistically significant sample of 1,168 README file commits within 400 randomly selected repositories and adopted qualitative analysis to synthesise the types of README update tasks in the modified sections.\nBased on our analysis, we synthesised a comprehensive taxonomy of 189 update behaviours, which are related to the categories of: (1) pre-installation instructions, (2) installation instructions, (3) post-installation instructions, (4) help information, (5) document presentation, and (6) external resource management. We then proposed a README template tailored to cover the installation-related sections for documentation maintainers to reference when updating documents. The template validation process indicates that readers find README files that apply our template to be of generally increased quality. This serves as a fundamental step towards automated documentation updates. We further discussed their implications for documentation maintainers and software engineering researchers based on our discoveries from perspectives of completeness, correctness and upto-dateness, and information presentation considerations.\nOur key contributions are as follows: (1) A large-scale repository dataset, which can be used for future research.\n(2) Formalisation of a detailed list of software development tasks related to README file content. (3) A comprehensive taxonomy for the types of installation-related documentation modifications for OSS projects. (4) A README template validated by documentation readers to be of better quality compared to original README files. (5) Actionable recommendations for OSS documentation maintainers and researchers.\nThe rest of the paper is structured as follows: Section 2 covers the related work; Section 3 introduces our study design and methodology adopted to conduct our study; Section 4 presents the results of our qualitative analysis for the installation instruction taxonomy; Section 5 provides the README template from our study and its validation process with an online survey; Section 6 discusses the implication of this study to practitioners and researchers; Section 7 covers the threats to the validity of our study; Section 8 provides the conclusion; and Section 9 includes the replication package link to our GitHub repository.", "publication_ref": ["b0", "b1", "b0", "b2", "b3", "b4", "b5", "b4", "b5", "b6", "b7", "b4"], "figure_ref": [], "table_ref": []}, {"heading": "RELATED WORK", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Empirical Studies on Software Documentation", "text": "Various empirical studies have been conducted to cover software documentation from different perspectives.\nOne source of information for researchers is directly from software engineering practitioners. Several studies have investigated the impact of software documentation. Kajiko-Mattson [9] studied the practices of software documentation in Swedish organisations, identifying rudimentary documentation requirements relevant within corrective maintenance. Garousi et al. [10] conducted an industrial case study on the usage and usefulness of different documentation artefacts in the software development life cycle. Their findings indicated variations in documentation usage based on information needs, and the recommendations derived from their study have been integrated into the company's practices where the experiment took place. Software documentation issues are also investigated. Uddin and Robillard [11] conducted a large-scale survey on API documentation failure factors among IBM practitioners, and identified the most pressing issue related to content, as opposed to presentation. Aghajani et al. [6] presented the views of practitioners on various issues of software documentation, along with their proposed solutions to address these issues. Moreover, the quality of software documents is another perspective that has been studied. Treude et al. [12] recruited technical editors and synthesised a framework to assess the quality of the software documentation from the respondents. Their work provides visions for a potential unified quality framework for assessing software documentation.\nHowever, these studies are limited in their context (e.g., practitioners' organisation and knowledge or software artefacts), making it difficult to generalise the results to broader software documentation artefacts. Another source of information for researchers lies in these software artefacts themselves. Different software documentation artefacts have been evaluated, revealing a series of issues. Wen et al. [13] conducted a large-scale empirical study of code-comment inconsistencies, identifying the taxonomy of inconsistencies fixed by developers. Mirhosseini and Parnin [4] evaluated the executability of software tutorials and discussed the categories of errors that can lead to the failure of code block executions. Aghajani et al. [5] conducted a qualitative study on software documentation issues from Stack Overflow, GitHub issues, GitHub pull requests, and mailing lists, identifying both content and process issues.\nAmong the software documentation artefacts, README files play an important role in introducing OSS repositories. They are relatively easy to access, with a rich content editing history. Despite their significance, README files have received relatively less attention in research, and most existing work focuses on more abstract perspectives, such as the structure and content topics. Prana et al. [1] conducted a qualitative study involving manual annotation of 4,226 README file sections to categorise README content into different purposes. Liu et al. [14] studied the patterns adopted for README files by GitHub Java repositories and investigated the association between repository popularity and README file structures. The study identified 32 clusters representing common README file structures, and the findings suggested that repositories adhering to GitHub guidelines for README files tend to get more stars. Meanwhile, Wang et al. [15] investigated the factors that influence the popularity of GitHub repositories from the README file angle, and identified significant difference between popular and non-popular repositories in README file related featrues.\nThe richness of README file edit history provides us with the possibility to investigate software documents from a process perspective. In this work, we provide a more detailed study of README files centred around installationrelated instructions, considering both their content and their process, to offer concrete suggestions for documentation maintainers and researchers.", "publication_ref": ["b8", "b9", "b10", "b5", "b11", "b12", "b3", "b4", "b0", "b13", "b14"], "figure_ref": [], "table_ref": []}, {"heading": "Automated Tools for Software Documentation", "text": "Inspired by various empirical pieces of evidence regarding the roles and issues of software documentation, there has been much research on automated tool support for software documentation.\nPrevious research focuses on supporting various software documentation artefacts with non-documentation artefact, such as source code. To begin with, code summarisation is an actively evolving field, with techniques developed for generating code comments [16], [17], [18], [19], commit messages [20], [21], [22], code reviews [23], [24] and release notes [25], [26]. Technical debt, including code comment inconsistency detection [27], [28], and self-admitted technical debt [29], [30], is also investigated to facilitate software maintenance.\nEfforts have also been made to improve and augment software documentation content and navigation across this content. Treude and Robillard [31] investigated a technique for augmenting the content of API documents by incorporating information from Stack Overflow. Treude et al. [32] extracted development tasks from software documents, helping bridge the gap between software documentation and the information needs of software developers. Gao et al. [33] mined README files from GitHub and performed transfer learning to simplify complicated documentation sentences. In fact, Robillard et al. [34] have proposed a paradigm shift for automatic documentation generation based on developers' queries, given their contexts.\nHowever, to facilitate more effective automated documentation-writing tools, it is essential to have a deeper understanding not only of the software documentation artefacts, but also of the patterns of behaviours associated with their updates. In this work, we conducted qualitative analysis of installation-related documentation update behaviours, with the aim of gaining a deep understanding and providing motivation for developing automated software tools for documentation writing.", "publication_ref": ["b15", "b16", "b17", "b18", "b19", "b20", "b21", "b22", "b23", "b24", "b25", "b26", "b27", "b28", "b29", "b30", "b31", "b32", "b33"], "figure_ref": [], "table_ref": []}, {"heading": "OSS Barriers and Project Installation", "text": "The term \"installation\" is widely used in different contexts. A simple installation procedure only requires fetching a remote binary file, while a complicated situation would confirm that minimum system requirements are met, identify and resolve shared library dependencies, verify the integrity of each downloaded component, and other procedures [35]. Due to the absence of a precise definition of installation-related instructions, we define them to encompass all procedures occurring after the environment setup and the preceding project usage phase in this paper.\nRecent studies [3], [36] have highlighted both documentation problems and the configuration of the development environment as barriers for newcomers when they first contribute to Open Source Software (OSS) repositories. Salerno et al. [37] discovered that student self-efficacy improves as a result of participating in OSS courses, but simultaneously they also perceive an increase in documentation issues. In particular, one of the identified issues revolves around the challenges associated with setting up the development environment.\nMoreover, another study [1] pointed out that the major content category of README files is \"How\", which includes instructions from setting up the environment to installation and running the project. Therefore, README files play a vital role in guiding newcomers and software users for installation-related topics.\nIn contrast to previous research focusing on the human perspective of OSS barriers for newcomers, this work synthesises empirical evidence on software documentation activities, specifically on parts related to the installation, based on evidence derived from a large-scale dataset that we mined. Such empirical evidence will be useful to mitigate documentation-related barriers for newcomers when engaging with OSS projects.", "publication_ref": ["b34", "b2", "b35", "b36", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "STUDY DESIGN AND METHODOLOGY", "text": "The goal of this study is to investigate how installationrelated instructions in README files are updated. We formulate two research questions (RQs) to guide our study:\nRQ1: How are installation sections in README files modified? This RQ will reveal different modification behaviours for updating the documentation. We studied the documentation modification behaviour rather than the most recent version of README files because the modification behaviours not only provide the documentation structure and contents, but also offer more insights into the documentation maintenance efforts on OSS repositories. By understanding the documentation maintenance practice, we could provide implications to practitioners and researchers for better maintaining the README files. We perform qualitative analysis of the installation-related sections within our mined data to answer this question. One of the target outcomes from this RQ is a template encompassing all essential components to facilitate better documentation activities for the maintainers.\nRQ2: Could a template for installation instructions be devised to improve documentation quality? This research question aims to validate our proposed README template, which is the fundamental first step towards automated documentation updates. We conduct a survey asking participants to evaluate the perceived documentation quality before and after applying the README template, based on an established documentation assessment framework [12].", "publication_ref": ["b11"], "figure_ref": [], "table_ref": []}, {"heading": "Data Preparation", "text": "In this paper, we only consider GitHub repositories that use Python or Java as their main programming language. Python and Java are two widely used programming languages that span a broad range of applications, from developing easy-to-use tools to large-scale servers. In fact, Python and Java consistently rank among the top three most used programming languages on GitHub 3 , following JavaScript.\nAlthough the GitHub API provides access to its data, the rate limit is not enough for extensively collecting all repositories that meet our needs. Therefore, we used GH Archive, 4 which collects GitHub data based on the Event API. Figure 1 describes our overall repository collection procedure.\nAs our focus is on update behaviours, we started with commits rather than repository content. In addition, we want the repositories retrieved to contain a history of updating their installation-related instructions. Therefore, we looked at the \"PushEvent\" in the data records, and retrieved Step 1: Extract repository based on commit keywords.\nStep 2: Remove fork projects and projects without pull requests.\nStep 3: Only preserve projects that use Python or Java.", "publication_ref": [], "figure_ref": ["fig_5"], "table_ref": []}, {"heading": "N=28,896", "text": "Step 4: Preserve projects that have over 500 commits and 10 stars.\nStep 5: README commit filter and additional outlier filters.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "N=12,908", "text": "Fig. 1: Data Preparation Process those with commit messages containing keywords that we pre-defined after tokenisation and lemmatisation. Keywords were derived from four base keywords \"instruct\", \"guide\", \"install\" and \"deploy\". These terms were chosen to represent the content genres and topics that we aimed to include in our analysis. They were further combined with tags used in Zahedi et al. [38]. We expand the set of keywords by finding both the noun and verb forms of words in WordNet [39]. This procedure resulted in a total of 21,238,948 repositories.\nAfter that, we preserved only 5,335,695 repositories that are not forks and have at least one pull request in the history. Further refinement was applied, narrowing down the selection to 886,365 by considering repositories that use Python or Java as their primary programming language. As the aim of this study is to investigate modifications within the README file, we focus only on repositories with at least 500 commits [13] to obtain repositories that went through code changes in different phases of the software development lifecycle. In this way, the README updates ideally capture a broader range of changes. In contrast, most repositories have fewer than 500 commits. Sampling from the entire population would give higher weight to repositories with fewer commits, potentially leading to less diversity in the types of change reflected in README updates. We also used 10 stars as a threshold for eliminating toy projects [40]. This further reduces the number of repositories to 28,896. The earlier keyword filtering was applied to all commit messages without considering the semantics of changes specifically made to README files. Therefore, we further applied a filter on the README-changing commits, requiring them to have at least one occurrence in the keyword set, which decreased the dataset size to 14,958 records.\nThere are caveats that need to be taken care of when mining software repositories on GH Archive. First, some repositories are no longer available, either because they have been deleted or made private by their owner. We found 254,236 of these repositories and ignored them in our analysis. Second, due to renaming and other factors, some repositories are redirected by the GitHub API to alternative names, potentially causing duplicate repository issues. We further eliminated these repositories, reducing the number of repositories to 13,245.\nIn the last step, we removed outliers that fall outside of the scope of this study. We used FastText [41] to filter out 292 repositories with non-English README content. We manually inspected the repositories included after these filtering steps and found that there were some non-software repositories in there. Non-software repositories refer to projects primarily contain content other than traditional Fig. 2: Ratio of non-software repositories among top n repositories software code. These repositories may include, but are not limited to, collections of awesome lists, educational materials, and personal websites. To exclude those systematically, we considered several factors that might indicate nonsoftware projects, including (1) README commits to overall commits ratio, (2) number of README commits, (3) number of README commits per day, and (4) repository size. We sorted the repositories by these factors in descending order and manually labelled the top 100 records for each factor, respectively. Figure 2 illustrates how the percentage of nonsoftware repositories varies as more projects are included. Although the number of README commits can identify the most unrelated repositories, the accuracy is merely 51% for the top 100 entries. Meanwhile, regarding README commits to overall commit ratio, a plateau on the left side of the red vertical line indicates a consistent high accuracy of identifying non-software projects, with the red line representing the percentage of 52.9% of this ratio. Therefore, we rounded the ratio to 50%, used it as a threshold, and discarded these repositories, eventually obtaining a dataset consisting of 12,908 repositories.", "publication_ref": ["b37", "b38", "b12", "b39", "b40"], "figure_ref": ["fig_5"], "table_ref": []}, {"heading": "README Commit Classification", "text": "We randomly sampled 400 repositories from the entire population, ensuring a confidence level above 95%. For the 400 repositories sampled, there are 25,209 README commits in total, which need to be classified as \"relevant\" or \"irrelevant\" to the installation-related instructions. Given the prohibitively large number for manual annotation, we employed a semi-automated heuristic to significantly reduce the manual workload for identifying the relevant README updates.\nSpecifically, we extracted the different scales of headers from the sampled README files in their commit histories, with scales ranging from \u27e8h1\u27e9 to \u27e8h6\u27e9. We considered the occurrence of a particular header as one if it appeared at least once in the commit history. All repositories have at least one header, and Table 1 shows the distribution of header scales. Almost every repository has level 1 and level 2 headers, while level 3 and level 4 headers are also quite common. In contrast, the frequency of level 5 and level 6 headers is scarce. A closer examination identifies that level 5 and 6 do not convey meaningful document structural information; instead, some of them are used merely for emphasis within the text. The basic idea of our heuristics is that README headers work as an overview of the contents beneath them. By examining the section headers, we can discern whether the sections are relevant to our target without delving into the detailed content. Therefore, we extracted the 100 most frequently occurring headers from \u27e8h1\u27e9 to \u27e8h4\u27e9, along with the 100 most frequently occurring word tokens. Three authors independently annotated these headers and tokens into categories of \"relevant\", \"irrelevant\" or \"not sure\". Agreement on the annotations was achieved through discussions in regular meetings. In total, we identified 66 relevant headers, 14 relevant keywords, and 177 irrelevant headers. These keywords and headers are also made available in our replication package.\nBased on the information obtained from the headers, we developed semi-automated labelling heuristics implemented as a program. Starting from the \u27e8h1\u27e9 headers, this program recursively examines whether the modified sections in the README commit are in the \"relevant\" set or not. If any of the modified sections has a \"relevant\" header, the program will mark the commit as relevant. Conversely, if all modified sections are categorised under the \"irrelevant\" headers, the commit is marked accordingly as irrelevant. Otherwise, the program cannot determine and proceeds to the next level of headers, repeating the decision process. If it still cannot ascertain the relevance after inspecting the headers at level 4, it assigns a \"not sure\" label, indicating that human annotation is required.\nTo verify the accuracy of this program, we manually annotated four repositories, and the program reached an accuracy of 92.4% (133/144). Subsequently, we applied this program to all repositories, resulting in 7,161 relevant, 8,583 irrelevant and 9,465 \"not sure\" commits generated by the semi-automatic labelling heuristics.\nTo annotate the data points categorised as \"not sure\", the first author randomly selected 50 records and three authors independently performed the annotation. The outcome of the annotation reached a Fleiss' Kappa score of 0.69, indicating a good level of agreement. Three authors further discussed the disagreed entries and came to an eventual agreement. Subsequently, the first author continued to annotate the remaining commits. Finally, within the dataset of 25,230 README commits, 8,673 commits were identified as relevant and 16,557 as irrelevant. The high accuracy rate (over 92.4%) and high recall (82.6%) indicate that our heuristic is quite capable of categorising the README documentation.", "publication_ref": [], "figure_ref": [], "table_ref": ["tab_1"]}, {"heading": "Dataset Characteristics", "text": "Before the details of the data analysis, we briefly introduce the characteristics of our curated dataset. The 8,673 identified relevant commits from the previous step cover 378 of 400 sampled repositories, that is, 94.5% of the repositories contain at least one README commit modifying installation-related sections. To assess whether we had missed relevant installation-related documents, for each repository, we further searched \"INSTALL.md\", \"INSTALLATION.md\", \"docs/INSTALL.md\", and \"docs/INSTALLATION.md\" within its project folder (case insensitive), and consider them as additional installation documents other than the default README file. Only two repositories contain additional installation document. Based on this observation, the majority of repositories in our analysed dataset use README file as the primary installation documentation source, and the provided installation steps in README file thus serve as the primary source for documentation users to access them. This observation further motivates us to focus on the analysis of README file.\nRegarding the representativeness of our analysed repositories, we selected three measures, namely repository size, total number of pull requests, and total number of issues in the repository. The repository size serves as a proxy for the complexity of the project, while the other measures quantify project's interaction with its users. We accessed Java and Python repositories on Github with above 2,000 stars using GHS [40]. The 2,000 stars threshold was also used in previous study [42] when trying to build an Automatic Program Repair dataset, with the aim to collect data from popular repositories. Figure 3 shows the box plot for these three measures in our data and the repositories having above 2,000 stars. Their distribution are similar according to the figure. This shows that our analysed projects are comparable to popular GitHub projects in terms of their scale and user interactions.\nOn average, each repository contains 23 relevant README commits, with a standard deviation of 25.7, indicating a skewed distribution. Specifically, with a minimum of 1 and a maximum of 224, the 25th, 50th, and 75th percentiles are 8, 14 and 31 commits, respectively.\nFor the qualitative study, we need to obtain a sample from the data. However, due to the skewed distribution of README commits across repositories, a completely random sample would result in a dataset dominated by repositories with a large number of README commits, thereby reducing diversity across repositories.\nTherefore, we performed a cluster sampling [43], splitting the dataset into four clusters: repositories with README commits from the minimum to the first quantile, from the first quantile to the second quantile, from the second quantile to the third quantile, and from the third quantile to the maximum. Within each cluster, we performed a random sample with the sample size required to achieve a 95% confidence level (confidence interval: 5), resulting in samples of 206, 280, 324, and 358 README commits for each respective cluster. In total, we conducted a large-scale qualitative study on 1,168 README commits.\nWe calculated the correlation coefficient between the number of relevant README commits and the number of stars, as well as with the number of years the project has existed. The Pearson correlation coefficient reached 0.19 and 0.01, respectively. This statistic indicates that projects that actively participate in documentation activities, particularly for the installation-related sections, have a positive correlation to the project's popularity, while the number of relevant README commits does not necessarily grow with the years of the project. From the section level, Figure 4 shows the number of sections that are added, removed, or modified per commit on average. The figure illustrates that the README updates mostly focus on sections in the top two hierarchies of headers, while the modification operation is much more frequent than the addition and removal operations.\nBased on the results of Figure 4, we visualised the top 20 most updated keywords within the section headers at the first two levels to have a better understanding of the updated sections. The heat maps are presented in Figure 5.\nFrom the figures, it is clear that more addition and removal operations are conducted on the level 2 hierarchy, while most sections are related to themes including installation, usage, build, setup and running.", "publication_ref": ["b39", "b41", "b42"], "figure_ref": ["fig_1", "fig_2", "fig_2"], "table_ref": []}, {"heading": "Data Analysis", "text": "We conducted a qualitative study of the annotated data to answer our research question. Specifically, we synthesised a comprehensive taxonomy of 6 categories, consisting of 189 different codes. The findings provide a comprehensive understanding of the nature of the modifications with rich implications for practitioners and researchers. We adopted open coding [44] for qualitatively analysing the update events. The first author conducted the data analysis and created spreadsheets containing all raw data and codes. The spreadsheets were shared among all authors, and the second and third authors cross-validated all codes, concepts, and categories to reduce bias and increase the reliability of the findings [45]. Concepts and categories were discussed among authors through regular meetings and finalised after several rounds of revisions.\nWe started our analysis by searching each commit on GitHub and recording the text summarising the changes from the perspective according to our research question: the updates for the installation-related sections. We call this process \"key points extraction and getting familiar with the data\". Then we rigorously performed open coding to assign each README commit with one to many succinct descriptions of their update modifications. This process took into account both the key points that were extracted and the content of the README commits themselves. The additional investigation into the raw README commit data is to address any unclear key points and to double-check whether any part of the modification is missing.\nDuring the coding procedure, we constantly compared the emerging codes within and across different README commits to synthesise a higher level of abstraction called concepts, and later the highest level of abstract called categories. Figure 6a illustrates examples of the procedure of generating one of the categories called \"Pre-installation Instruction Updates\". Figures 6b and Figure 6c further explain the process for how we assign codes for different changes within the commit. We have made our analysed data available. Please refer to Replication Package section for more details. Update programming language version description for this project Update supported/ recommended OS for install this project Add code instruction for setup virtual environment for this project.\nCategory Concepts Codes Key Points Raw Data Commit Sha\n1. In the install section, add textual instruction with external link for install maven, which will be used to install the project.\n1. Add section setup, with one subsection gcs source, with both textual and code instruction for install googlecloud-storage, with some notes on what are needed for setup this service.\n1. In section installation, update python version 1. In section bootstrap, add a subsection vituralenvs, with textual and code instruction to manage virtual environment and installation of this project and dependencies for this project.   ", "publication_ref": ["b43", "b44"], "figure_ref": [], "table_ref": []}, {"heading": "RESULTS", "text": "Table 2 presents the hierarchical taxonomy of 189 codes that we identified from the 1,168 data points to answer our RQ1.\nThe updates are categorised into six main groups: (1) preinstallation instruction;\n(2) installation-related instruction;\n(3) post-installation instruction; (4) help information; (5) document presentation; and ( 6) external resource management.\nTo give readers a better understanding of our analysed result, Figure 7 synthesises our analysis in a timeline fash-ion, corresponding to pre-installation, installation, and postinstallation, where different software development tasks are included in each phase. Moreover, various information perspectives regarding the README files are also displayed within this figure, including instruction, help information, external resource links, and document presentation. For each of the categories, we describe representative examples and discuss implications for practitioners and researchers.\nIt is worth noting that, compared to other qualitative studies [1], [5], [6], [11], our work focuses on modifications made to Markdown-formatted text, which involves two pieces of documents. Due to the substantial space required to illustrate examples of README updates, we will only include figures for a few examples. Additional examples are made accessible through URLs that we have been formatted as clickable links in Table 2. We have also included the URLs and their corresponding screenshots in our replication package.", "publication_ref": ["b0", "b4", "b5", "b10"], "figure_ref": [], "table_ref": ["tab_3", "tab_3"]}, {"heading": "Pre-installation Instruction", "text": "Pre-installation instructions, also seen as environment setup instructions, contain preparation instructions before installation. In our analysed samples, 628 out of 1,168 performed updates are related to environment setup topics in their README documents. In this category, we synthesised three concepts, which are discussed as follows: Dependency Setup (527) 5 . Dependencies enable code reuse and require maintenance effort as the project and other dependencies evolve [46]. In our analysed dataset, more than 40% of the documentation updates contain dependency-related instructional modifications, indicating the importance of this perspective.\nAmong the modifications of the dependency setup, the concept of programming language version compatibility refers to details concerning the target version of the programming language upon which the software is built, ensuring its accurate execution. Figure 8 includes examples of how the programming language version information in the README files is updated. Updates are mostly small, only reflecting the new version of the programming language that their projects are using. However, as seen in Figure 8c, when the programming language requirement information is newly added to the documentation, it means that the previous README suffered from incomplete information, and efforts are made to remedy the lack of information in the programming language requirements.\nApart from the programming language, other dependencies setup include external libraries and modules (e.g., API), as well as third-party software (e.g., database) that projects rely on. The inclusion of new features, resolution of 5. Number in the parenthesis represents the frequency of this concept.  In Example 3, the commit adds configuration instructions for the database on which the project relies. This underscores the importance of incorporating essential configuration details when dependencies are not ready for use following the dependency installation step, which is a common scenario for third-party software dependencies. Interestingly, some examples, such as commit Example 4, add guidelines to verify the success of dependency installation. This type of instruction becomes more valuable for critical dependencies, especially when the installation and configuration instructions become intricate.\nPlatform Setup (82). Platform setup information includes details for systems on which the software operates, which is the second largest updated concept for the preinstallation instructions category.\nDue to the diverse source of OSS project participants, encountering different local environments with different installed packages becomes inevitable, rendering the project installation and dependency management a challenging issue. In our analysed data, we found that 48 instances involve modification in setting up virtual environment, and a majority of them are related to newly added instructions such as the one indicated in Example 5. Furthermore, Example 6 explicitly mentions the virtual environment as their recommended way of installation of the project.\nOperating system information is another platform setup concern. As project users might come from a diverse distribution of operating systems, this information becomes a critical prerequisite before project installation and usage. We observed efforts that mostly focused on adding operating system compatibility information (e.g., BiglyBT comes in several editions for different operating systems. Mac OSX, Linux and Windows use the full BiglyBT-API based on Java 8.) or update operating system version information as indicated in Example 7, which updated the support operating system from Debian 9 and 10 to Debian 10 and 11.\nVirtual Machine and Hardware (19). Depending on the nature and usage purpose of different software repositories, hardware requirements may differ for different software projects and sometimes even require deployment on cloud servers. We observed commit updates that include hardware specification information or steps for configuring a virtual machine. It would be important to include this information for certain projects, although this does not generalise to all repositories.", "publication_ref": ["b45", "b18"], "figure_ref": [], "table_ref": []}, {"heading": "Summary of pre-installation instruction results:", "text": "The concept of dependency setup includes management of programming language version and other dependencies to reflect software system changes. However, the concept of platform setup majorly includes updates in providing virtual environment instructions and operating system information of the software project. Virtual machine and hardware instructions are less frequently encountered.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Installation-related Instruction", "text": "In this category, we synthesised two concepts, which are discussed as follows:\nInstallation-related Instructions from Source Code Operations (267). Installation from source code requires users to obtain the source code and then locally execute a set of predefined operations, encompassing compilation, building, and other procedures, to install the software project. While projects may use various technologies, including Docker, Pip, and Maven, we identified in our analysed data that source code-level installation is the most commonly adopted method which the projects tend to initially provide. In addition, the inclusion of newly added instructions also accounts for various operating systems. Given that commands for Windows systems typically differ from those for Linux, additional information in the README file instructions or even the source code is needed to facilitate a smooth installation experience for different users.\nDocumentation efforts are also observed to provide better encapsulated installation alternatives that are easier to install, as well as versions of project targeting for different user groups. For example, in commit Example 8, the installation option initially provided includes obtaining the source code and performing compilation. The newly added instruction introduces an alternative approach specifically for building and running a Docker image from the Dockerfile within the source code. This provides an integrated installation experience, alleviating concerns related to compilation and other dependency management issues.\nRegarding the update behaviours for the installation instructions from source code, a wide range of patterns are identified, which are more project-specific. For example, modifications within code instructions covering project name, file path for executables, and configuration file names are usually trivial, reflecting changes at the file level and repository level. A simple example in commit Example 9 migrated the codebase from GitLab to GitHub, while also changing the project name from atoml-local to catlearn, leading to the corresponding adjustment of the commands in the README file. Updates to the source code installation option also involve adjustments of parameters, with various patterns observed for this type of change. As an illustrative example, commit Example 9 altered the Docker compose command with an additional \"-d\" command indicating a detached mode to run the Docker container.\nInstallation-related Instructions from Published Package Operations (162). In contrast, users can also install software and libraries from package management systems, such as Pip, Conda, and Maven, which enable an easier installation experience. Published package installation instructions are typically not the first option OSS developers incorporate in their system, considering the additional effort required to configure the distribution binary on package management systems. In our analysed data, only 33% of the newly added published package installation instructions do not have other installation alternatives in their previous README files. For example, in commit Example 10, a new alternative was added to install the project through PyPI, which is a package management system. However, alternative options for source code level installation were already provided in the previous README file, making the newly added published package installation option an additional choice.\nRegarding the update operations within the published package installation instructions, we identified a predominant pattern which focuses on updating the project version. Trivial updates are usually found in this type of modification, with merely a version number increment for repository's latest stable version, and sometime combined with development version. For example, both the stable version and the snapshot version were incremented within the code instruction for the Maven dependency of the repository in this commit Example 11.\nApart from the version modification, other noticeable update operations for published package installation include changes for package names or package source and changes for package management technology instructions. For example, the path to the image on DockerHub was updated in commit Example 12, reflecting the changes in the source of the project. As an example of the change in technology instruction, in commit Example 13, the Gradle command compile is updated to implementation as the previous keyword was deprecated. The rest of the updates are more specific to reflect the project development status.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Summary of installation-related instruction results:", "text": "The concept of installation-related instruction from source code operation is the most commonly-adopted choice in our analysed data. Their update behaviours varies, covering factors including project meta-data changes and parameter changes. On the other hand, the concept of installation-related instructions from published package operation is less frequent, and they are usually used as the additional operation on top of the source code installation alternative.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Post-installation Instruction", "text": "After project installation, different components are usually covered within README files. In total, 248 of 1,168 data points are related to post-installation instruction updates. We synthesised six concepts based on their tasks and discuss them as follows:\nProject Running Instruction (185). The most important aspect after project installation is to execute the software to accomplish specific tasks, and we observed that the vast majority of modifications in this concept fall into the running instruction changes.\nOSS projects often come with different execution options that accept different parameters as input for different use cases. In these scenarios, adding different combinations of parameters with varying but similar functionalities could lead to bloated documents, but we did notice a few instances in practice. Meanwhile, we observe that newly added commands often contain the default setting or offer a template with placeholders for parameters. For example, commit Example 14 added a template execution command with two brief examples. Moreover, it included a \"get help\" command, allowing documentation users to access detailed running options.\nIn addition, OSS projects sometimes contain multiple runnable modules, each serving a specific aspect of the project, such as server/worker modules in distributed system projects and training/inference modules in machine learning projects. Properly documenting each component's execution instruction is essential for users to make use of the software product. Within our analysed data, we identified in Example 15 that additional execution commands were added for other blocks of functions. This could happen to remedy incomplete documentation issues [5] or to reflect newly added features in the system.\nInstruction updates for software execution are also common in our analysed data. Changes are found to be frequently appearing in changing file names or file path of the executable, changing default parameter settings for the instruction. These changes are highly intertwined with code base changes, giving rise to motivation of automated documentation tools to perform updates.\nInstallation Check (13). After a complicated software installation process, the installation check commands allow users to verify that the software has been installed and configured successfully. In our analysed data, only a few repositories incorporated the installation check process into their documentation. Represented by commit Example 16, the added installation verification process normally contains the execution of a simple predefined code snippet.\nRunning Tests (43). Tests may not be required from the user's perspective, but become crucial in the context of installation in development mode. Although Deployment Instruction (9), Upgrade Instruction (6), Uninstall Instruction (3) also occurred in our analysed data, their occurrence is relatively infrequent.", "publication_ref": ["b4"], "figure_ref": [], "table_ref": []}, {"heading": "Summary of post-installation instruction results:", "text": "The most dominant concept in this category is project running instruction. Changes in this concept are found to be related to updating parameter options and file paths to the executables. Other concepts are less frequently encountered but they all constitue the installation-related software development tasks.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Help Information", "text": "Previous sections discuss updates of instructional commands, which focus on providing commands for the reader of the documentation to follow. In contrast, the help information serves as a resource for documentation readers to get clarification or examples to better understand the project and commands. In total, 265 out of 1,168 data points are related to the Help Information category. In this category, we synthesised three concepts, which are discussed as follows:\nTutorial Updates (70). Limited in space and purpose, README files typically do not offer comprehensive usage instructions, such as API documentation. We observed that most updates within this concept involve providing code demos for basic usage of a project. Most documentation changes are trivial, merely made to align with the source code modifications. In Example 17, updates are made within the code demos, altering all naming paradigms for the methods of using the model.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Explanation Information Updates (125).", "text": "Instructional commands require users to follow step-by-step commands to complete tasks. In cases where users lack related background knowledge, they may need to blindly follow instructions. In our analysed data, we observed examples where efforts were made to enhance the accessibility of README file instructions by updating explanations.\nExplanations can be added as complementary materials to different types of instruction. For example, a new dependency scikit-learn was added in commit Example 18. However, instead of providing a simple manifest of dependencies, it includes explanations of when and why this dependency is required: If there is no interest in this level of optimisation/benchmarking, then the code base is not needed. This type of information empowers documentation users to make informed decisions about whether to include a particular package when installing the project.\nExplanation is not only added where the instructions are optional, when the instructions are not common enough or potentially have side effects, additional explanation is also needed, such as the case in Example 19. In this example, an explanation is added for the parameter option \"no-deps\", detailing its intended outcome, along with caveats specifying when manual installation of dependencies for other modules may be necessary.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Notes and Troubleshooting (70).", "text": "In our analysed data, we identified documentation efforts in updating notes and troubleshooting content. A brief definition of \"notes\" is additional information or important considerations that must be taken into account when following the instruction. Meanwhile, troubleshooting is dedicated to providing guidance towards common errors that people may encounter.\nFor example, the commit Example 20 added a note, specifying additional steps that need to be done for linux-armv6 and linux-armv7 systems. On the other hand, in commit Example 21, troubleshooting information was added, including a description of the problem related to an outdated dockercompose version and the solution provided to address this issue. These instructions are crucial for specific user groups, and the inclusion of common notes and troubleshooting information can enhance users' experiences by reducing the time spent searching for solutions.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Summary of help information results:", "text": "Tutorials cover basic project usage with code demos. Explanation information serves as complementary materials to instructions, providing guides when instructions are optional or not common. Notes and troubleshooting provides additional information, and are dedicated to providing guidance towards common errors for the software project.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Document Presentation", "text": "Different from the previous sections, document presentation updates involve less content modification. Instead, the emphasis is on organising the documentation to enhance visual presentation and reading comprehension. In total, 477 of 1,168 data points are associated with this category, indicating a relatively heavy documentation effort. In this category, we synthesised five concepts, which are discussed as follows:\nDocumentation Structural Modification (197). The structure of the documentation contains essential information for the reader to distinguish its source, topic, and other characteristics [47]. In our analysed data, we identified a large amount of effort in document structure updates, reaching around 16% of all data.\nSection headers are indicators of the content within the sections. Figure 9 shows examples for updating the section names to more accurately reflect the content under the section. Figure 9a updates the header name as a result of the inclusion of new distinct contents in the section, while Figure 9b undergoes an update with the aim of improving the clarity of the header of the section.\nIn addition, when a section is cluttered with excessive contents, it becomes necessary to re-organise the materials in a more logical manner by relocating them into other sections. In commit Example 22, the instructions in the previous README file are largely gathered in a single section. The updates, as indicated in the commit, distribute the corresponding parts among different subsections, enhancing the organisation of the documentation for better comprehension. This also happens when instructions are introduced with the same purpose but with different technologies. For example, in commit Example 23, the Docker installation instruction is moved under \"Installation with Docker\" after adding the Pip install instruction.\nOther modification operations including adjusting the section header size, section hierarchical changes which organise multiple sections under a single common section, and section order updates are less commonly found in practice, but all contribute to the organisation of information in README files.   All of these formatting operations contribute to enhance the presentation of the documentation, making the README files easier to follow. Specifically, the formatting on code blocks enables better highlighting on code components, while the formatting on URL facilitates enhanced accessibility and clearer content display. Plain text is also formatted to highlight important information, as indicated in Example 27, with bold and italic texts.\nOther formatting includes adding empty lines to separate logically different paragraphs, using bullet points, or an ordered list to organise the instructions within the documentation. These formatting operations organise the content within a section in a more logical manner to improve the reading experience.\nPresentation Fixing (61). Presentation fixing in the domain of README documentation presentation involves addressing two perspectives: grammar and typo fixing, as well as Markdown syntax fixing. Documentation writers might inadvertently make errors when composing README documents, leading to additional time needed for meticulous checking.\nErrors in grammar and typography can influence the reading experience, but may not severely impact the documentation's usability. In commit Example 28, the whole commit is dedicated to fixing typos to improve readability. For example, the word Pyhton is corrected to Python. On the other hand, Markdown syntax errors sometimes prevent the content from correctly rendering, making the documentation difficult to read. For example, in commit Example 29, an extra space is inserted between the hash symbol and section header, ensuring the correct display of the header.", "publication_ref": ["b46"], "figure_ref": [], "table_ref": []}, {"heading": "Text Rephrasing and Editing (70).", "text": "Text rephrasing and editing is different from updates in instructions or help information, as the latter two entail different or additional information in the actual guidance, procedures, or technical details, while the first one focuses on modification of the wordings and sentence structures.\nRegarding the style of text rephrase and editing, we observed instances where efforts were made to simplify the sentences or render them more succinct. In commit Example 30, the phrase instead of 'pip install .' was deleted. Since there already exists the correct code command, providing an incorrect command is unnecessary and could potentially lead to users' misuse. On the other hand, there are also light updates that perform less apparent modifications. For example, in commit Example 31, the phrase doesn't necessarily work is revised to might not work as expected. The modified text included the behaviour that code does not work, highlighting the potential limitations.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Self-admitted Documentation Debt Management (30).", "text": "Although uncommon, there are projects on which developers explicitly leave unfinished marks in certain sections. In commit Example 32, an installation section is added, with only a placeholder \"coming soon\". Although in most scenarios, these self-admitted documentation debts are removed once the contents are added, we identified cases in which the documentation debt is only commented out using Markdown syntax. In this case, the reader can still access the complete information, while the documentation maintainers are aware of the outstanding documentation debt from README files.\nSummary of document presentation results: Documentation structural modification includes changes in section headers, and organising content underneath them. The concept of content formatting and cleaning involves using Markdown syntax to either highlight or organise the content. Error fixing includes both Markdown syntax fixing and grammar and typography fixing. In addition, the concept of text rephrasing and editing is primarily related to making text simpler and more succinct. Furthermore, we also identified a few cases where self-admitted documentation debt is managed within README files.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "External Resources Management", "text": "External Resources refer to other documentation and nondocumentation artefacts that are not embedded within the project's README files, but are accessible only via the provided URL links. In total, 366 of 1,168 data points are related to this category. In this category, we synthesised three concepts, which are discussed as follows:\nProject External Documentation Management (120). README files serve as a starting point for an OSS project, which contains essential information for users to learn and start on a Github repository [15]. However, including all information within the README files would lead to information overload, hindering documentation users from quickly identifying their desired contents. In our analysed data, we discovered one common activity as managing the project's external documentation, taking up around 10% of the whole data instances.\nIn commit Example 33, the content regarding \"how-touse\" became overly lengthy and complicated. This commit reorganised the content into a Wiki document for this project, with a URL provided to easily navigate to this external documentation. Meanwhile, it also provided a URL redirect to another Markdown file with contribution information. Generally, we found that the newly introduced documentation has a wider range of formats, including Markdown files, HTML files, Wiki files, RST files, and so on. There are also update operations for the URL of external documents, which can be rooted to change of documentation location or new version reflection. In fact, we observed that the addition of external documentation resources is often accompanied with the deletion of instructional content within the README, which corresponds to documentation organisation efforts.\nProject Non-documentation Artefacts Management (136). Apart from external documents, other artefacts (e.g., source code, release package, data, and configuration file) are closely related to installation-related tasks. Typically facilitated by Git, the most frequent modification for nondocumentation artefact is on source code access. This access is a crucial step to enable the source code installation method. Release packages, such as the jar package for Java projects, are also actively maintained for users to get access to different versions of the release. Additionally, some projects organise other URLs, such as links to configuration files (e.g., Dockerfile), providing quick access to corresponding files, such as the update in commit Example 34. This practice provides quick access to editable files, which helps with local development.\nThird-Party External Resources Management (110). Although third-party requirements are important for OSS projects, it is not the responsibility of the README file to provide detailed information for them; doing so may lead to issues of tangled information [11]. Therefore, we identified that the majority of data instances in this concept involve adding or updating URLs for third-party dependencies or other requirements of this project, such as the update in commit Example 35. These changes often accompany related instructional changes, and the URLs typically lead to their official websites or documentation sources.", "publication_ref": ["b14", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "Summary of external resources management results:", "text": "Project external documentation management is related to providing links for other detailed project document, which helps avoid lengthy README files. Project nondocumentation artefacts refers to URLs for project artefacts including source code, executable and other configuration files. Furthermore, the concept of third-party external resources management corresponds to updates for URLs for external requirements of the software project.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Cross-Cutting Concerns", "text": "There are several perspectives that we identified during the analysis that are scattered across different categories and important to the README file update operations. Therefore, we dedicate a subsection to discuss them.\n(1) Version Management. As described in previous sections, version management is a notable area where substantial efforts are invested when updating README files. With the development of the project, new versions are released to incorporate additional features, which leads to the active update for version information. In summary, we identified that version management primarily focuses on project version, dependency version, and operating system version.\nIn terms of project version, information is provided for the latest stable version and the developing version. This version information is usually updated within installationrelated instruction, project running instructions, URLs for accessing project artefacts, and plain text manifest. Additionally, previous versions are sometimes provided, and outdated versions are included as help information. Regarding dependency version updates, the programming language version will be updated when a newer version is incorporated into the software project, e.g., migrating from Python 2 to Python 3 or adding support for the latest version of JVM. As for other dependencies, although version information is not always displayed in the README file for every repository, their versions are also updated accordingly in the case that they are displayed, to reflect the changes within each project. As indicated in the previous example, operating system version updates reflect project changes that introduce a newer compatible version. In addition, when a new compatible operating system is added to the project, it might be necessary to document specific instructions on different software development tasks.\n(2) Development related Instruction Updates. Development-related instructions require different settings from normal usage mode, and are documented in README files to facilitate better contribution guidelines.\nStarting from pre-installation setup, the development mode requires slightly different or additional dependencies compared to the normal usage mode. For example, pytest is only useful for testing and is not required for normal use cases. In terms of installation-related processes, separate instructions are usually added for development mode, with an additional flag in the command parameter to handle extra procedures that are needed. Moreover, some projects also provide a snapshot version of the project that is under development for users to experience. Regarding postinstallation instructions, development-specific activities are included to complete the development guidelines, which includes testing and processes to contribute to the project.\n(3) Error Fixing. Errors are in various forms, as summarised above. The impact on documentation users varies depending on the nature of these errors. Document presentation errors are among the least severe, mainly affecting the readability of README files. In addition, presentation errors are relatively easier to solve by applying additional grammar and Markdown syntax checking tools.\nHowever, we also observed efforts to address instructional errors. Instructional errors are scattered across preinstallation, installation-related, and post-installation sections, and their presence can lead to failure of command execution, thus hindering the usability of README files. Errors also exist in URLs that serve as links to external resources. These types of errors are less apparent and more severe, requiring detailed examination or even execution to identify and a higher level of expertise to rectify.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "README Update Behaviours", "text": "Last, we summarise the overall update behaviours based on the derived codes. The most frequently updated category is \"Pre-installation instruction,\" with dependency setup being the most modified concept. Documentation presentation is the second most focused category, where maintainers primarily work on modifying the documentation structure and formatting the documents for better readability. Additionally, updates to instructional commands significantly outnumber updates to help information, with nearly five times as many. These observations indicate that OSS documentation maintainers invest more effort in updating dependencies and documentation structures. They also focus more on providing instructional information rather than help information such as troubleshooting in README files.\nAdditionally, we distinguish our base codes with the operations of \"Addition\", \"Modification\", and \"Removal\", with the statistics displayed in Table 2. Unlike the sectionlevel updates shown in Figure 4, we categorise them based on more detailed modification behaviours. Specifically, whether the modification introduces new information, updates existing information, or removes old information. Clearly seen from the table, apart from document presentation, the largest proportion of update behaviour involves \"addition\". This indicates that more information is being incorporated into README files as the software development process progresses, requiring documentation maintainers to spend time assembling new information to reflect system changes.", "publication_ref": [], "figure_ref": ["fig_2"], "table_ref": ["tab_3"]}, {"heading": "Project Template", "text": "This is a template encompassing installation-related sections for README.md. Adjust the template accordingly to incorporate contribution guidelines. In case of any uncommon commands, please make explanation.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Prerequisites", "text": "This project is built based on Programming Language. Make sure to use Programming Language with version before getting started. Make sure you have the following installed before proceeding:\n\u2022 Prerequisite 1 \u2022 Prerequisite 2", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Installation Steps", "text": "Choose one of the following options to install the project: ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Usage Basic Commands", "text": "Provide a list of basic commands or the most essential commands to run the project.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "# Insert command here", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Advanced Option", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "TODO", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "External Documents", "text": "Provide additional documents for users to explore the comprehensive documents, e.g., INSTALL.md, WIKI, CONTRIBUTE.md etc.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Version History", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Help and Support", "text": "Provide FAQs and commonly encountered errors here. Also make reference to channels where you want to have interact with users. ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "README TEMPLATE AND ITS VALIDATION", "text": "As we discovered that most categories contain more addition operations and that significant efforts are spent on documentation presentation adjustments by practitioners, we created a README template based on the derived taxonomy. This template encompasses all essential installation-related contents, aiming to provide a comprehensive checklist and reduce practitioners' maintenance efforts for README files. In this section, we describe our proposed template and validate it through a survey conducted on Prolific.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "README Template Content", "text": "Figure 10 presented the suggested template. It covers basic instructions including prerequisites, installation steps, usage, external documents, version history, and help and support sections. These sections are linked to the taxonomy derived from our RQ1, and we have explicitly labelled them in the figure. In prerequisites section, we incorporate programming language version and dependencies for the project. URLs for the official websites of the dependencies are also provided. The installation steps include both source code level installation and published package level installation. Usage section covers basic commands for running the project, as well as some advanced option to display the capability of the software. External documents provides links to external comprehensive documents. Version history section provides the version information of this project, while help and support section provides most common FAQs and channels for users to interact with. In cases where specific functionalities are yet to be implemented, these placeholders can be seen as a form of self-admitted document debt, serving as reminders for document maintainers to complete the necessary information.", "publication_ref": [], "figure_ref": ["fig_10"], "table_ref": []}, {"heading": "Template Validation Process", "text": "To further verify whether our proposed template is perceived as useful by the documentation users, we conducted a survey on Prolific. We applied our proposed template to the original README documents by performing rewrites. To avoid subjectivity in the rewriting process, we instructed ChatGPT to handle this task. Specifically, we provided the original README file and the template, along with two additional instructions: (1) do not omit any details from the original document, and (2) do not add any information not present in the original document. We used ChatGPT 4o throughout this procedure. Only one entry of instruction is provided to ChatGPT to collect the generation, without further tuning or additional feedback.\nFor the evaluated samples, we first randomly selected 20 repositories. From each repository, we randomly chose one commit to ensure each document was selected only once per repository. We then instructed ChatGPT to apply our proposed template to these documents. We refer to the original documents as \"original\" documents and the generated documents as \"augmented\" documents. In total, we obtained 20 \"original\" to \"augmented\" document pairs for evaluation.\nWe conducted a Prolific survey by dividing the 20 document pairs into 10 different surveys, with each survey taken by three different participants. We performed a sequential survey release as in [33] to prevent same individual from participating multiple times. Meanwhile, we followed a study design similar to Nadi and Treude [48] by inserting a \"quality gate\" in the survey. After reading the documents, we asked the participants to answer a simple question, e.g., \"Is Gradle used in the above-mentioned project?\". We filtered out participants who did not answer the question correctly.\nTo evaluate how users perceive the documents, we adopted an evaluation framework proposed by Treude et al. [12], which provides a ten-dimensional framework for assessing software documentation quality. Table 3 displays these dimensions as well as questions in this paper. Participants were requested to read through the original and augmented documents and provide scores on these ten dimensions. To prevent biased judgements, the documents were anonymised regarding their status as original or augmented. Likert scale is used to mark each of the aspects, with a score of 1 for strongly disagreeing and a score of 5 for strongly agreeing. Additionally, we revealed the template at the end of the survey and with an open-ended question aiming to gather participants opinions about it. We added a sample as well as all README file pairs in our replication package. ", "publication_ref": ["b32", "b47", "b11"], "figure_ref": [], "table_ref": ["tab_7"]}, {"heading": "Augmented", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Demographics of Annotators", "text": "We first applied predefined filters on Prolific, requiring participants to be in the Information Technology (IT) employment sector and be proficient in English. We asked the same question about their employment again at the beginning of our survey and filtered out 18 participants who did not answer this question consistently with their Prolific registration. Our \"quality gate\" question further filtered out four participants.\nIn the survey, we asked participants about their job roles and how many years they have worked in the IT field. For the 30 participants who passed all filters and submitted their response, they have on average 6.9 years of experience working in IT, with a maximum of twenty years and a minimum of one year. Among the 30 participants, there are eleven developers (36.7%), four data analyst (13.3%), four security specialist (13.3%), three IT support staff (10.0%), three project manager (10.0%), one UI designer (3.3%), one business analyst (3.3%), and one infrastructure engineer (3.3%).", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Template Validation Result", "text": "Seen from Figure 11, the average scores for the \"augmented\" document are consistently higher than those of the \"original\" documents. The figure is sorted based on the difference between the average scores of these two types of documents. The most improved dimensions are structure, understandability and conciseness, with a gain of 0.80, 0.53, and 0.53 of Likert average score, respectively. Meanwhile, the increase clarity and consistency are less noticeable.\nWe also performed Wilcoxon signed rank tests [49] on all dimensions to determine whether the differences are statistically significant. As indicated in the figure, eight out of ten dimensions are with a p-value below 0.05, indicating statistically significant differences. We further computed the Cohen's d effect size [50] for the ten evaluation dimensions. The results indicate that the adoption of our proposed template significantly enhances the perceived structure with large effect, while significantly enhances understandability, conciseness, readability, quality, cohesion, appeal, and effectiveness with medium effect. The improvement in clarity and consistency are small. Therefore, based on the quantitative results of our survey, we find that applying our proposed template increases the quality of the generated documents, particularly in terms of structure, understandability, and conciseness, without compromising clarity and consistency, as perceived by document readers.", "publication_ref": ["b48", "b49"], "figure_ref": ["fig_5"], "table_ref": []}, {"heading": "IMPLICATIONS AND DISCUSSION", "text": "The ultimate goal of our study is to understand the practices of updating README files in the parts related to the installation, enabling better documentation activities to improve the quality of software documentation and its process. In this section, we discuss the findings of this study and their implications for different stakeholders, including researchers and practitioners.\nCompleteness considerations. The importance of documentation content completeness issue has been identified in previous work [5], and efforts have been made to use recommendation systems to recommend newly added code elements to be documented [51]. However, more factors constitute the completeness factor in the context of README files. We provide a more detailed discussion of completeness considerations in the context of GitHub README files.\nFor documentation maintainers, instruction completeness is important. The categories that emerged from our qualitative analysis of pre-installation instructions, installation-related instructions, and post-installation instructions collectively account for a complete process, enabling self-contained documentation for users to follow. In our synthesised codes, the introduction of a new instruction without a pre-existing alternative implies a deficiency in the previous documentation. For example, we found that the programming language and operating system to be frequently newly added to the document. This type of update addresses previously absent details. On the other hand, practitioners should also take into account the completeness of help information. Well-managed help information can improve the comprehension of the documentation and reduce the search time for users in case of errors [52]. Based on our analysed data, it is evident that the frequency of help information is notably lower compared to the combined occurrence of instructions within the three major categories. This observation implies a tendency among practitioners to overlook the inclusion of comprehensive help information. Therefore, practitioners could closely monitor the issues and pull requests to incorporate frequently-asked or confusion questions into the README documents. For documentation updates, they could use our proposed template as a checklist before performing the updates.\nFor researchers, we suggest several directions for investigation to improve the completeness of README files. First, this work primarily focuses on the update operation without looking at the state of README file before and after modification. Therefore, identifying whether the updates are complete in reflecting the system change and fixing the previous document's lack of information would help better characterise a \"good\" or \"bad\" update. Second, an investigation of the temporal aspect of the absence of various types of instructions within the README file could better quantify the severity of this issue. Furthermore, researchers can also assist in providing essential help information. Automatically supplying help information is a difficult task. However, this can be done by algorithms to detect insufficient information for each instruction. Moreover, previous efforts [31] augmented API documentation with information from Stack Overflow. Similar ideas could be adopted by automatically extracting the most requested help information from various online channels based on certain project characteristics. Lastly, the development of tools to detect completeness issues could help document maintainers identify and address these concerns quickly.\nGitHub could also help mitigating this issue by providing the template proposed in this study for installationrelated instructions when users create or update the README files. According to the result discussed in the previous section, by simply applying the template to the original document, documentation readers could experience increased documentation quality. In fact, the survey participants left comments to our proposed template: \"Good to see that you provide Frequently Asked Questions (FAQ)\", \"Covers all the important elements\". Therefore, this template could serve as a good starting point for reminding practitioners of the essential aspects to cover for their README files before performing updates.\nCorrectness and up-to-dateness considerations. Issues related to correctness and up-to-dateness have been ex-plored in prior studies [11], [13]. Tan et al. [53] introduced a method to identify outdated code elements in README files. In our discussion, we offer a more in-depth exploration, encompassing considerations of correctness within the context of README information and providing a more comprehensive list of up-to-dateness considerations other than code elements.\nAs indicated in the previous section, errors occur across different categories. Less severe errors encompass grammar issues, typographical errors within the text, and Markdown syntax errors. More severe errors are related to instructions, which require certain level of expertise to identify. Although not explicitly coded, we identified a few updates fixing errors within their instructions. In combination, these two types of errors constitute a noticeable percentage of update behaviours. This type of documentation effort can be avoided by checking the content more carefully.\nConcerning considerations of up-to-dateness, delays in updating the README file can result in a temporary misalignment and potentially introduce correctness issues in the document. Codes related to updating various instructions reflect the changes in the software system. As also discovered in [53], code elements are indeed updated frequently in our analysed data. Specifically, the frequent pattern found for code update code demo for using this project corresponds to modifying code elements to reflect naming paradigm shifts within the source code. Additionally, change factors regarding meta data (project names, file path names, and technology used) of the project, modification of dependencies for the project, instructions with specific operating systems, all influence the up-to-dateness of the README file and require close monitor by document maintainers.\nFor researchers, an investigation of the events that trigger instructional changes in the README files could shed light on the severity of the up-to-dateness issue and reveal the relationship between coding activities and documentation activities. Second, the combination of instructional update results and trigger events can provide valuable insights for the development of automatic document tools to perform updates to mitigate up-to-dateness concerns.\nInformation presentation considerations. Previous studies investigated how information is presented within the software documentation [5]. Considering the role of README files, which serve as the introductory point for users to participate in OSS projects, we discuss their distinctive characteristics and implications.\nAs indicated in Table 2, document presentation undergoes frequent updates, ranking as the second most frequently updated category in our analysis. This observation underscores the considerable effort practitioners invest in updating this particular aspect of the documentation. However, most of the updates are repetitive and could be avoided by adopting better documentation schemes. Within this category, the code change section header name has the highest frequency of 88 occurrences, followed by codes that adjust the hierarchies of the sections and move the contents from one section to another. Therefore, practitioners can adopt more standardised section headers and examine whether there are mismatches between contents and headers before committing the change. For researchers, natural language processing techniques can be applied to exam-ine content-header similarity or summarising the section contents with more appropriate headers [54]. In addition, techniques can be applied to examine and adjust the hierarchical structure for the README sections. Furthermore, this observation also motivates us to propose the README installation-related templates in Figure 10 to mitigate practitioners' efforts in document structure modifications.\nText rephrasing is also frequently observed within README updates. Two codes dedicated to adjusting the wording within the text or making sentences succinct account for 53 occurrences in total. For document maintainers, we suggest that they consider the audience of README files before writing the document. Specifically, as README files target newcomers and serve as an introductory document, overly complicated sentences and terminologies should be avoided. For researchers, previous research [33], [55] attempted to identify documentation smells or simplify complicated sentences within the documentation. With the advent of ChatGPT [56], text rephrasing becomes easier and attention is drawn to how different groups of users perceive useful information.\nREADME files serve as an introductory resource for navigating the OSS projects and should not be regarded as exhaustive documentation. In our analysed data, we observed instances where the concept of project running instructions involved presenting a comprehensive list of all running options with varying parameter combinations. This approach could lead to information overload, making it challenging for documentation users to locate their desired content. In addition, we also identified a pattern of content removal in combination with external document addition, when content within the README files becomes excessively long. For example, there are a few cases where instructions are removed, and a link to INSTALL.md or CONTRIBUTE.md is supplied in the README files.\nFor practitioners, the above-mentioned external content organisation approach can be adopted to avoid information overload. Furthermore, we identified in code add code instruction for running this project that add a comprehensive list of project running instructions, making it difficult for users to identify the desired content. In this scenario, these instructions can be documented in a RUNNING.md with README providing a reference to it, or covered by command line interface with parameter --help.\nFor researchers, detecting information overload helps determine when a documentation refactor of moving content outside the README file is needed. A survey to documentation users on the appropriate amount of information can help better understand the users' needs, while automated tools can also be developed for overload detection.\nAdditionally, the results in the template validation section indicate that structure, understandability, conciseness, and readability perspectives are perceived the top four increased dimensions after applying our template to the original README documents. In short, the application of this template directly mitigate the above-mentioned issues related to documentation structure, targeted audience, and information overload. In particular, one participant commented on the templates \"I like the order of chapters and it is easy to find everything. Just enough information to get started with technology.\". Therefore, to enhance the down-stream users' experience, documentation maintainers could manually adopt our template, or use an automatic approach of delegating this task to LLMs. The automatic approach could further alleviate the massive efforts from practitioners for adjusting documentation presentation. For researchers, our approach did not extensively adopt prompt engineering or make adjustment to the generated document. Refinements in these aspects might further improve the quality of README documents. The usability of the augmented documents could be verified through live installation sessions with documentation users.", "publication_ref": ["b4", "b50", "b51", "b30", "b10", "b12", "b52", "b52", "b4", "b53", "b32", "b54", "b55"], "figure_ref": ["fig_10"], "table_ref": ["tab_3"]}, {"heading": "THREATS TO VALIDITY", "text": "We consider threats to the validity of our study.\nFirst, we only collect repositories that use Python or Java as their primary programming language, which could affect the generalisability of our findings to other software projects. However, we did not observe any significant differences in the taxonomy between Python and Java projects in our analyzed data. The taxonomy derived in this study includes modifications in the installation process, help information, documentation presentation, and resource management. These factors can serve as a starting point for researchers and practitioners when addressing projects with different programming languages.\nSecond, as indicated earlier, our semi-automatic labelling heuristic is not completely accurate in distinguishing \"relevant\" and \"irrelevant\" commits. In the sampled dataset, we discarded the ones that are misclassified during our manual analysis, and fill each sample bucket with additional randomly sampled commits to ensure the same amount of data is analysed.\nThird, the 400 analysed repositories may not be representative to the overall population, potentially introducing sample bias. To address this threat, we ensured that sampled dataset size exceed 95% confidence rate of the overall dataset. Furthermore, our qualitative analysis may inherently carry subjectivity. To mitigate this concern, a rigorous process was implemented, involving all authors in reviewing the codes. Weekly meetings were held to facilitate discussions and address any discrepancies for codes, concepts and categories.\nFourth, this study is conducted on the GitHub platform, and its generalisability is expected to extend to other opensource software (OSS) projects that follow similar processes. However, considering the different procedures and use cases for proprietary and private software projects, it is important to note that we do not assert generalisability beyond the domain of open source.\nFifth, our analysis is limited in README update contents, without examining external referenced links. The results may also only apply to GitHub and are not easily generalisable to beyond GitHub projects to other platforms and closed-source projects.\nLastly, our template validation was conducted on 20 README documents with 30 participants, which might not represent the entire range of README documentation genres or the broader participant population. To mitigate this limitation, we randomly sampled the evaluated documents and recruited participants who work in IT with additional \"quality gate\". However, the participants were not actual README users; they were only required to evaluate the perceived documentation quality without installing the software according to the guidelines provided in the documents. Therefore, we only claim an improvement in the documentation reading experience rather than in documentation accuracy. Future work can further investigate this perspective by involving actual README users with live installation sessions.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "CONCLUSION", "text": "README files serve a critical role of introductory overviews for software projects, among which the installation-related sections are included. Considering various issues these documents may encounter, as well as the benefits of investing efforts to maintain high-quality documentation, knowledge of the practices of the README file efforts becomes essential. To achieve this, we conducted a large-scale qualitative analysis on GitHub README file commit updates specifically related to installation sections, aiming to gain a comprehensive insight into documentation activities.\nIn this paper, we collected GitHub repositories with several stringent filters to obtain a dataset consisting of 12,908 repositories. From this dataset, we randomly sampled 400 repositories, resulting in 25,209 commits that modified a README file. We applied semi-automatic labelling heuristics and eventually obtained 8,673 commits that modified sections related to installation topics. Among these, 1,168 instances were cluster sampled for qualitative analysis, resulting in a comprehensive taxonomy of 189 update behaviours.\nOur research reveals six categories of updates, namely pre-installation instructions, installation instructions, postinstallation instructions, help information updates, document presentation, and external resource management. We further provide detailed insights into modification behaviours and offer examples of these updates.\nBased on our findings, we proposed a README template for documentation maintainers when updating documents. The template validation process finds that the augmented documents based on our template are perceived of better quality by documentation readers. This step serves as an initial step towards automated documentation updates to facilitate better documentation activities. Furthermore, we provided suggestions for practitioners and potential directions for researchers from perspectives of completeness, correctness and up-to-dateness, and information presentation considerations. To sum up in an abstract way, documentation maintainers should take care of completeness and correctness for instructions in a succinct manner, while incorporating help information and external resources to make README files more accessible and easier to comprehend. Document presentation is also a critical aspect to consider. Meanwhile, future research directions include identifying triggers for README updates, understanding user information needs in documentation, and developing automated documentation tools. Knowledge in triggering events could reveal the relationship between document and code activities, user information needs help understand the appropriate instructions to include, while all these direc-tions contribute to the eventual automated documentation tools.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "REPLICATION PACKAGE", "text": "The replication package is available at https://github.com/ Haoyu-Gao/README Empirical Study.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Categorizing the content of github readme files", "journal": "Empirical Software Engineering", "year": "2019", "authors": "G A A Prana; C Treude; F Thung; T Atapattu; D Lo"}, {"ref_id": "b1", "title": "Open source software recommendations using github", "journal": "Springer", "year": "2018", "authors": "M Koskela; I Simola; K Stefanidis"}, {"ref_id": "b2", "title": "Preliminary empirical identification of barriers faced by newcomers to open source software projects", "journal": "IEEE", "year": "2014", "authors": "I Steinmacher; A P Chaves; T U Conte; M A Gerosa"}, {"ref_id": "b3", "title": "Docable: Evaluating the executability of software tutorials", "journal": "", "year": "2020", "authors": "S Mirhosseini; C Parnin"}, {"ref_id": "b4", "title": "Software documentation issues unveiled", "journal": "IEEE", "year": "2019", "authors": "E Aghajani; C Nagy; O L Vega-M\u00e1rquez; M Linares-V\u00e1squez; L Moreno; G Bavota; M Lanza"}, {"ref_id": "b5", "title": "Software documentation: the practitioners' perspective", "journal": "", "year": "2020", "authors": "E Aghajani; C Nagy; M Linares-V\u00e1squez; L Moreno; G Bavota; M Lanza; D C Shepherd"}, {"ref_id": "b6", "title": "Selecting the most appropriate web ide for learning programming using ahp", "journal": "IEEE", "year": "2016", "authors": "I \u0160kori\u0107; B Pein; T Orehova\u010dki"}, {"ref_id": "b7", "title": "Co-evolution of project documentation and popularity within github", "journal": "", "year": "2014", "authors": "K Aggarwal; A Hindle; E Stroulia"}, {"ref_id": "b8", "title": "A survey of documentation practice within corrective maintenance", "journal": "Empirical Software Engineering", "year": "2005", "authors": "M Kajko-Mattsson"}, {"ref_id": "b9", "title": "Usage and usefulness of technical software documentation: An industrial case study", "journal": "Information and software technology", "year": "2015", "authors": "G Garousi; V Garousi-Yusifo Glu; G Ruhe; J Zhi; M Moussavi; B Smith"}, {"ref_id": "b10", "title": "How api documentation fails", "journal": "Ieee software", "year": "2015", "authors": "G Uddin; M P Robillard"}, {"ref_id": "b11", "title": "Beyond accuracy: Assessing software documentation quality", "journal": "", "year": "2020", "authors": "C Treude; J Middleton; T Atapattu"}, {"ref_id": "b12", "title": "A large-scale empirical study on code-comment inconsistencies", "journal": "IEEE", "year": "2019", "authors": "F Wen; C Nagy; G Bavota; M Lanza"}, {"ref_id": "b13", "title": "How readme files are structured in open source java projects", "journal": "Information and Software Technology", "year": "2022", "authors": "Y Liu; E Noei; K Lyons"}, {"ref_id": "b14", "title": "Study the correlation between the readme file of github projects and their popularity", "journal": "Journal of Systems and Software", "year": "2023", "authors": "T Wang; S Wang; T.-H P Chen"}, {"ref_id": "b15", "title": "Autofolding for source code summarization", "journal": "IEEE Transactions on Software Engineering", "year": "2017", "authors": "J Fowkes; P Chanthirasegaran; R Ranca; M Allamanis; M Lapata; C Sutton"}, {"ref_id": "b16", "title": "Deep code comment generation", "journal": "", "year": "2018", "authors": "X Hu; G Li; X Xia; D Lo; Z Jin"}, {"ref_id": "b17", "title": "Deep code comment generation with hybrid lexical and syntactical information", "journal": "Empirical Software Engineering", "year": "2020", "authors": ""}, {"ref_id": "b18", "title": "Reinforcement-learning-guided source code summarization using hierarchical attention", "journal": "IEEE Transactions on software Engineering", "year": "2020", "authors": "W Wang; Y Zhang; Y Sui; Y Wan; Z Zhao; J Wu; S Y Philip; G Xu"}, {"ref_id": "b19", "title": "Commit message generation for source code changes", "journal": "", "year": "2019", "authors": "S Xu; Y Yao; F Xu; T Gu; H Tong; J Lu"}, {"ref_id": "b20", "title": "Atom: Commit message generation based on abstract syntax tree and hybrid ranking", "journal": "IEEE Transactions on Software Engineering", "year": "2020", "authors": "S Liu; C Gao; S Chen; L Y Nie; Y Liu"}, {"ref_id": "b21", "title": "Fira: fine-grained graph-based code change representation for automated commit message generation", "journal": "", "year": "2022", "authors": "J Dong; Y Lou; Q Zhu; Z Sun; Z Li; W Zhang; D Hao"}, {"ref_id": "b22", "title": "Automatic code review by learning the revision of source code", "journal": "", "year": "2019", "authors": "S.-T Shi; M Li; D Lo; F Thung; X Huo"}, {"ref_id": "b23", "title": "Improving automated code reviews: Learning from experience", "journal": "IEEE", "year": "2024", "authors": "H Y Lin; P Thongtanunam; C Treude; W Charoenwet"}, {"ref_id": "b24", "title": "Automatic generation of release notes", "journal": "", "year": "2014", "authors": "L Moreno; G Bavota; M Di Penta; R Oliveto; A Marcus; G Canfora"}, {"ref_id": "b25", "title": "Arena: an approach for the automated generation of release notes", "journal": "IEEE Transactions on Software Engineering", "year": "2016", "authors": ""}, {"ref_id": "b26", "title": "Deep justin-time inconsistency detection between comments and source code", "journal": "", "year": "2021", "authors": "S Panthaplackel; J J Li; M Gligoric; R J Mooney"}, {"ref_id": "b27", "title": "Just-in-time obsolete comment detection and update", "journal": "IEEE Transactions on Software Engineering", "year": "2021", "authors": "Z Liu; X Xia; D Lo; M Yan; S Li"}, {"ref_id": "b28", "title": "Automatic classifying self-admitted technical debt using n-gram idf", "journal": "IEEE", "year": "2019", "authors": "S Wattanakriengkrai; N Srisermphoak; S Sintoplertchaikul; M Choetkiertikul; C Ragkhitwetsagul; T Sunetnanta; H Hata; K Matsumoto"}, {"ref_id": "b29", "title": "Self-admitted technical debt in the embedded systems industry: An exploratory case study", "journal": "IEEE Transactions on Software Engineering", "year": "2022", "authors": "Y Li; M Soliman; P Avgeriou; L Somers"}, {"ref_id": "b30", "title": "Augmenting api documentation with insights from stack overflow", "journal": "", "year": "2016", "authors": "C Treude; M P Robillard"}, {"ref_id": "b31", "title": "Extracting development tasks to navigate software documentation", "journal": "IEEE Transactions on Software Engineering", "year": "2014", "authors": "C Treude; M P Robillard; B Dagenais"}, {"ref_id": "b32", "title": "Evaluating transfer learning for simplifying github readmes", "journal": "", "year": "2023", "authors": "H Gao; C Treude; M Zahedi"}, {"ref_id": "b33", "title": "On-demand developer documentation", "journal": "IEEE", "year": "2017", "authors": "M P Robillard; A Marcus; C Treude; G Bavota; O Chaparro; N Ernst; M A Gerosa; M Godfrey; M Lanza; M Linares-V\u00e1squez"}, {"ref_id": "b34", "title": "Securing decentralized software installation and updates", "journal": "", "year": "2014", "authors": "D J Barrera"}, {"ref_id": "b35", "title": "A systematic literature review on the barriers faced by newcomers to open source software projects", "journal": "Information and Software Technology", "year": "2015", "authors": "I Steinmacher; M A G Silva; M A Gerosa; D F Redmiles"}, {"ref_id": "b36", "title": "Barriers and self-efficacy: A large-scale study on the impact of oss courses on student perceptions", "journal": "", "year": "2023", "authors": "L Salerno; S De Franc \u00b8a Tonh\u00e3o; I Steinmacher; C Treude"}, {"ref_id": "b37", "title": "Mining questions asked about continuous software engineering: A case study of stack overflow", "journal": "", "year": "2020", "authors": "M Zahedi; R N Rajapakse; M A Babar"}, {"ref_id": "b38", "title": "Wordnet: a lexical database for english", "journal": "Communications of the ACM", "year": "1995", "authors": "G A Miller"}, {"ref_id": "b39", "title": "Sampling projects in github for msr studies", "journal": "IEEE", "year": "2021", "authors": "O Dabic; E Aghajani; G Bavota"}, {"ref_id": "b40", "title": "Fasttext.zip: Compressing text classification models", "journal": "", "year": "2016", "authors": "A Joulin; E Grave; P Bojanowski; M Douze; H J\u00e9gou; T Mikolov"}, {"ref_id": "b41", "title": "When large language models confront repository-level automatic program repair: How well they done?", "journal": "", "year": "2024", "authors": "Y Chen; J Wu; X Ling; C Li; Z Rui; T Luo; Y Wu"}, {"ref_id": "b42", "title": "Sampling in software engineering research: A critical review and guidelines", "journal": "Empirical Software Engineering", "year": "2022", "authors": "S Baltes; P Ralph"}, {"ref_id": "b43", "title": "Discovery of grounded theory: Strategies for qualitative research", "journal": "Routledge", "year": "2017", "authors": "B Glaser; A Strauss"}, {"ref_id": "b44", "title": "basics of qualitative research: Techniques and procedures for developing grounded theory . thousand oaks, ca: Sage", "journal": "Organizational Research Methods", "year": "2008", "authors": "R W Service"}, {"ref_id": "b45", "title": "When and how to make breaking changes: Policies and practices in 18 open source software ecosystems", "journal": "ACM Transactions on Software Engineering and Methodology (TOSEM)", "year": "2021", "authors": "C Bogart; C K\u00e4stner; J Herbsleb; F Thung"}, {"ref_id": "b46", "title": "Exploiting structural information for semi-structured document categorization", "journal": "Information Processing & Management", "year": "2006", "authors": "A Bratko; B Filipi\u010d"}, {"ref_id": "b47", "title": "Essential sentences for navigating stack overflow answers", "journal": "IEEE", "year": "2020", "authors": "S Nadi; C Treude"}, {"ref_id": "b48", "title": "Wilcoxon signed-rank test", "journal": "Encyclopedia of Biostatistics", "year": "2005", "authors": "R F Woolson"}, {"ref_id": "b49", "title": "Effect size (es)", "journal": "", "year": "2000", "authors": "L A Becker"}, {"ref_id": "b50", "title": "Using traceability links to recommend adaptive changes for documentation evolution", "journal": "IEEE Transactions on Software Engineering", "year": "2014", "authors": "B Dagenais; M P Robillard"}, {"ref_id": "b51", "title": "Who asked what: Integrating crowdsourced faqs into api documentation", "journal": "", "year": "2014", "authors": "C Chen; K Zhang"}, {"ref_id": "b52", "title": "Detecting outdated code element references in software repository documentation", "journal": "", "year": "2022", "authors": "W S Tan; M Wagner; C Treude"}, {"ref_id": "b53", "title": "Text summarization with pretrained encoders", "journal": "Association for Computational Linguistics", "year": "2019-11", "authors": "Y Liu; M Lapata"}, {"ref_id": "b54", "title": "Automatic detection of five api documentation smells: Practitioners' perspectives", "journal": "IEEE", "year": "2021", "authors": "J Y Khan; M T I Khondaker; G Uddin; A Iqbal"}, {"ref_id": "b55", "title": "Gpt-4 technical report", "journal": "", "year": "2023", "authors": " Openai"}], "figures": [{"figure_label": "3", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Fig. 3 :3Fig. 3: Comparison between repositories in our dataset and ones above 2,000 stars", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Fig. 4 :4Fig. 4: Average Updated Sections Per Commit", "figure_data": ""}, {"figure_label": "25", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "2 Fig. 5 :25Fig. 5: Update Keywords Heat-Map (A: Added, R: Removed, M: Modified)", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "plain text for dependency of this project Add installation code instructions for dependency of this project.", "figure_data": ""}, {"figure_label": "1", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "1 .1In the dependencies section, update python version from 2.7 to 3.6^ 2. Update the OS version that this project is tested on from 9, 10 to 10, Steps for Synthesising Categories from Raw Data", "figure_data": ""}, {"figure_label": "67", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Fig. 6 :Fig. 7 :67Fig. 6: Coding Process and Examples of Assigned Codes", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_7", "figure_caption": "Commit updated README master Mathieu Bernard committed on Nov 13, 2019 1 parent 2248d50 commit 1d85fcc manelkhentout / https-github.com-bootphon-abkhazia-tree-aesrc Code is no more compatible with python2, please use python3 instead. The -4 last version comaptible with python2 is -5 [abkhazia-0.3.1](https://github.com/bootphon/abkhazia/releases/tag/v0.3.1)** -6 -7 ### Online documentation can be found [here] (https://coml.lscp.ens.fr/docs/abkhazia)** -3 ### See Online documentation https://coml.lscp.ens.fr/docs/abkhazia + project makes it easy to obtain simple baselines for 10 6 supervised ASR (using [Kaldi](http://kaldi-asr.org)) and ABX tasks 11 7 (using [ABXpy](https://github.com/bootphon/ABXpy)) on the large corpora 12 8 of speech recordings typically used in speech engineering, linguistics 13 9 or cognitive science research. 14 10 11 **Abkhazia requires python>=3.6 instead. The last version comaptible with + 12 python2 is + 13 [abkhazia-0.3.1](https://github.com/bootphon/abkhazia/releases/tag/v0.3.12015-2019 by Mathieu Bernard, Thomas Schatz, Xuan-Nga Cao, Roland -19 Thiolli\u00e8re, Emmanuel Dupoux** -17 **Copyright 2015-2019 CoML team (Inria, ENS, CNRS, EHESS)*free software: you can redistribute it and/or modify 22 20 it under the terms of the GNU General Public License as published by Showing 1 changed file with 5 additions and 7 deletions. Split Unified (a)", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_8", "figure_caption": "CommitFixed some issues, renamed files and updated README main v0.4.0.0 v0.3.0.0 themarpe committed on Jun 4", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_9", "figure_caption": "successful installation, run the following comand:# Insert command here", "figure_data": ""}, {"figure_label": "10", "figure_type": "figure", "figure_id": "fig_10", "figure_caption": "Fig. 10 :10Fig. 10: Proposed README Template", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "Counts for Header Scales", "figure_data": "Header Scale \u27e8h1\u27e9 \u27e8h2\u27e9 \u27e8h3\u27e9 \u27e8h4\u27e9 \u27e8h5\u27e9 \u27e8h6\u27e9Count387382312167458"}, {"figure_label": "2", "figure_type": "table", "figure_id": "tab_3", "figure_caption": "Examples for Qualitative Analysis", "figure_data": "CategoryConcept# Codes Frequency Example IDAddition Modification RemovalDependency Setup23527 1, 2, 3, 447.8%34.8%17.4%Pre-installationPlatform Setup1182 5, 6, 754.5%18.2%27.3%instructionVirtual Machine and Hardware619 --66.7%16.7%16.7%Total4062852.5%27.5%20.0%Installation-related instructionSource code Published package23 14267 8, 9 162 10, 11, 12, 1343.4% 57.1%43.5% 28.6%13.0% 14.3%Total3742948.6%37.8%13.5%Project running instruction12185 14, 1537.5%50.0%12.5%Installation check313 1640.0%60.0%0.0%Post-installation instructionRunning Tests Deployment Instruction Upgrade Instruction6 3 432 --9 --6 --88.9% 75% 100.0%0.0% 0.0% 0.0%11.1% 25.0% 0.0%Uninstall Instruction23 --0.0%0.0%100.0%Total3024858.6%24.1%17.2%Tutorial updates670 1750.0%33.3%16.7%Help informationExplanation Notes and troubleshooting14 16125 18, 19 70 20, 2161.5% 68.8%38.5% 6.3%0.0% 25.0%Total3626562.9%22.9%14.3%Documentation structural modification7197 22, 230.0%100.0%0.0%Content formatting and cleaning10119 24, 25, 26, 270.0%100.0%0.0%DocumentPresentation fixing261 28, 290.0%100.0%0.0%PresentationText rephrasing and editing570 30, 310.0%100.0%0.0%Documentation debt430 3225.0%0.0%75.0%Total284773.6%85.7%10.7%Project external documentation3120 3325.0%50.0%25.0%External resourcesProject non-documentation artefact11136 3444.4%33.3%22.2%managementThird-party external resources4110 3560.0%20.0%20.0%Total1836644.4%33.3%22.2%"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_4", "figure_caption": "tion within the README files. Indeed, most updates in this aspect involve updating dependency information, as indicated in Example 1, and instructions on installation of dependencies as indicated in Example 2. We observed a common practice of manifesting dependencies by listing them (e.g., in forms of plain texts, bullet points, or tables), with addition, updates, and deletion to reflect the corresponding changes. Meanwhile, the patterns for providing the installation instruction of dependencies are quite diverse. Centralised commands (e.g., requirements.txt) or separate installation commands for each dependency are widely used. However, maintaining the separate command style requires more effort, as individual attention to each dependency is needed, making modifications potentially more time-consuming and the process more complicated.", "figure_data": "Codeeclipse-esmf / esmf-sdk Issues 60Pull requests 5ActionsProjectsWikiSecurityInsiBrowse files1 parent 8ffa613 commit 616fd7e3232## Requirements33333426-* Jargon depends on Java 1.7+ README.md34+* Jargon depends on Java 1.8+35 49 5049 35 50## Build and contribute5151+consortium37373838+## Libraries3939 53+Building the SDK requires a Java 17-compatible [GraalVM JDK](https://www.graalvm.org/) with the100 101100 101 54+'js' the For put/get to a directory, do a permission check and create any necessary component installed. If you with to build the bamm-cli (see below), you will also have to have55+subdirs as specified 'native-image' GraalVM component installed.102102 56+103 57+### SSL cert check bypass option #155 To build the SDK core components, run the following command: +104 58++ ```bash59+mvn -pl '!io.openmanufacturing:bamm-cli' clean install60``+61+62+To also build SDK core components and the CLI tool, run the above command, followed by:63+```bash64+cd tools/bamm-cli65+mvn -B clean verify66+mvn -B verify -Pnative67``+55685669We"}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_6", "figure_caption": "README content formatting involves using Markdown syntax to either highlight or organise the content. Various information is commonly formatted, including large code blocks in Example 24, inline code blocks in Example 25, and URLs in Example 26.", "figure_data": "Split Unified24README.md...@@ -1,24 +1,16 @@1-# DepthAI Python Module1+# DepthAI Demo Program223-This repo contains the pre-compiled3+This repo contains demo application,DepthAI Python module (compiled as anwhich can load different networks,architecture-specific `.so` file),create pipelines, record video, etc.utilities, and a submodule that allowscompiling the DepthAI Python modulefor other platforms.445__Documentation is available at5__Documentation is available at[https://docs.luxonis.com][https://docs.luxonis.com](https://docs.luxonis.com).__(https://docs.luxonis.com).__667-## Python modules7+## Python modules (Dependencies)889-DepthAI requites [numpy]9DepthAI Demo requires [numpy](https://numpy.org/) and [opencv-(https://numpy.org/), [opencv-python]python](https://pypi.org/project/opencv-(b)Fig. 9: Section Header Name Update Examples"}, {"figure_label": "3", "figure_type": "table", "figure_id": "tab_7", "figure_caption": "Dimensions of software documentation quality", "figure_data": "5Structure p=0.0001 d=0.82Understandability p=0.0003 d=0.62Conciseness p=0.0047 d=0.60Readability p=0.0118 d=0.45Quality p=0.0091 d=0.424Score3ScoreScoreScoreScore21 5Original Cohesion p=0.0134 d=0.42Augmented Appeal p=0.0301 d=0.36 OriginalAugmented Effectiveness Original p=0.0400 d=0.28Augmented Clarity p=0.3522 d=0.15 OriginalAugmented Consistency Original p=0.8856 d=0.024Score3ScoreScoreScoreScore21AugmentedOriginalAugmentedOriginalAugmentedOriginalAugmentedOriginalAugmentedOriginalFig. 11: Survey ResultDimensionQuestionQualityHow well-written is this document (e.g., spelling, grammar)AppealHow interesting is it?ReadabilityHow easy was it to read?Understandability How easy was it to understand?StructureHow well-structured is the document?CohesionHow well does the text fit together?ConcisenessHow succinct is the information provided?EffectivenessDoes the document make effective use of technical vocabulary?ClarityDoes the document contain ambiguity?"}], "formulas": [{"formula_id": "formula_0", "formula_text": "\u2022 Prerequisite 1 \u2022 Prerequisite 2", "formula_coordinates": [14.0, 59.87, 129.3, 33.77, 8.85]}], "doi": ""}
