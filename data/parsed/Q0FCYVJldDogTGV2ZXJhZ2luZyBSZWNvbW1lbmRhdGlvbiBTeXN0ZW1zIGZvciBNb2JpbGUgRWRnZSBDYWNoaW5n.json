{"title": "CABaRet: Leveraging Recommendation Systems for Mobile Edge Caching", "authors": "Savvas Kastanakis; Pavlos Sermpezis; Vasileios Kotronis; Xenofontas Dimitropoulos", "pub_date": "2018-06-07", "abstract": "Joint caching and recommendation has been recently proposed for increasing the efficiency of mobile edge caching. While previous works assume collaboration between mobile network operators and content providers (who control the recommendation systems), this might be challenging in today's economic ecosystem, with existing protocols and architectures. In this paper, we propose an approach that enables cache-aware recommendations without requiring a network and content provider collaboration. We leverage information provided publicly by the recommendation system, and build a system that provides cache-friendly and high-quality recommendations. We apply our approach to the YouTube service, and conduct measurements on YouTube video recommendations and experiments with video requests, to evaluate the potential gains in the cache hit ratio. Finally, we analytically study the problem of caching optimization under our approach. Our results show that significant caching gains can be achieved in practice; 8 to 10 times increase in the cache hit ratio from cache-aware recommendations, and an extra 2 times increase from caching optimization.", "sections": [{"heading": "INTRODUCTION", "text": "Mobile Edge Caching (MEC) is one of the key technologies for 5G networks [7] that can reduce latency of service delivery and offload traffic from backhaul links. In MEC, caches are located at the edge of the mobile network (e.g., base stations), and thus have limited capacity and serve smalland frequently changing-user populations [10]. These factors, despite the advances in caching policies [10] or delivery techniques [5], limit the possible gains from MEC: capacity is a tiny fraction of today's content catalogs, and traffic is highly variable; hence, a large number of user requests is for non-cached contents, i.e., not served in the edge.\nA recently proposed solution for increasing the efficiency of MEC is jointly caching and recommending content [2,4,13]. Recommendation Systems (RS) are integrated in many popular services (e.g., YouTube, Netflix) and significantly affect the user demand [6,14]. Therefore, steering recommendations towards cached contents, can significantly increase the cache hit ratio, even with small caches or populations.\nHowever, joint caching and recommendation requires collaboration between network operators and Content Providers (CPs). This might be challenging, due to the different scope of these entities, and the constraints of current network protocols and architectures. For example, CPs encrypt traffic (e.g., https) and do not typically share user-related information [11].\nTo bridge this gap, we propose an approach that is applicable in today's networks: the network operator leverages the information made available by the RS, and, based on this, provides independently of the CP high-quality and cachefriendly recommendations that increase the efficiency of MEC. Specifically, we consider the YouTube service, and design a system/application that (i) obtains video relations from the YouTube API, based on which (ii) it builds extended lists of directly and indirectly related videos, and (iii) carefully steers initial recommendations -and thus user demand-towards cached videos. These operations can take place without any tight collaboration with the CP, thus facilitating the application of joint caching and recommendation approaches by network operators (or other entities), without any need for modifications in architectures or protocols.\nOur contributions are summarized as follows:\n\u2022 We propose an approach that enables joint caching and recommendation, without requiring collaboration between network operators and CPs (Sec. 2). \u2022 We design an algorithm (named CABaRet) that leverages available information provided by a RS, and returns cacheaware recommendations (Sec. 3). \u2022 We perform extensive measurements over the YouTube service. Our results show that significant caching gains can be achieved in practice; even in conservative scenarios, our approach increases the cache hit ratio by a factor of 8 to 10 (Sec. 4). \u2022 We analytically study the problem of caching optimization under recommendations from CABaRet, and propose an approximation algorithm. We show that when caching is controlled by the network operator, an extra 2 times increase in the cache hit ratio can be achieved (Sec. 5).\nFinally, while in this paper we focus on the YouTube service, which provides a public API, our approach can be extended to other video/radio services (e.g., Neflix, Vimeo, Spotify, Pandora) as well, e.g., using offline crawling processes (in case APIs are not available) for discovering content relations.", "publication_ref": ["b6", "b9", "b9", "b4", "b1", "b3", "b12", "b5", "b13", "b10"], "figure_ref": [], "table_ref": []}, {"heading": "SYSTEM OVERVIEW", "text": "The proposed approach can be implemented in a lightweight system/application that runs on mobile devices, and is triggered either by the network operator or by the user. The system is composed of the user interface (UI), the back-end, and the recommendation module, as depicted in Fig. 1.\nUser Interface (UI). The UI resembles the original content service UI. For instance, in the YouTube case, the UI contains a search bar, a video player, and a list of related videos 1 . The users search, browse, and watch videos through the UI.\nBack-end. The back-end is responsible for (i) retrieving the list of cached video IDs (e.g., in the form of a text file), and (ii) streaming videos to the UI. Depending on the scenario, the list of cached video IDs can be already known to the network operator, e.g., in the case of network-controlled caching. Alternatively, they can be requested from the content provider directlyfoot_1 , or discovered through offline network measurements (e.g., latency [9], or DNS resolution [1]) by the network operator. The video requested by the user is delivered / streamed from the CP's (e.g., YouTube's) origin server, or the CP's cache, or an edge cache. In case the caches are controlled by the content provider (which is the most prevalent scenario today), the user-service communication can be encrypted (e.g., https requests directly to YouTube) and remain transparent to the network operator.\nRecommendation Module. The recommendation module is triggered upon each content request, and (i) receives as input the video that the user currently watches, (ii) retrieves from the YouTube API a list of video IDs directly/indirectly related to , (iii) extracts from the back-end the list of cached video IDs, and (iv) builds a list of related and cached video IDs and recommends it to the user, according to the cacheaware recommendation algorithm of Sec. 3. This recommendation process is lightweight and can return the list of recommendations very fast (e.g., \u223c1sec. in our prototype), without affecting the user experience.", "publication_ref": ["b8", "b0"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "CACHE-AWARE RECOMMENDATIONS", "text": "In existing approaches, e.g., [2,4,13], the \"most related\" contents that are also cached, are recommended to users. However, this requires the system to be aware of the content relations (e.g., similarity scores, user preferences/history, trending videos), i.e., information owned by the content provider. Such data are unlikely to be disclosed to third parties, due to privacy and/or economic reasons (e.g., advertising). In our approach, the system leverages information about content relations that is made publicly available by the RS of the content service (i.e., YouTube in this paper). In particular, when a user watches a video , the system requests from the YouTube API a list of video IDs L related to , i.e., the videos that YouTube would recommend to the user. Then it requests the related video IDs for every video in L and adds them in the end of L, and so on, in a Breadth-First Search (BFS) manner. In the end of the process, the list L contains IDs of videos directly and indirectly related to , from which the top N cached and/or highly related to videos are finally recommended to the user. The list L is (i) much larger than the list of videos recommended by YouTube, and thus it is more probable to contain cached videos that are related to , and (ii) built based on video relations provided by YouTube itself, which satisfies a high quality of recommendations.\nWe detail our recommendation algorithm (CABaRet) in Sec. 3.1, and discuss the related design implications in Sec. 3.2.", "publication_ref": ["b1", "b3", "b12"], "figure_ref": [], "table_ref": []}, {"heading": "The Recommendation Algorithm", "text": "Input. The recommendation algorithm receives as input:\n\u2022 : the video ID (or URL) which is currently watched \u2022 N : the number of videos to be recommended \u2022 C: the list with the IDs of the cached videos \u2022 D BF S : the depth to which the BFS proceeds \u2022 W BF S : the number of related videos that are requested per content from the YouTube API (i.e., the \"width\" of BFS)\nOutput. The recommendation algorithm returns as output:\n\u2022 R: ordered list of N video IDs to be recommended.\nWorkflow. CABaRet searches for videos related to video in a BFS manner as follows (line 1 in Algorithm 1). Initially, it requests the W BF S videos related to , and adds them to a list L in the order they are returned from the YouTube API.\nFor each video in L, it further requests W BF S related videos, as shown in Fig. 2, and adds them in the end of L. It proceeds similarly for the newly added videos, until the depth D BF S is reached; e.g., if D BF S = 2, then L contains W BF S video IDs related to , and W BF S \u2022 W BF S video IDs related to the related videos of . Then, CABaRet searches for video IDs in L that are also included in the list of cached videos C and adds them to the list of video IDs to be recommended R, until all IDs in L are explored or the list R contains N video IDs, whichever comes first (lines 4-9). If after this step, R contains less than N video IDs, N -|R| video IDs from the head of the list L are added to R; these IDs correspond to the top N -|R| non-cached videos that are directly related to video (lines 10-15).", "publication_ref": [], "figure_ref": ["fig_1"], "table_ref": []}, {"heading": "Implications and Design Choices", "text": "High-quality recommendations. Using the YouTube recommendations ensures strong relations between videos that are directly related to (i.e., BFS at depth 1). Moreover, while the YouTube RS finds hundreds of videos highly related to , only a subset of them are recommended to the user [3]. The rationale behind CABaRet is to explore the related videos that are not communicated to the user. To this end, based on the fact that related videos are similar and have high probability of sharing recommendations (i.e., if video a is \nif i \u2264 N then 12:\nR.append(c)\n13: i \u2190 i + 1 14:\nend if 15: end for 16: return R related to b, and b to c, then it is probable that c relates to a), CABaRet tries to infer these latent video relations through BFS. Hence, videos found by BFS in depths > 1 are also (indirectly) related to and probably good recommendations as well.\nTo further support the above claim, we collect and analyze datasets of related YouTube videos. Specifically, we consider the set of most popular videos, let P, in a region, and for each \u2208 P we perform BFS by requesting the list of related videos (similarly to line 1 in CABaRet). We use as pa-rametersW BF S = {10, 20, 50} and D BF S = 2, i.e., considering the directly related videos (depth 1) and indirectly related videos with depth 2. We denote as R 1 ( ) and R 2 ( ), the set of videos found at the first and second depth of the BFS, respectively. We calculate the fraction of the videos in R 1 ( ) that are also contained in R 2 ( ), i.e., I ( )\n= |R 1 ( )\u2229R 2 ( )| |R 1 ( )|\n. High values of I ( ) indicate a strong similarity of the initial content with the set of indirectly related contents at depth 2.\nTable 1 shows the median values of I ( ), over the |P | = 50 most popular contents in the region of Greece (GR), for different BFS widths. As it can be seen, I ( ) is very high for most of the initial videos . For larger values of W BF S , I ( ) increases, and when we fully exploit the YouTube API capability, i.e., for W BF S =50, which is the maximum number of related videos returned by the YouTube API, the median value of I ( ) becomes larger than 0.9. Finally, we measured the I ( ) in other regions as well, and observed that even in large (size/population) regions, the I ( ) values remain high, e.g., in the United States (US) region, I ( )=0.8 for W BF S =50. Tuning CABaRet. The parameters D BF S ,W BF S can be tuned to achieve a desired performance, e.g., in terms of probability of recommending a cached or highly related video.\nFor large D BF S , the similarity between and the videos at the end of the list L is expected to weaken, while for small D BF S the list L is shorter and it is less probable that a cached content is contained in it. Hence, the parameter D BF S can be used to achieve a trade-off between quality of recommendations (small D BF S ) and probability of recommending a cached video (large D BF S ). The number of related videos requested per content W BF S , can be interpreted similarly to D BF S . A small W BF S leads to considering only top recommendations per video, while a large W BF S leads to a larger list L.\nRemark: YouTube imposes quotas on the API requests per application per day, which prevents API users from setting the parameters W BF S and D BF S to arbitrarily large values.\nIn practice, CABaRet can be fine-tuned through experimentation with real users, e.g., A/B testing iterations, which is a common approach for tuning recommendation systems [3].", "publication_ref": ["b2", "b2"], "figure_ref": [], "table_ref": ["tab_0"]}, {"heading": "MEASUREMENTS AND EVALUATION", "text": "We conduct measurements and experiments over the YouTube service 3 , to investigate the performance (in terms of cache hit ratios) of our approach in MEC scenarios. The setup of the scenarios is presented in Sec. 4.1, and the results in Sec. 4.2.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Setup", "text": "The YouTube API provides a number of functions to retrieve information about videos, channels, user ratings, etc. In our measurements, we request the following information:\n\u2022 the most popular videos in a region (max. 50)\n\u2022 the list of related videos (max. 50) for a given video Remark: In the remainder, we present results collected during March 2018, for the region of Greece (GR). Nevertheless, our insights hold also in the other regions we tested (e.g., US).. Caching. We assume a MEC cache storing the most popular videos in a region. We populate the list of cached contents with the top C video IDs returned from the YouTube API.\nRecommendations. We consider two classes of scenarios with (i) YouTube and (ii) CABaRet recommendations. In both cases, when a user enters the UI, the 50 most popular videos in her region are recommended to her (as in YouTube's front 3 Our experiments and use of the YouTube API conform to the YouTube terms of service https://www.youtube.com/static?template=terms. page). Upon watching a video , a list of N = 20 videos is recommended to the user; the list is (i) composed of the top N directly related videos returned from the YouTube API (YouTube scenarios), or (ii) generated by CABaRet with parameters N , W BF S and D BF S (CABaRet scenarios).\nVideo Demand. In each experiment, we assume a user that enters the UI and watches one of the initially recommended (i.e., 50 most popular) videos at random. Then, the system recommends a list of N videos (r 1 , r 2 , ..., r N ), and the user selects with probability p i to watch r i next. We set the probabilities p i to depend on the order of appearance -and not the content-and consider uniform (p i = 1 N ) and Zipf (p i \u223c 1 i \u03b1 ) scenarios; the higher the exponent \u03b1 of the Zipf distribution, the more preference is given by the user to the top recommendations (user preference to top recommendations has been observed in YouTube traffic [9]).", "publication_ref": ["b8"], "figure_ref": [], "table_ref": []}, {"heading": "Results", "text": "", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Single Requests.", "text": "We first consider scenarios of single requests (similarly to [2,13]). In each experiment i (i = 1, ..., M) a user watches one of the top popular videos, let 1 (i), and then follows a recommendation and watches a video 2 (i). We measure the Cache Hit Ratio (CHR), which we define as the fraction of the second requests of a user that are for a cached video (since the first request is always for a cached -top popular-video):\nCHR = 1 M \u2022 M i =1 I 2 (i )\u2208C\nwhere I 2 (i )\u2208C = 1 if 2 (i) \u2208 C and 0 otherwise, and M the number of experiments 4 .\nCHR vs. BFS parameters. Fig. 3 shows the CHR achieved by CABaRet under various parameters, along with the CHR under regular YouTube recommendations, when caching all the most popular videos (|C|=50). The efficiency of caching significantly increases with CABaRet, even when only directly related contents are recommended (D BF S =1), i.e., without loss in recommendation quality. Just reordering the list of YouTube recommendations (as suggested in [9]), brings gains when p i is not uniformly distributed. However, the added gains by our approach are significantly higher. As expected, the CHR increases for larger W BF S and/or D BF S ; e.g., CABaRet for W BF S =50 and D BF S =2, achieves 8-10 times higher CHR than regular YouTube recommendations. Also, the CHR increases for more skewed p i distributions, since top recommendations are preferred and CABaRet places cached contents at the top of the recommendation list.\nIn experiments concerning the -larger-US region, the CHR values are lower for both regular YouTube (< 0.5%) and  CABaRet (1% -43%) recommendations, due to the fact that the top popular videos appear with lower frequency in the related lists. However, the relative gains from CABaRet are consistent with (or even higher than) the presented results.\nCHR vs. number of cached videos. We further consider scenarios with varying number of cached contents C = |C|.\nIn each scenario, we assume that the C most popular contents are cached. Fig. 4 shows the CHR achieved by CABaRet, in comparison to scenarios under regular YouTube recommendations. The results are consistent for all considered values ofC; the CHR under CABaRet is significantly higher than in the YouTube case. Moreover, even when caching a small subset of the most popular videos, CABaRet brings significant gains. E.g., by caching C = 10 out of the 50 top related contents CABaRet increases the CHR from 2% and 3.2% to 17% and 50%, for the uniform and Zipf(\u03b1=1) scenarios, respectively.", "publication_ref": ["b1", "b12", "b8"], "figure_ref": ["fig_3", "fig_4"], "table_ref": []}, {"heading": "Sequential Requests.", "text": "We now test the performance of our approach in scenarios where users enter the system and watch a sequence of K, K > 2, videos (similarly to [4], and in contrast to the previous case, where they watch only two videos, i.e., K = 2). At each step, the system recommends a list of videos to the user by applying CABaRet on the currently watched video. We denote as k (i) the k th video requested/watched by a user in experiment i. We measure the CHR, which is now defined as\nCHR = 1 M \u2022 M i =1 K k=2 I k (i )\u2208C\nwhere I k (i )\u2208C = 1 if k (i) \u2208 C and 0 otherwise, over M = 100 experiments per scenario.\nMoving \"farther\" from the initially requested video (which belongs to the list of most popular and cached videos) through a sequence of requests, we expect the CHR to decrease, due to lower similarity of the requested and cached videos. However, as Fig. 5 shows, the decrease in the CHR (under CABaRet recommendations) is not large. The CHR remains close to  the case of single requests (i.e., for K=2 in the x-axis), indicating that our approach performs well even when we are several steps far from the cached videos. In fact, caching more than the top most popular videos appearing on the front page, would further reduce the CHR decrease.", "publication_ref": ["b3"], "figure_ref": ["fig_5"], "table_ref": []}, {"heading": "CACHING OPTIMIZATION", "text": "In this section, we extend our study by considering the scenario where CABaRet and the caches are controlled by the same entity, e.g., the network operator. Network operatorcontrolled caching is the most commonly considered scenario in related work for MEC; although in most of today's architectures the caches are actually controlled by the CP.\nIn this scenario, the network operator can optimize caching decisions, thus further increasing the efficiency of CABaRet recommendations. Note that still there is no need for collaboration between the operator and the CP (e.g., possessing full knowledge of the RS), assumed in previous works [2,4,13].\nIn the following, we first analytically formulate and study the problem of optimizing the caching policy, and propose an approximation algorithm with provable performance guarantees (Sec. 5.1). We then evaluate the performance of this joint caching and recommendation approach (Sec. 5.2).", "publication_ref": ["b1", "b3", "b12"], "figure_ref": [], "table_ref": []}, {"heading": "Optimization Problem & Algorithm", "text": "Let a content catalog V, V = |V |, and a content popularity vector q = [q 1 , ..., q V ] T . Let L( ) \u2286 V be the set of contents that are explored by CABaRet (at line 1) for a content \u2208 V, and denote L = \u2208V L( ). For some set of cached contents C \u2286 V, and a content , CABaRet returns a list of recommendations R( ) (|R( )| = N ), in which at most N contents c \u2208 C \u2229 L( ) appear at the top of the list. Therefore, CHR can be expressed as\nCHR(C) = \u2208V q N (C, ) i =1 p i(1)\nwhere N (C, ) = min{|C \u2229 L( )|, N }, and p i is the probability for a user to select the i th recommended content.\nThen, the problem of optimizing the caching policy (to be jointly used with CABaRet), is formulated as follows:\nmax C CHR(C) s.t ., |C| \u2264 C (2\n)\nwhere C is the capacity of the -MEC-cache. We prove the following for the optimization problem of Eq. ( 2).\nL 1. The optimization problem of Eq. ( 2): (i) is NPhard, (ii) cannot be approximated within 1 -1 e + o(1) in polynomial time, and (iii) has a monotone (non-decreasing) submodular objective function, and is subject to a cardinality constraint.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "P", "text": ". Items (i) and (ii) of the above lemma, are proven by reduction to the maximum set coverage problem, and we prove item (iii) using standard methods (see, e.g., [5,13]).\nIf we design a greedy algorithm that starts from an empty set of cached contents C = \u2205, and at each iteration it augments the set C (until |C | = C) as follows:\nC \u2190 C \u222a arg max \u2208V CHR(C \u222a { }),(3)\nthen the properties stated in item (iii) satisfy that it holds [8] CHR\n(C ) \u2265 1 - 1 e \u2022 CHR(C * )(4)\nwhere C * the optimal solution of the problem of Eq. ( 2). Remark: While Eq. ( 4) gives a lower bound for the performance of the greedy algorithm, in practice greedy algorithms have been shown to perform often very close to the optimal.", "publication_ref": ["b4", "b12", "b7"], "figure_ref": [], "table_ref": []}, {"heading": "Evaluation of Greedy Caching", "text": "Calculating the CHR from Eq. ( 1) requires running a BFS (CABaRet, line 1) and generating the lists L( ), for every content \u2208 V. In practice, for scalability reasons, the most popular contents (i.e., with high q i ) can be considered by the greedy algorithm in the calculation of the objective function Eq. ( 1), since those contribute more to the objective function. However, any video in the catalog is still candidate to be cached, e.g., a video with low q i can bring a large increase in the CHR through its association with many popular contents.\nIn fact, in our experiments, for the calculation of Eq. ( 1), we consider only the 50 most popular videos, for which we set q i = 1 50 . Nevertheless, in the different scenarios we tested, only 10% to 30% of the cached videos (selected by the greedy algorithm) were also in the top 50 most popular.\nIn Fig. 6, we compare the achieved CHR when the cache is populated according to the greedy algorithm of Eq. (3) (Greedy Caching), and with the top most popular videos (Top Caching). Greedy caching always outperforms top caching, with an increase in the CHR of around a factor of 2 for uniform video selection (for the Zipf(a=1) scenarios we tested, the CHR values are even higher, and the relative performance is 1.5 times higher). This clearly demonstrates that the gains from joint recommendation and caching [2,13], are applicable even in simple practical scenarios (e.g., CABaRet & greedy caching). Finally, while greedy caching increases the CHR even with regular YouTube recommendations, the CHR is still less than 50% of the CABaRet case with top caching. This further stresses the benefits from CABaRet's cache-aware recommendations.", "publication_ref": ["b1", "b12"], "figure_ref": ["fig_6"], "table_ref": []}, {"heading": "RELATED WORK", "text": "In the recent works of [2,4,13], caching and recommendation of contents is considered for mobile networks. [2,13] jointly optimize the caching and recommendation policies, while [4] optimizes cache-aware recommendations for sequential requests. Our work is complementary to these works: we propose an approach for deploying joint caching and recommendation in practice, without collaboration between network operators and content providers. Moreover, our extensive measurements over the real YouTube service show that the gains demonstrated in [2,4,13] can be achieved even today, using a simple and lightweight system.\n[9] studies how to improve the efficiency of YouTube caches, by reordering the list of recommendations. CABaRet goes beyond reordering, and leverages more information that is available through the YouTube API; as our results show, this can bring substantial gains in the CHR.\nFinally, research on the performance of the YouTube CDN in relation to network parameters [1,9,12], indicates that our approach can be relevant to wireline networks as well. For instance, on top of classic load-balancing, network-aware recommendations (e.g., taking into account routing policies [1,12], inter-domain load balancing [12], cache locations [1]) can be used to improve the user QoE (e.g., latency).", "publication_ref": ["b1", "b3", "b12", "b1", "b12", "b3", "b1", "b3", "b12", "b0", "b8", "b11", "b0", "b11", "b11", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "CONCLUSION", "text": "In this paper, we proposed an approach that enables joint caching and recommendation in MEC, without requiring tight collaboration of network and content providers. We considered the YouTube service as our use case, and showed that significant gains can be achieved by leveraging available information from its recommendation system.\nThe effect of geographical and temporal factors on the gains from cache-aware recommendations, can be further investigated in the future to extend our initial experimental results. Moreover, we believe that analytically studying the interplay between content relations and potential gains with CABaRet, as well as extending our approach to other online content services, are interesting research directions.", "publication_ref": [], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "Where do you \"tube\"? uncovering YouTube server selection strategy", "journal": "", "year": "2011", "authors": "V K Adhikari; S Jain; Z.-L Zhang"}, {"ref_id": "b1", "title": "Caching-aware Recommendations: Nudging User Preferences towards better Caching Performance", "journal": "", "year": "2017", "authors": "L.-E Chatzieleftheriou; M Karaliopoulos;  Koutsopoulos"}, {"ref_id": "b2", "title": "Deep neural networks for YouTube recommendations", "journal": "", "year": "2016", "authors": "P Covington; J Adams; E Sargin"}, {"ref_id": "b3", "title": "Show me the Cache: Optimizing Cache-Friendly Recommendations for Sequential Content Access", "journal": "", "year": "2018", "authors": "T Giannakas; P Sermpezis; T Spyropoulos"}, {"ref_id": "b4", "title": "FemtoCaching: Wireless video content delivery through distributed caching helpers", "journal": "", "year": "2012", "authors": "N Golrezaei; K Shanmugam; A G Dimakis; A F Molisch; G Caire"}, {"ref_id": "b5", "title": "The netflix recommender system: Algorithms, business value, and innovation", "journal": "ACM Transactions on Management Information Systems (TMIS)", "year": "2016", "authors": "C Gomez-Uribe; N Hunt"}, {"ref_id": "b6", "title": "Mobile Edge Computing A key technology towards 5G", "journal": "ETSI White Paper", "year": "2016", "authors": "Y C Hu; M Patel; D Sabella; N Sprecher; V Young"}, {"ref_id": "b7", "title": "Submodular function maximization", "journal": "Tractability: Practical Approaches to Hard Problems", "year": "2012", "authors": "A Krause; D Golovin"}, {"ref_id": "b8", "title": "Cachecentric video recommendation: an approach to improve the efficiency of YouTube caches", "journal": "ACM Transactions on Multimedia Computing, Communications, and Applications (TOMM)", "year": "2015", "authors": "D K Krishnappa; M Zink; C Griwodz; P Halvorsen"}, {"ref_id": "b9", "title": "Placing Dynamic Content in Caches with Small Population", "journal": "", "year": "2016", "authors": "M Leconte; G Paschos; L Gkatzikis; M Draief; S Vassilaras; S Chouvardas"}, {"ref_id": "b10", "title": "Cryptocache: Network caching with confidentiality", "journal": "", "year": "2017", "authors": "J Leguay; G Paschos; E Quaglia; B Smyth"}, {"ref_id": "b11", "title": "Revealing the Load-Balancing Behavior of YouTube Traffic on Interdomain Links", "journal": "", "year": "2018", "authors": "R Mok; V Bajpai; A Dhamdhere; Kc Claffy"}, {"ref_id": "b12", "title": "Femto-Caching with Soft Cache Hits: Improving Performance with Related Content Recommendation", "journal": "", "year": "2017", "authors": "P Sermpezis; T Spyropoulos; L Vigneri; T Giannakas"}, {"ref_id": "b13", "title": "The Impact of YouTube Recommendation System on Video Views", "journal": "", "year": "2010", "authors": "R Zhou; S Khemmarat; L Gao"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Figure 1 :1Figure 1: System overview.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "Figure 2 :2Figure 2: CABaRet: example with D BF S = 2, W BF S = 3, N = 6. Cached videos are denoted with black color.", "figure_data": ""}, {"figure_label": "1", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "Algorithm 11CABaRet: Cache-Aware & BFS-related Recommendations Input : , N , C, D BF S ,W BF S 1: L \u2190 BFS( , D BF S ,W BF S ) \u22b2 ordered set of video IDs 2: R \u2190 \u2205 \u22b2 ordered set of video IDs to be recommended 3: i \u2190 1 4: for c \u2208 L do 5: if i \u2264 N and c \u2208 C then 6: R.append(c) 7: i \u2190 i + 1 8: end if 9: end for 10: for c \u2208 L \\ R do 11:", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Figure 3 :3Figure 3: CHR under different BFS parameters.", "figure_data": ""}, {"figure_label": "4", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "Figure 4 :4Figure 4: CHR vs. # cached contents C (W BF S =50, D BF S =2).", "figure_data": ""}, {"figure_label": "5", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Figure 5 :5Figure 5: CHR vs. # requests in sequence K (C=20, W BF S =20, D BF S =2). Note: y-axis up to 40%.", "figure_data": ""}, {"figure_label": "6", "figure_type": "figure", "figure_id": "fig_6", "figure_caption": "Figure 6 :6Figure 6: CHR vs. # cached contents (p i uniform, W BF S =50, D BF S =2).", "figure_data": ""}, {"figure_label": "1", "figure_type": "table", "figure_id": "tab_0", "figure_caption": "I ( ) vs. W BF S for the region of GR.", "figure_data": "W BF S : 102050I ( ) : 0.70 0.85 0.92"}], "formulas": [{"formula_id": "formula_0", "formula_text": "if i \u2264 N then 12:", "formula_coordinates": [3.0, 320.64, 255.03, 86.18, 21.07]}, {"formula_id": "formula_1", "formula_text": "13: i \u2190 i + 1 14:", "formula_coordinates": [3.0, 320.64, 278.87, 81.31, 21.11]}, {"formula_id": "formula_2", "formula_text": "= |R 1 ( )\u2229R 2 ( )| |R 1 ( )|", "formula_coordinates": [3.0, 497.04, 524.47, 59.05, 16.0]}, {"formula_id": "formula_3", "formula_text": "CHR = 1 M \u2022 M i =1 I 2 (i )\u2208C", "formula_coordinates": [4.0, 390.6, 408.19, 93.39, 30.31]}, {"formula_id": "formula_4", "formula_text": "CHR = 1 M \u2022 M i =1 K k=2 I k (i )\u2208C", "formula_coordinates": [5.0, 118.44, 579.19, 109.47, 30.8]}, {"formula_id": "formula_5", "formula_text": "CHR(C) = \u2208V q N (C, ) i =1 p i(1)", "formula_coordinates": [5.0, 382.8, 676.51, 175.53, 31.16]}, {"formula_id": "formula_6", "formula_text": "max C CHR(C) s.t ., |C| \u2264 C (2", "formula_coordinates": [6.0, 113.16, 138.47, 177.38, 10.24]}, {"formula_id": "formula_7", "formula_text": ")", "formula_coordinates": [6.0, 290.54, 138.47, 3.55, 9.7]}, {"formula_id": "formula_8", "formula_text": "C \u2190 C \u222a arg max \u2208V CHR(C \u222a { }),(3)", "formula_coordinates": [6.0, 100.8, 342.95, 193.29, 15.4]}, {"formula_id": "formula_9", "formula_text": "(C ) \u2265 1 - 1 e \u2022 CHR(C * )(4)", "formula_coordinates": [6.0, 128.58, 378.59, 165.51, 23.26]}], "doi": ""}
