{"Differentiable Edge-based OPC": "Guojin Chen \u2217 CUHK & UT Austin & NVIDIA Haoyu Yang NVIDIA Corporation Haoxing Ren NVIDIA Corporation Bei Yu Chinese University of Hong Kong David Z. Pan University of Texas at Austin", "Abstract": "Optical proximity correction (OPC) is crucial for pushing the boundaries of semiconductor manufacturing and enabling the continued scaling of integrated circuits. While pixel-based OPC, termed as inverse lithography technology (ILT), has gained research interest due to its flexibility and precision. Its complexity and intricate features can lead to challenges in mask writing, increased defects, and higher costs, hence hindering widespread industrial adoption. In this paper, we propose DiffOPC, a differentiable OPC framework that enjoys the virtue of both edge-based OPC and ILT. By employing a mask rule-aware gradient-based optimization approach, DiffOPC efficiently guides mask edge segment movement during mask optimization, minimizing wafer error by propagating true gradients from the cost function back to the mask edges. Our approach achieves lower edge placement error while reducing manufacturing cost by half compared to state-of-the-art OPC techniques, bridging the gap between the high accuracy of pixel-based OPC and the practicality required for industrial adoption, thus offering a promising solution for advanced semiconductor manufacturing.", "1 Introduction": "Optical proximity correction (OPC) is a critical technique in computational lithography that compensates for the optical proximity effect (OPE) caused by interference and diffraction in the lithographic imaging process. As integrated circuit technology nodes advance to 90 nm and below, simple resolution enhancement techniques (RET) can no longer meet the requirements for high-resolution and high-fidelity lithographic imaging. To address this challenge, OPC has evolved from rule-based OPC (RBOPC) to model-based OPC (MBOPC). RBOPC relies on a pre-established mask correction rule table, which is derived from engineering experience or fitted experimental and simulation data [1]. Although RBOPC is computationally fast and produces relatively simple optimized mask patterns, it can only compensate for local OPE and cannot find a globally optimal solution for the mask optimization problem. MBOPC,onthe other hand, is based on the physical model of lithographic imaging and employs numerical optimization algorithms to modify the mask pattern. As depicted in Figure 1, MBOPC can be further classified into edge-based OPC (EBOPC) and pixel-based OPC (PBOPC). EBOPC divides the edge contour of the mask pattern into several segments and iteratively optimizes the position of each segment along its normal direction to compensate for lithographic imaging errors [2]. However, current EBOPC methods, such as the Mask Error Enhancement Factor (MEEF) matrix algorithm [2], have limitations in \u2217 Work accomplished during internship at NVIDIA. PBOPC (ILT) SRAFs MRC violations Pxiel-based ILT Level set-based ILT MRC violations EBOPC Traditional MEEF-based EBOPC DiffOPC (Ours) SRAFs EPE: 25 EPE: 51 MRC clean MRC clean EPE: 59 EPE: 19 # Figure 1: Model-based OPC includes pixel-based OPC (ILT) and edge-based OPC (EBOPC). While ILT masks face manufacturability issues requiring significant post-processing, EBOPC masks are manufacturable but have performance limitations. DiffOPC combines the advantages of both approaches, enhancing manufacturability and performance. computational efficiency and accuracy. The algorithm is computationally intensive, scaling poorly with the size and complexity of IC layouts. Its foundational linearity assumptions often fail to account for the nonlinearities prevalent in advanced lithography, leading to subpar performance in complex cases where edge interactions are significant and not adequately captured. The MEEF matrix, further burdened by potential ill-conditioning and a static representation throughout optimization, may not adapt to dynamic process variations, thus trading off accuracy for computational manageability. PBOPC, also known as inverse lithography technology (ILT), pushes the boundaries of mask optimization by rasterizing the mask layout into a pixel array and optimizing the transmission of each mask pixel by gradient descent [3]. This approach allows for freeform curved edge contours and the addition of sub-resolution assist features (SRAF) [4-7] to improve imaging performance. ILT algorithms can be categorized into two classes based on their mask representation: end-to-end pixel-based methods for prediction [814] or acceleration, and implicit function-based methods using level sets to enhance acceleration and manufacturability [15-17]. Among the SOTA ILT methods, MultiILT [14] adopts a multi-level resolution strategy for better OPC performance and manufacturability. Despite the advancements in ILT algorithms, they still face several challenges that hinder their widespread adoption in the semiconductor industry. As illustrated in Figure 1, the pixelated mask patterns generated by ILT are often complex and difficult to manufacture, requiring costly rectangular decomposition into manufacturable Manhattan polygons. Further, the application of decomposition and mask rule check (MRC) methods to regularize the mask patterns may lead to a decline in OPC performance and introduce new hotspots, negating the performance advantages of ILT. Moreover, ILT algorithms tend to over-optimize shape corners because the simulated line-ends will never match the Manhattan rectangles at the line-end. Nevertheless, these challenges have been largely overlooked, preventing ILT's large-scale adoption in the industry, which tends to favor EBOPC due to lower manufacturing costs. To bridge the gap between the manufacturability of EBOPC and the performance of ILT, we propose DiffOPC, a differentiable edgebased OPC method that leverages gradient information to optimize edge placement error (EPE) while considering process variation. By relaxing discrete edge movements and embedding mask rule constraints into the gradient computation, DiffOPC combines EBOPC's high manufacturability with ILT's performance. Additionally, it ensures MRC-clean results, allowing the optimized mask patterns to be directly used for mask fabrication without additional postprocessing. DiffOPC introduces efficient solutions to enhance the edge-based OPC process. In the forward algorithm, a flexible segmentation approach and CUDA-accelerated ray casting expedite differentiable layout rasterization, while a novel SRAF seed generation algorithm optimizes SRAF placement. In the backward algorithm, DiffOPC computes lithography gradients for edge movements using a chain-rule approach and incorporates mask rule constraints to ensure manufacturability. By combining these improvements, DiffOPC achieves superior OPC performance with high manufacturability. In summary, our main contributions are as follows: We propose DiffOPC, a differentiable edge-based OPC framework that integrates EPE loss and leverages MRC-aware gradi- \u00b7 ents for mask optimization. \u00b7 A flexible segmentation approach and a CUDA-accelerated ray casting algorithm are introduced to expedite layout rasterization. \u00b7 DiffOPC efficiently computes edge segment gradients using a chain-rule approach to ensure manufacturability. \u00b7 A novel SRAF seed generation algorithm leveraging gradients for optimal SRAF placement and further optimization. \u00b7 DiffOPC bridges the gap between EBOPC's manufacturability and ILT's performance, offering a promising solution for highquality and efficient OPC corrections. The experimental results show that DiffOPC reduces EBOPC's EPE by half, and even achieves lower EPE than ILT while maintaining manufacturing costs that are half of ILT's.", "2 Preliminaries": "", "2.1 Forward Lithography Model": "We employ the sum of coherent systems (SOCS) decomposition of a 193 \ud835\udc5b\ud835\udc5a wavelength system as the optical model for lithography modeling, following the same approach as [18]. The aerial image intensity \ud835\udc70 is represented by the convolution of the mask \ud835\udc74 and a set of optical kernels \ud835\udc6f . The \ud835\udc41 \ud835\udc61\u210e \ud835\udc58 order approximation to the partially coherent system is obtained using eq. (1):  where \u2297 denotes the convolution operation, \u210e \ud835\udc56 is the \ud835\udc56 \ud835\udc61\u210e kernel of \ud835\udc6f , \ud835\udf0e \ud835\udc56 is the corresponding weight of the coherent system, and ( \ud835\udc65,\ud835\udc66 ) is the index notation of the matrix. \ud835\udc74 ( \ud835\udc65,\ud835\udc66 ) represents the pixel value at the point ( \ud835\udc65,\ud835\udc66 ) of the mask image \ud835\udc74 . A constant threshold resist model (CTR) is applied to convert the aerial image intensity \ud835\udc70 to the printed resist image \ud835\udc81 .  where \ud835\udc3c \ud835\udc61\u210e is the intensity threshold.", "2.2 Evaluation Metrics": "In this paper, we use squared \ud835\udc3f 2 error, process variation band (PVB) and edge placement error (EPE) as three typical metrics to evaluate OPC performance. Moreover, the mask fracturing shot count (#shot) proposed in [10] is also applied in this work to evaluate mask complexity and manufacturability. Squared \ud835\udc3f 2 error \ud835\udc3f 2 measures the difference between the nominal resist image \ud835\udc81 \ud835\udc5b\ud835\udc5c\ud835\udc5a and the target image \ud835\udc7b , defined as:  PVB evaluates the robustness of the mask against different process conditions. A smaller PVB indicates a more robust mask. PVB ( \ud835\udc81 \ud835\udc5a\ud835\udc4e\ud835\udc65 , \ud835\udc81 \ud835\udc5a\ud835\udc56\ud835\udc5b ) = \u2225 \ud835\udc81 \ud835\udc5a\ud835\udc4e\ud835\udc65 -\ud835\udc81 \ud835\udc5a\ud835\udc56\ud835\udc5b \u2225 2 2 . Edge placement error The Edge Placement Error (EPE) [18] quantifies the geometric distortion of the resist image. Shot count #Shot [10] is the number of decomposed rectangles that replicate the original mask exactly.", "2.3 Problem Formulation": "Given a target design \ud835\udc7b , we aim to find a set of boundary segments \ud835\udc7a = { \ud835\udc94 1 , \ud835\udc94 2 , . . . , \ud835\udc94 \ud835\udc56 } , and a binary mask \ud835\udc74 \u2208 { 0 , 1 } \ud835\udc5a \u00d7 \ud835\udc5b formed by the matrix inside the boundary composed of these segments \ud835\udc7a , where \ud835\udc5a and \ud835\udc5b are the dimensions of \ud835\udc7b . The objective is to determine the corresponding printed image \ud835\udc81 that minimizes the weighted sum of EPE, \ud835\udc3f 2 , PVB, and #shots.", "3 DiffOPC Algorithm": "To enable the application of differentiable EBOPC to arbitrary layout patterns while utilizing minimal additional information, such as the EPE measure points, several challenges need to be addressed: 1) Ensuring a more flexible movement of segments in Manhattan geometries, particularly at pattern corners. 2) Mapping discrete edge movements to a continuous space for efficient updates. 3) Maintaining compatibility with the chain rule for differentiation during the rasterization process, which converts edge parameters to pixel binary masks. In this section, we introduce the movement and update mechanisms for edge segments, describe a CUDA-accelerated ray casting algorithm for rasterization, demonstrate how lithography gradients can be utilized to update the movement of edge segments, and introduce an algorithm for SRAF placement.", "3.1 Edge Segmentation and Movement": "We present Algorithm 1 for segmenting target polygon edges into smaller segments of a pre-defined length. The algorithm returns a minimal set of segments, denoted as \ud835\udc7a \u2208 R \ud835\udc41 \ud835\udc60 \u00d7 2 \u00d7 2 , where R represents the real number domain and \ud835\udc41 \ud835\udc60 is the number of segments. Each segment \ud835\udc94 \ud835\udc56 \u2208 \ud835\udc7a is represented by its starting and ending coordinates in vector form: [[ \ud835\udc65 1 , \ud835\udc66 1 ] , [ \ud835\udc65 2 , \ud835\udc66 2 ]] . These segments \ud835\udc7a serve Figure 2: DiffOPC: differentiable edge-based OPC framework. Initial Segments Optimized Segments Mask gradient Mask Resist Initialize Update STE Corner Merge Rasterization Forward Lithography Lithography Gradient Calculate Loss Gradient Interpolation GDS OASIS Layout Corner Segments Horizontal & Vertical Segments DiffOPC Forward DiffOPC Backward Segment Gradients & Velocities as the optimization parameters for DiffOPC, providing increased flexibility in handling corner edges compared to traditional EBOPC methods which only optimize the edge movement distance. As illustrated in Figure 2, each segment \ud835\udc94 \ud835\udc56 is associated with a direction vector \ud835\udc85 \ud835\udc56 \u2208 D , which enables better reconstruction of segments back into polygons and determines the direction of movement. Furthermore, the algorithm ensures compliance with the MRC by merging excessively short segments when necessary.", "Algorithm 1 Edge Parameter Initialization.": "Input: \ud835\udc5d\ud835\udc5c\ud835\udc59\ud835\udc66\ud835\udc54\ud835\udc5c\ud835\udc5b\ud835\udc60 : mask polygon coordinates; \ud835\udc60\ud835\udc52\ud835\udc54 _ \ud835\udc59\ud835\udc52\ud835\udc5b\ud835\udc54\ud835\udc61\u210e : segment length. Output: \ud835\udc4e\ud835\udc59\ud835\udc59 _ \ud835\udc60\ud835\udc52\ud835\udc54\ud835\udc5a\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc60 : List of polygons with segmented lines & directions; 1: for \ud835\udc5d\ud835\udc5c\ud835\udc59\ud835\udc66 in \ud835\udc5d\ud835\udc5c\ud835\udc59\ud835\udc66\ud835\udc54\ud835\udc5c\ud835\udc5b\ud835\udc60 do 2: for \ud835\udc52\ud835\udc51\ud835\udc54\ud835\udc52 in \ud835\udc5d\ud835\udc5c\ud835\udc59\ud835\udc66 do 3: \ud835\udc5a\ud835\udc56\ud835\udc51\ud835\udc5d\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61 \u2190 Calculate the midpoint of the edge; 4: \ud835\udc59\ud835\udc52\ud835\udc5b\ud835\udc54\ud835\udc61\u210e \u2190 Calculate the length of the edge; 5: \ud835\udc51\ud835\udc56\ud835\udc5f\ud835\udc52\ud835\udc50\ud835\udc61\ud835\udc56\ud835\udc5c\ud835\udc5b \u2190 Get edge direction vector (horizontal or vertical); 6: if \ud835\udc59\ud835\udc52\ud835\udc5b\ud835\udc54\ud835\udc61\u210e \u2264 2 \u2217 \ud835\udc60\ud835\udc52\ud835\udc54 _ \ud835\udc59\ud835\udc52\ud835\udc5b\ud835\udc54\ud835\udc61\u210e then 7: Create two segments from \ud835\udc5a\ud835\udc56\ud835\udc51\ud835\udc5d\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61 ; 8: else 9: \ud835\udc60\ud835\udc61\ud835\udc52\ud835\udc5d\ud835\udc60 \u2190 Calculate the number of steps based on edge \ud835\udc59\ud835\udc52\ud835\udc5b\ud835\udc54\ud835\udc61\u210e and \ud835\udc60\ud835\udc52\ud835\udc54 _ \ud835\udc59\ud835\udc52\ud835\udc5b\ud835\udc54\ud835\udc61\u210e ; 10: for \ud835\udc56 \u2190- \ud835\udc60\ud835\udc61\ud835\udc52\ud835\udc5d\ud835\udc60 to \ud835\udc60\ud835\udc61\ud835\udc52\ud835\udc5d\ud835\udc60 do 11: Calculate the start and end points of the segment based on \ud835\udc5a\ud835\udc56\ud835\udc51\ud835\udc5d\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61 and step size; 12: if segment length > \ud835\udc60\ud835\udc52\ud835\udc54 _ \ud835\udc59\ud835\udc52\ud835\udc5b\ud835\udc54\ud835\udc61\u210e then 13: Split the segment into two segments at the \ud835\udc5a\ud835\udc56\ud835\udc51\ud835\udc5d\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61 ; 14: else 15: Create a single segment; 16: Mark the start or the end of edge segments as corner segments; 17: Add the segments and directions to polygon segments list; 18: Add the polygon segments and directions to \ud835\udc4e\ud835\udc59\ud835\udc59 _ \ud835\udc60\ud835\udc52\ud835\udc54\ud835\udc5a\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc60 ; 19: return \ud835\udc4e\ud835\udc59\ud835\udc59 _ \ud835\udc60\ud835\udc52\ud835\udc54\ud835\udc5a\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc60 ; In DiffOPC, after determining the segments \ud835\udc7a and their corresponding directions D , it is crucial to establish the velocity vector \ud835\udc97 \ud835\udc56 for each segment \ud835\udc94 \ud835\udc56 . The velocity vector connects the movement of edge segments with the gradients obtained from lithography simulations. The concept of velocity vectors is inspired by level set-based ILT (LSILT). In LSILT, the velocity component is the projection of the gradient of the implicit level set function \ud835\udf19 onto the mask plane, denoted as \u2207 \ud835\udf19 , which can be a vector in any direction. However, in DiffOPC, the movement direction \ud835\udc97 \ud835\udc56 of an edge segment \ud835\udc94 \ud835\udc56 is restricted to be perpendicular to its direction vector \ud835\udc85 \ud835\udc56 , (either horizontal or vertical), satisfying the condition \ud835\udc97 \ud835\udc56 \u00b7 \ud835\udc85 \ud835\udc56 = 0. Additionally, we set the default orientation of all velocity vectors \ud835\udc97 \ud835\udc56 to point outward from the polygon, as illustrated in Figure 2.", "3.2 Differentiable Edge-Based OPC": "The preprocessed data consists of segments \ud835\udc7a and corresponding velocity vectors \ud835\udc7d . \ud835\udc7a is stored as learnable parameters in tensor \ud835\udc7a \u2208 R \ud835\udc41 \ud835\udc60 \u00d7 2 \u00d7 2 , while \ud835\udc7d is a fixed tensor \ud835\udc7d \u2208 R \ud835\udc41 \ud835\udc60 \u00d7 2 used in computations, where \ud835\udc41 \ud835\udc60 is the number of segments. In DiffOPC, the forward pass from edge parameters \ud835\udc7a to the resist image \ud835\udc81 involves five differentiable steps: 1) Edge parameter rounding. 2) Merging corner edges. 3) Edge-to-mask rasterization. 4) Forward lithography simulation. 5) Loss calculation. Each step's forward and backward computations will be discussed in detail in this chapter. Differentiable edge parameter rounding . Since the edge parameters \ud835\udc7a are real-valued, while the edge coordinate system is integervalued, the rounding operation is non-differentiable. To address this issue and enable a differentiable process, we employ the straightthrough estimator (STE) for rounding \ud835\udc7a .  STE is defined as:   The forward pass illustrated in Figure 3(a) applies the rounding function to \ud835\udc7a , while the backward pass directly propagates the gradients from \u00af \ud835\udc7a to \ud835\udc7a , as shown in Figure 3(b). Figure 3: (a) STE forward; (b) STE backward. 1 2 3 4 1 2 3 0 \ud835\udc65 STE ( \ud835\udc65 ) (a) 1 2 3 1 2 3 0 \ud835\udf15\ud835\udc3f \ud835\udf15\ud835\udc65 \ud835\udf15\ud835\udc3f \ud835\udf15 STE ( \ud835\udc65 ) (b) Corner edge merging . During the optimization, as edges move, the endpoints of different segments separate. For non-corner segments, the segment length remains unchanged since they only move along the normal direction. The newly formed edges between adjacent segments can be obtained from the endpoints of the neighboring edges without additional processing. However, for segments adjacent to corners, the movement directions differ, requiring extra handling. After the movement, the new intersection point may lie outside the two segments. Therefore, it is necessary to additionally connect the segments adjacent to the corners. The adjusted algorithm is presented in Algorithm 2. After the forward pass of the corner merging operation, the modified edge parameters \u02c6 \ud835\udc7a ensure that all adjacent segments at the corners are re-connected. The backward pass is straightforward, as the gradients are directly propagated to the rounded edge parameters \u00af \ud835\udc7a .", "Algorithm 2 Find Intersection and Adjust Corner Segments": "function FindIntersectionAndAdjust(\u00af \ud835\udc60 1 , \u00af \ud835\udc60 2 ) 1: 2: \ud835\udc60 \ud835\udc63 \u2190 vertical segment; \ud835\udc60 \u210e \u2190 horizontal segment; 3: \ud835\udc5d \u2020 \u2190 the intersection point ( \ud835\udc65 of \ud835\udc60 \ud835\udc63 , \ud835\udc66 of \ud835\udc60 \u210e ); 4: if \u00af \ud835\udc60 1 is vertical then 5: Adjust the end point of the vertical line \ud835\udc60 \ud835\udc63 to \ud835\udc5d \u2020 ; 6: Adjust the start point of the horizontal line \ud835\udc60 \u210e to \ud835\udc5d \u2020 ; 7: else 8: Adjust the end point of the horizontal line \ud835\udc60 \u210e to \ud835\udc5d \u2020 ; 9: Adjust the start point of the vertical line \ud835\udc60 \ud835\udc63 to \ud835\udc5d \u2020 ; 10: return the adjusted segments ( \u02c6 \ud835\udc60 1 , \u02c6 \ud835\udc60 2 ) ;", "Differentiable rasterization using CUDA-accelerated ray cast-": "ing . The core challenge in DiffOPC is the edge-to-pixel rasterization, as the lithography model in eq. (1) only accepts pixel-based mask input \ud835\udc74 . This rasterization process must be differentiable to allow the gradient flow to reach the edge parameters from the mask, and it should be as fast as possible since it is performed in every optimization epoch. Traditional EBOPC methods involve moving segments and then filling or subtracting the corresponding binary matrix at the new positions. However, this approach is time-consuming due to the need to sequentially access each segment and convert the segment's displacement into mask indices, repeatedly reading and modifying the corresponding locations. To address these issues, a method that effectively generates a binary mask from rounded edge parameters using CUDA-accelerated ray casting is proposed in Algorithm 3. Algorithm 3 presents an efficient, fully parallelized method for generating a binary mask from edge parameters using ray casting. The main function, Rasterize , initializes an empty mask and a count matrix, then extracts horizontal segments from the edge parameters. Since the polygons in the mask are Manhattan rectangles and closed shapes, the algorithm only needs to process segments along one direction (either horizontal or vertical), reducing the computational cost by half. For each segment, the algorithm performs parallel computation across all grid points within the bounding box, calling the check_cross function to determine ray-segment intersections. The check_cross function uses cross products to efficiently check if a ray from a point intersects a segment. After processing all segments, the even-odd rule is applied to finalize the binary mask based on the parity of intersections at each point. The algorithm leverages parallel computation, efficient ray-segment intersection checks, and the properties of Manhattan rectangles to enable fast and accurate mask generation, making it suitable for use in the DiffOPC framework. Algorithm 3 Parallelized Ray Casting for Edge to Mask Rasterization Input: Merged edge parameters: \u02c6 \ud835\udc7a , width \ud835\udc4a , height \ud835\udc3b ; Output: Binary mask: \ud835\udc5a\ud835\udc4e\ud835\udc60\ud835\udc58 ; 1: function Rasterize ( \u02c6 \ud835\udc7a , \ud835\udc4a , \ud835\udc3b ) 2: \ud835\udc5a\ud835\udc4e\ud835\udc60\ud835\udc58 \u2190 zeros (( \ud835\udc4a,\ud835\udc3b )) ; \ud835\udc4f\ud835\udc4f\ud835\udc5c\ud835\udc65 \u2190 bounding_box ( \u02c6 \ud835\udc7a ) ; 3: \ud835\udc5d\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61\ud835\udc60 \u2190 grid_within ( \ud835\udc4f\ud835\udc4f\ud835\udc5c\ud835\udc65 ) ; \ud835\udc50\ud835\udc5c\ud835\udc62\ud835\udc5b\ud835\udc61 \u2190 zeros (( \ud835\udc4a,\ud835\udc3b )) ; 4: \u25b7 Create grid points and initialize count 5: \u02c6 \ud835\udc7a \u210e \u2190 extract horizontal segments from \u02c6 \ud835\udc7a ; 6: for \ud835\udc94 \ud835\udc56 in \u02c6 \ud835\udc7a \u210e parallelly do \u25b7 Parallel computation 7: for \ud835\udc5d in \ud835\udc5d\ud835\udc5c\ud835\udc56\ud835\udc5b\ud835\udc61\ud835\udc60 parallelly do 8: \ud835\udc50\ud835\udc5f\ud835\udc5c\ud835\udc60\ud835\udc60 \u2190 check_cross ( \ud835\udc5d, \ud835\udc94 \ud835\udc56 ) ; 9: \ud835\udc50\ud835\udc5c\ud835\udc62\ud835\udc5b\ud835\udc61 [ \ud835\udc5d ]\u2190 \ud835\udc50\ud835\udc5c\ud835\udc62\ud835\udc5b\ud835\udc61 [ \ud835\udc5d ] + \ud835\udc50\ud835\udc5f\ud835\udc5c\ud835\udc60\ud835\udc60 \u25b7 Accumulate checks 10: __syncthreads() ; \u25b7 Synchronize threads 11: \ud835\udc5a\ud835\udc4e\ud835\udc60\ud835\udc58 \u2190 mod ( \ud835\udc50\ud835\udc5c\ud835\udc62\ud835\udc5b\ud835\udc61, 2 ) == 1; \u25b7 Apply even-odd rule 12: return \ud835\udc5a\ud835\udc4e\ud835\udc60\ud835\udc58 ; 13: function check_cross ( \ud835\udc5d , \ud835\udc7a ) 14: \ud835\udc63 1 \u2190 \ud835\udc5d - \ud835\udc60.\ud835\udc60\ud835\udc61\ud835\udc4e\ud835\udc5f\ud835\udc61 ; \ud835\udc63 2 \u2190 \ud835\udc5d - \ud835\udc60.\ud835\udc52\ud835\udc5b\ud835\udc51 ; \u25b7 Vectors from \ud835\udc5d to \ud835\udc7a 15: \ud835\udc50\ud835\udc5f\ud835\udc5c\ud835\udc60\ud835\udc60 \u2190 \ud835\udc63 1 .\ud835\udc65 \u00d7 \ud835\udc63 2 .\ud835\udc66 - \ud835\udc63 1 .\ud835\udc66 \u00d7 \ud835\udc63 2 .\ud835\udc65 ; \u25b7 Cross product 16: \ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc51 1 \u2190( \ud835\udc63 1 .\ud835\udc65 < 0 ) and ( \ud835\udc63 2 .\ud835\udc65 \u2265 0 ) and ( \ud835\udc50\ud835\udc5f\ud835\udc5c\ud835\udc60\ud835\udc60 < 0 ) ; 17: \ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc51 2 \u2190( \ud835\udc63 1 .\ud835\udc65 \u2265 0 ) and ( \ud835\udc63 2 .\ud835\udc65 < 0 ) and ( \ud835\udc50\ud835\udc5f\ud835\udc5c\ud835\udc60\ud835\udc60 > 0 ) ; 18: return \ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc51 1 or \ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc51 2; \u25b7 True if ray crosses the segment The forward pass of the rasterization process converts the edge parameters, represented as a tensor of shape [ \ud835\udc41 \ud835\udc60 , 2 , 2 ] , into a mask tensor of shape [ \ud835\udc4a,\ud835\udc3b ] , where \ud835\udc41 \ud835\udc60 is the number of segments, and \ud835\udc4a and \ud835\udc3b are the width and height of the mask, respectively. In contrast, the backward pass requires transforming the gradients from the lithography model, which are of shape [ \ud835\udc4a,\ud835\udc3b ] , into gradients for the segments, represented as a tensor of shape [ \ud835\udc41 \ud835\udc60 , 2 , 2 ] . To accomplish this, the algorithm first computes the gradient of the mask tensor with respect to the edge parameters using automatic differentiation. Let \ud835\udf15\ud835\udc3f \ud835\udf15 \ud835\udc74 be the gradient of the loss function \ud835\udc3f with respect to the mask tensor \ud835\udc74 , obtained from the lithography model. The goal is to calculate \ud835\udf15\ud835\udc3f \ud835\udf15 \u02c6 \ud835\udc7a , the gradient of the loss function with respect to the edge parameters \u02c6 \ud835\udc7a . Applying the chain rule, we have:  The term \ud835\udf15 \ud835\udc74 \ud835\udf15 \u02c6 \ud835\udc7a represents the Jacobian matrix of the rasterization process, which maps changes in edge parameters to changes in the mask tensor. This Jacobian matrix is computed efficiently using Algorithm 4. In our implementation, as in the Interpolate function in line 10, we choose the gradient at the midpoint of each segment as the representative gradient for that segment, as stated in eq. (10). Once the Jacobian matrix is obtained, the gradient of the loss function with respect to the edge parameters can be calculated by multiplying the gradient of the loss function with respect to the mask tensor, \ud835\udf15\ud835\udc3f \ud835\udf15 \ud835\udc74 , by the Jacobian matrix \ud835\udf15 \ud835\udc74 \ud835\udf15 \ud835\udc7a . This operation effectively backpropagates the gradients from the lithography model to the edge parameters, enabling the optimization of the edge-based OPC problem using gradient-based methods. MRC aware optimization . One of the significant advantages of EBOPC is the ability to obtain boundary information in real-time during the optimization process, including edges, line ends, jogs, notches, and other features. This is not possible with PBOPC. While Algorithm 4 Transform Mask to Edge Gradients with Velocity 1: Input: Gradient matrix \ud835\udf15\ud835\udc3f \ud835\udf15 \ud835\udc74 of size \ud835\udc4a \u00d7 \ud835\udc3b ; 2: Input: Edge segments \u02c6 \ud835\udc7a of shape [ \ud835\udc41 \ud835\udc60 , 2 , 2 ] , where each edge is defined by two points: start ( \ud835\udc65 1 , \ud835\udc66 1 ) and end ( \ud835\udc65 2 , \ud835\udc66 2 ) ; 3: Input: Pre-defined velocity list \ud835\udc7d for each segment \ud835\udc94 \ud835\udc56 ; 4: Output: Edge gradients \ud835\udf15\ud835\udc3f \ud835\udf15 \u02c6 \ud835\udc7a of shape [ \ud835\udc41 \ud835\udc60 , 2 , 2 ] ; 5: function ComputeEdgeGradients( \ud835\udf15\ud835\udc3f \ud835\udf15 , \u02c6 \ud835\udc7a , \ud835\udc7d  level set-based methods can control boundaries globally, they lack the ability to fine-tune specific locations. DiffOPC generates MRCclean optimization results by explicitly controlling manufacturability through the velocity term \ud835\udc97 \ud835\udc56 during optimization. Before the experiment, we divide the MRC edges into corresponding check pairs. We classify mask rules into two categories: spacing checks, such as minimum spacing, end of line spacing, jog to jog spacing, and special notch spacing, and width checks, such as minimum width check. Let \ud835\udf39 denote the distance vector between check pairs. The projection of \ud835\udf39 along the y-direction is given by proj \ud835\udc66 \ud835\udf39 = ( \ud835\udf39 \u00b7 \ud835\udc8b ) \ud835\udc8b , where \ud835\udc8b is the unit vector in the y-direction. The projection along the x-direction is similarly defined. We achieve MRC-aware optimization by controlling the velocity \ud835\udc97 \ud835\udc56 as follows: \ud835\udc97 \u2032 \ud835\udc56 = \ud835\udc97 \ud835\udc56 \u00b7 \ud835\udf0f ( \ud835\udf39 ) where \ud835\udf0f ( \ud835\udf39 ) is a function related to \ud835\udf39 , defined as: \ud835\udf0f ( \ud835\udf39 ) = \ud835\udf0e ( \ud835\udefd ( proj \ud835\udf39 -\ud835\udc37 )) . Here, \ud835\udc37 is a constant related to the mask rule, and proj is the projection operator in either \ud835\udc65 or \ud835\udc66 direction, \ud835\udefd is the steepness of sigmoid function \ud835\udf0e (\u00b7) . For the spacing and width check, when the distance proj \ud835\udf39 is smaller than \ud835\udc37 , the velocity term rapidly decays to 0, preventing further reduction in the distance. When proj \ud835\udf39 is greater than \ud835\udc37 , \ud835\udf0f ( \ud835\udf39 ) returns to 1, allowing normal optimization to proceed without interference. By controlling the velocity term based on the distance between check pairs and mask rule constants, DiffOPC effectively incorporates MRC constraints into the optimization process. Lithography simulations . After obtaining the mask \ud835\udc74 through the rasterization process, we can utilize forward lithography model in eq. (1) to calculate the aerial intensity \ud835\udc70 . To obtain a continuousvalued printed image \ud835\udc81 , we employ the sigmoid function \ud835\udf0e (\u00b7) to scale eq. (2) into a continuous space: \ud835\udc81 = \ud835\udf0e ( \ud835\udefc ( \ud835\udc70 -\ud835\udc3c \ud835\udc61\u210e )) , where \ud835\udefc is the steepness of \ud835\udf0e (\u00b7) , and \ud835\udc3c \ud835\udc61\u210e is the threshold intensity value. Objective function . We employ a combination of three loss functions: \ud835\udc3f 2 loss, PVB loss, and EPE loss. The \ud835\udc3f 2 loss and PVB loss are defined as:  For the EPE loss, measured points are sampled along the boundary of the target patterns, which includes a set of samples on horizontal edges (HS) and a set of samples on vertical edges (VS). To map the EPE loss to the continuous-value domain, we utilize the sigmoid function. First, we calculate the distance between \ud835\udc81 \ud835\udc5b\ud835\udc5c\ud835\udc5a and the target pattern \ud835\udc7b at the sampled points in VS and HS:  \uf8f3 where \ud835\udc6b \ud835\udc56\ud835\udc58 and \ud835\udc6b \ud835\udc58\ud835\udc57 represent the distances between the printed image and the target pattern at the corresponding locations, and \ud835\udc61\u210e \ud835\udc52\ud835\udc5d\ud835\udc52 is a threshold value that determines the neighborhood size for the distance calculation. \ud835\udc6b is calculated by \ud835\udc6b = ( \ud835\udc81 \ud835\udc5b\ud835\udc5c\ud835\udc5a -\ud835\udc7b ) 2 . Next, we apply the sigmoid function to the calculated distances to obtain the continuous-valued EPE loss:  where \ud835\udefe is a scaling factor that controls the steepness of the sigmoid function. The total loss function is then defined as a weighted sum of the three individual loss components:  where \ud835\udc64 1 , \ud835\udc64 2 , and \ud835\udc64 3 are the weights assigned to each loss component. The use of the sigmoid function in the EPE loss allows for a smooth integration of the EPE into the continuous-value domain, enabling efficient gradient-based optimization. For the backward pass, the gradients of the total loss function with respect to the segment \ud835\udc94 \ud835\udc56 are calculated using the chain rule:  where \u230a\u00b7\u230b is floor operation and  For the \ud835\udc3f 2 loss, the gradient is calculated as:  where the \ud835\udc6f \u2032 is the flipped kernel set \ud835\udc6f , and the \ud835\udc6f \u2217 is the conjugate of \ud835\udc6f . Similarly, for the PVB loss, the gradient is calculated as:  The derivation of \ud835\udf15 \ud835\udc81 \ud835\udc5a\ud835\udc56\ud835\udc5b \ud835\udf15 \ud835\udc74 and \ud835\udf15 \ud835\udc81 \ud835\udc5a\ud835\udc4e\ud835\udc65 \ud835\udf15 \ud835\udc74 is similar to that of \ud835\udf15 \ud835\udc81 \ud835\udf15 \ud835\udc74 in eq. (12). For the EPE loss, the gradient is calculated by summarizing the gradients at the measure points ( \ud835\udc56, \ud835\udc57 ) :  where  and  with \ud835\udf15 \ud835\udc6b \ud835\udc56 \ud835\udc57 \ud835\udf15 \ud835\udc74 calculated as:  The detailed derivation of \ud835\udf15 \ud835\udc81 \ud835\udc56 \ud835\udc57 \ud835\udf15 \ud835\udc74 can be found in eq. (12). SRAF generation . SRAFs in lithography enhance sub-resolution element printability by modifying diffraction and interference patterns in photoresist, leading to widened process windows, improved resolution, depth of focus, and reduced line edge roughness. The primary distinction among prior works lies in their handling of SRAFs. In level set-based ILT methods, the implicit function \ud835\udf19 is tied to the primary pattern, preventing the generation of SRAFs during optimization. Conversely, pixel-based ILT methods like [14] can generate SRAFs during mask optimization due to their higher degree of freedom. However, pixel-based ILT cannot impose rule-based constraints on SRAFs, causing their growth to rely solely on gradients. This improves printability but can increase MRC violations and hotspots. To address these issues, we propose a two-stage SRAF optimization algorithm. The first stage involves efficient SRAF seed generation using gradient contours, and the second stage employs a differentiable edge-based optimization for the generated SRAFs. This approach effectively avoids the problems of missing SRAFs in level set-based methods and violations in pixel-based SRAFs. Gradient Contour-based SRAF Seed Generation: During the optimization process, we observe that certain regions near the main pattern exhibit gradients that flip the mask value, changing it from 0 to 1. However, since the edge-based segments do not include these regions, they remain at 0. Combining continuous transmission mask (CTM) [19] theory and the results from [14], we conclude that these gradients can contribute to SRAF generation. As depicted in Figure 4(a), the contour line of the mask gradient map shows the position of the extreme gradient points and indicates the gradient drop rate. The position of the extreme points can guide SRAF placement, while the gradient information can guide the subsequent SRAF cleanup process. The implementation involves extending the existing mask by a certain distance related to the mask rules to create a SRAF forbidden region. As illustrated in Figure 4(a), gradient contour lines are drawn outside the SRAF forbidden region. The extreme points and the corresponding contour aspect ratios are used as the center of the SRAF seeds. The initial SRAF minimum width/length is set to a fixed value, and the shape and placement of the SRAF are determined based on the aspect ratio. This step does not require precise SRAF generation; it only needs to determine the initial position and aspect ratio. Differentiable Edge-based SRAF Optimization: In the second stage, the generated seeds illustrated in Figure 4(a) are processed using the Algorithm 1 segmentation method to create new segments, which are then added to the main optimization process. The SRAFs are optimized together with the mask. To accelerate the SRAF optimization process, we adopt a multi-resolution strategy similar to [14]. SRAF seeds are generated at low resolution, and then the seeds and mask are refined in high resolution for more precise optimization. Sample results are shown in Figure 4(b). The proposed two-stage SRAF optimization algorithm enables the generation of SRAFs that Figure 4: DiffOPC SRAF insertion and optimization. SRAF Forbidden Region Initial SRAF Seeds Gradient map & Initial SRAFs (a) Final mask and SRAFs (b) enhance printability while minimizing MRC violations. We conducted a comprehensive comparison of DiffOPC, ILTs, and EBOPC in Table 1.", "4 Experimental Results": "In our implementation, we set \ud835\udc41 \ud835\udc58 = 24 for the SOCS approximation. The parameters \ud835\udefc = \ud835\udefd = \ud835\udefe = 50, \ud835\udc64 1 = 1 , \ud835\udc64 2 = 0 . 9 , \ud835\udc64 3 = 100. The default segment length is set to 80 nm. The lithography recipe is provided by the ICCAD 2013 [18] contest evaluation package. The mask fracturing tool is implemented based on a GPU-accelerated rectangular decomposition algorithm [20]. The entire framework is written in PyTorch and tested on an Nvidia RTX 3090 GPU. The mask rule check (MRC) is performed using KLayout. DiffOPC is tested on both metal layer and via layer designs. The metal layer evaluation designs for 32 nm M1 layout designs are from [18], and larger layouts from [14] for the same process node. The via layer evaluation designs are adopted from [21], containing ten 2 \ud835\udf07\ud835\udc5a \u00d7 2 \ud835\udf07\ud835\udc5a clips with different numbers of 70 \ud835\udc5b\ud835\udc5a \u00d7 70 \ud835\udc5b\ud835\udc5a via patterns. SRAF seeds are generated in a low resolution of 512 \u00d7 512 and optimized at a resolution of 2048 \u00d7 2048.", "4.1 Experimental Results on Metal Layer": "Comparison with ILT . Table 2 compares the performance of our proposed DiffOPC framework with state-of-the-art (SOTA) ILT approaches, namely NeuralILT [10] and MultiILT [14], on the ICCAD13 benchmark. The comparison is based on key metrics such as L2 ( \ud835\udc5b\ud835\udc5a 2 ), PVB ( \ud835\udc5b\ud835\udc5a 2 ), EPE ( \ud835\udc5b\ud835\udc5a ), number of shots, and turnaround time (TAT, seconds). DiffOPC demonstrates superior performance, achieving an average L2 of 28280, which is 1 . 5% and 27% lower than MultiILT and NeuralILT, respectively. Attributed to the utilization of EPE loss introduced in eq. (8), DiffOPC achieves lower EPE, with an average of 2.2, representing a 19% and 71% reduction compared to MultiILT and NeuralILT. Moreover, DiffOPC requires significantly fewer shots per case, with an average of 106.1 shots, representing a 62% and 81% reduction compared to MultiILT and NeuralILT, which translates to lower manufacturing costs. These results highlight the effectiveness of DiffOPC in generating mask patterns with improved printability while maintaining better manufacturability compared to ILT methods. As mentioned in Section 1 and illustrated in Figure 5, ILT approaches are prone to introducing MRC violations, which do not meet industrial requirements. We also present the post-MRC results for MultiILT in the \"Post-MRC\" column, where the TAT includes both the ILT runtime and the post-processing time for cleaning mask rule violations. It is noteworthy that the post-MRC stage for MultiILT leads to a significant performance degradation, evident from the Table 1: DiffOPC compared with ILTs and EBOPC. Table 2: Comparison with ILT methods on ICCAD13 dataset. Table 3: Comparison with ILT methods on larger dataset. increased average values of L2, PVB, EPE, and TAT compared to the original MultiILT results. The results of DiffOPC outperform all metrics of ILT in the post-MRC stage. This indicates that ILT-generated patterns may not optimize as desired and could introduce more violations, prolonging processing times due to MRC. In contrast, DiffOPC maintains superior performance without extra post-processing steps, highlighting its robustness and efficiency in generating high-quality, manufacturable mask patterns meeting industrial standards. Large dataset . To further validate the robustness and scalability of our proposed DiffOPC framework, we conduct experiments on a larger dataset and compare its performance with SOTA methods in Table 3. The results demonstrate that DiffOPC consistently outperforms the other methods, highlighting its effectiveness in handling complex and diverse patterns. DiffOPC achieves an average L2 of 50684, which is 4 . 7% and 28 . 2% lower than MultiILT and NeuralILT, Figure 5: MRC violations across methods and datasets NeuralILT [10] MultiILT [14] DiffOPC 0 10 20 30 8 . 9 11 . 7 0 18 . 6 25 . 4 0 4 22 0 Avg. MRC violations ICCAD13 Large Dataset Via respectively. Moreover, it exhibits superior performance in terms of EPE, with an average EPE of 2.7, representing a 23% and 75% reduction over MultiILT and NeuralILT. Notably, DiffOPC requires significantly fewer shots per case, with an average of 218.5 shots, which is 63% and 64% lower than MultiILT and NeuralILT. As observed in the previous experiment, the post-MRC stage for MultiILT leads to a deterioration in performance. This further underscores Table 4: Comparison with traditional MEEF EBOPC on ICCAD 2013 benchmark. the limitations of ILT-based methods in generating manufacturable patterns that comply with industrial requirements. Comparison with MEEF-based EBOPC on ICCAD2013 benchmark . To provide a fair comparison between proposed DiffOPC and the traditional MEEF-based EBOPC method [2], we evaluate both approaches on GPU without the inclusion of SRAFs. The results in Table 4 demonstrate that DiffOPC consistently outperforms MEEFEBOPC. On average, DiffOPC achieves an L2 of 30579.6, which is 6 . 5% lower than MEEF-EBOPC. Similarly, DiffOPC exhibits lower average PVB, EPE, and TAT with 3 . 9%, 58%, and 59% respectively. These findings highlight the superior printability of the mask patterns generated by DiffOPC compared to the traditional MEEF-EBOPC. It is worth noting that MEEF-EBOPC struggles to handle complex patterns. The limitation is evident from the results presented in Table 4, where MEEF-EBOPC exhibits particularly high EPE values for complex test cases such as c3 (EPE = 59) compared to simpler cases like c10 (EPE = 0). In contrast, DiffOPC demonstrates robust performance across all test cases while maintaining a competitive shot count compared to MEEF-EBOPC.", "4.2 Experimental Results on Via Layer": "In Table 5, we evaluate the performance of DiffOPC on the via layer against SOTA ILT and EBOPC methods, including a commercial tool, Calibre [22]. Comparison with ILT methods . DiffOPC outperforms ILT methods in terms of L2 and EPE, achieving the lowest values of 3957 and 13.5, respectively. Notably, DiffOPC achieves these improvements while maintaining a significantly lower shot count (9.7 shots on average), which is approximately 1/20th of the shot count required by [14] (225 shots). Comparison with EBOPC methods . Among the EBOPC methods, DiffOPC demonstrates superior performance, achieving the lowest L2 (3957), EPE (13.5), and TAT (2.8 seconds) compared to the commercial Calibre tool and the MEEF-based approach.", "4.3 Ablation Study": "Efficiency of CUDA-accelerated ray casting rasterization . We compare the runtime of our CUDA-accelerated ray casting rasterization approach with the traditional EBOPC method based on indexing and the find-then-move strategy. For a clip size of 2 \ud835\udf07\ud835\udc5a \u00d7 2 \ud835\udf07\ud835\udc5a , a single Table 5: Result comparison on via layer. \u2217 EPE: EPE threshold set to 1 \ud835\udc5b\ud835\udc5a . forward rasterization step in DiffOPC takes 16 milliseconds, while the traditional method requires 196 milliseconds, representing a 12 . 3 \u00d7 speedup achieved by our CUDA ray casting implementation. Ablation Study on Segment Length . Segment length in DiffOPC also impacts optimization performance. In an ablation study using the ICCAD 2013 benchmark, segment lengths of 60 \ud835\udc5b\ud835\udc5a , 80 \ud835\udc5b\ud835\udc5a , and 100 \ud835\udc5b\ud835\udc5a resulted in EPE of 2.6, 2.2, and 2.8, with runtimes of 8.95, 8.42, and 6.92 seconds. This shows that optimal segment length selection can enhance OPC performance. Future work could explore adaptive segment length strategies, adjusting lengths based on pattern complexity and optimization progress for better performance.", "4.4 Summary of Experimental Results": "The experimental results on both metal and via layers demonstrate DiffOPC's superiority over SOTA ILT, post-MRC ILT and EBOPC methods in terms of printability, manufacturability, and cost-efficiency. On metal layers, DiffOPC consistently outperforms SOTA ILT methods, exhibiting reduced EPE and shot count, along with lower manufacturing costs, while maintaining competitive TAT. The proposed framework eliminates the need for additional postprocessing to address MRC violations, making it an efficient and reliable edge-based OPC solution for large-scale OPC tasks. On via layers, DiffOPC achieves the best performance in L2, EPE, and TAT among EBOPC methods, surpassing even the commercial Calibre tool. Compared to ILT methods, DiffOPC shows the lowest L2 and EPE values while significantly reducing the number of shots, leading to lower manufacturing costs and improved throughput. These results highlight DiffOPC's enhanced printability, pattern fidelity, and computational efficiency.", "5 Conclusion": "We propose DiffOPC, a differentiable edge-based OPC framework that bridges the gap between the superior manufacturability of EBOPC and the enhanced performance of ILT. By leveraging a CUDA-accelerated ray casting algorithm, DiffOPC enables a differentiable rasterization process that allows gradients to propagate through the lithography model, facilitating the efficient optimization of edge segment positions. This innovative approach results in significant improvements in key metrics such as L2 and EPE while maintaining an exceptionally low shot count, leading to substantially reduced manufacturing costs. Moreover, DiffOPC incorporates an efficient SRAF generation method, which seamlessly integrates SRAF with the main pattern optimization for a holistic and effective OPC solution. Experimental results highlight DiffOPC's superior performance and efficiency over SOTA EBOPC and ILT methods, making it a promising advancement in semiconductor technologies.", "References": "[1] O. W. Otto, J. G. Garofalo, K. K. Low et al. , 'Automated optical proximity correction: a rules-based approach,' in Proc. SPIE , 1994, pp. 278-293. [2] J. Lei, L. Hong, G. Lippincott, and J. Word, 'Model-based opc using the meef matrix ii, ' in Optical Microlithography XXVII , vol. 9052. SPIE, 2014, pp. 170-178. [3] J.-R. Gao, X. Xu, B. Yu, and D. Z. Pan, 'MOSAIC: Mask optimizing solution with process window aware inverse correction,' in Proc. DAC , 2014, pp. 52:1-52:6. [4] T. E. Brist and J. A. Torres, 'Model-assisted placement of subresolution assist features: Experimental results,' in Proc. SPIE , vol. 5042, 2003, pp. 99-106. [5] X. Xu, Y. Lin, M. Li, T. Matsunawa, S. Nojima, C. Kodama, T. Kotani, and D. Z. Pan, 'Subresolution assist feature generation with supervised data learning,' IEEE TCAD , vol. 37, no. 6, pp. 1225-1236, 2017. [6] M. B. Alawieh, Y. Lin, Z. Zhang, M. Li, Q. Huang, and D. Z. Pan, 'GAN-SRAF: Sub-resolution assist feature generation using conditional generative adversarial networks,' in Proc. DAC , 2019, pp. 149:1-149:6. [7] H. Geng, W. Zhong, H. Yang, Y. Ma, J. Mitra, and B. Yu, 'Sraf insertion via supervised dictionary learning,' IEEE TCAD , 2020. [8] H. Yang, S. Li, Y. Ma, B. Yu, and E. F. Young, 'GAN-OPC: Mask optimization with lithography-guided generative adversarial nets,' in Proc. DAC , 2018, pp. 131:1131:6. [9] G. Chen, W. Chen, Y. Ma, H. Yang, and B. Yu, 'DAMO: Deep agile mask optimization for full chip scale, ' in Proc. ICCAD , 2020. [10] B. Jiang, L. Liu, Y. Ma, H. Zhang, E. F. Y. Young, and B. Yu, 'Neural-ILT: Migrating ILT to nerual networks for mask printability and complexity co-optimizaton',' in Proc. ICCAD , 2020. [11] W. Zhao, X. Yao, Z. Yu, G. Chen, Y. Ma, B. Yu, and M. D. F. Wong, 'AdaOPC: A selfadaptive mask optimization framework for real design patterns,' in Proc. ICCAD , 2022. [12] B. Zhu, S. Zheng, Z. Yu, G. Chen, Y. Ma, F. Yang, B. Yu, and M. D. F. Wong, 'L2O-ILT: Learning to optimize inverse lithography techniques,' IEEE TCAD , vol. 43, no. 3, pp. 944-955, 2024. [13] X. Zhang, S. Zheng, G. Chen, B. Zhu, H. Xu, and B. Yu, 'Fracturing-aware curvilinear ilt via circular e-beam mask writer,' 2024. [14] S. Sun, F. Yang, B. Yu, L. Shang, and X. Zeng, 'Efficient ILT via multi-level lithography simulation,' in Proc. DAC , 2023. [15] Z. Yu, G. Chen, Y. Ma, and B. Yu, 'A GPU-enabled level set method for mask optimization,' in Proc. DATE , 2021. [16] G. Chen, Z. Yu, H. Liu, Y. Ma, and B. Yu, 'DevelSet: Deep neural level set for instant mask optimization,' in Proc. ICCAD , 2021. [17] W. Lv, S. Liu, Q. Xia, X. Wu, Y. Shen, and E. Y. Lam, 'Level-set-based inverse lithography for mask synthesis using the conjugate gradient and an optimal time step,' Journal of Vacuum Science & Technology B, Nanotechnology and Microelectronics: Materials, Processing, Measurement, and Phenomena , vol. 31, no. 4, p. 041605, 2013. [18] S. Banerjee, Z. Li, and S. R. Nassif, 'ICCAD-2013 CAD contest in mask optimization and benchmark suite,' in Proc. ICCAD , 2013, pp. 271-274. [19] Z. Yu, P. Liao, Y. Ma, B. Yu, and M. D. F. Wong, 'CTM-SRAF: Continuous transmission mask-based constraint-aware subresolution assist feature generation,' IEEE TCAD , vol. 42, no. 10, pp. 3402-3411, 2023. [20] J. F. Chango, C. A. Navarro, and M. A. Gonz\u00e1lez-Montenegro, 'Gpu-accelerated rectangular decomposition for sound propagation modeling in 2d,' in 2019 38th International Conference of the Chilean Computer Science Society (SCCC) , 2019. [21] S. Zheng, H. Yang, B. Zhu, B. Yu, and M. D. Wong, 'LithoBench: Benchmarking AI computational lithography for semiconductor manufacturing,' in Proc. NeurIPS , 2023. [22] 'Calibre Design Solutions, Siemens,' https://eda.sw.siemens.com/en-US/ic/calibredesign/."}
