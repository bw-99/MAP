{
  "Differentiable Edge-based OPC": "Guojin Chen ∗ CUHK & UT Austin & NVIDIA Haoyu Yang NVIDIA Corporation Haoxing Ren NVIDIA Corporation Bei Yu Chinese University of Hong Kong David Z. Pan University of Texas at Austin",
  "Abstract": "Optical proximity correction (OPC) is crucial for pushing the boundaries of semiconductor manufacturing and enabling the continued scaling of integrated circuits. While pixel-based OPC, termed as inverse lithography technology (ILT), has gained research interest due to its flexibility and precision. Its complexity and intricate features can lead to challenges in mask writing, increased defects, and higher costs, hence hindering widespread industrial adoption. In this paper, we propose DiffOPC, a differentiable OPC framework that enjoys the virtue of both edge-based OPC and ILT. By employing a mask rule-aware gradient-based optimization approach, DiffOPC efficiently guides mask edge segment movement during mask optimization, minimizing wafer error by propagating true gradients from the cost function back to the mask edges. Our approach achieves lower edge placement error while reducing manufacturing cost by half compared to state-of-the-art OPC techniques, bridging the gap between the high accuracy of pixel-based OPC and the practicality required for industrial adoption, thus offering a promising solution for advanced semiconductor manufacturing.",
  "1 Introduction": "Optical proximity correction (OPC) is a critical technique in computational lithography that compensates for the optical proximity effect (OPE) caused by interference and diffraction in the lithographic imaging process. As integrated circuit technology nodes advance to 90 nm and below, simple resolution enhancement techniques (RET) can no longer meet the requirements for high-resolution and high-fidelity lithographic imaging. To address this challenge, OPC has evolved from rule-based OPC (RBOPC) to model-based OPC (MBOPC). RBOPC relies on a pre-established mask correction rule table, which is derived from engineering experience or fitted experimental and simulation data [1]. Although RBOPC is computationally fast and produces relatively simple optimized mask patterns, it can only compensate for local OPE and cannot find a globally optimal solution for the mask optimization problem. MBOPC,onthe other hand, is based on the physical model of lithographic imaging and employs numerical optimization algorithms to modify the mask pattern. As depicted in Figure 1, MBOPC can be further classified into edge-based OPC (EBOPC) and pixel-based OPC (PBOPC). EBOPC divides the edge contour of the mask pattern into several segments and iteratively optimizes the position of each segment along its normal direction to compensate for lithographic imaging errors [2]. However, current EBOPC methods, such as the Mask Error Enhancement Factor (MEEF) matrix algorithm [2], have limitations in ∗ Work accomplished during internship at NVIDIA. PBOPC (ILT) SRAFs MRC violations Pxiel-based ILT Level set-based ILT MRC violations EBOPC Traditional MEEF-based EBOPC DiffOPC (Ours) SRAFs EPE: 25 EPE: 51 MRC clean MRC clean EPE: 59 EPE: 19 # Figure 1: Model-based OPC includes pixel-based OPC (ILT) and edge-based OPC (EBOPC). While ILT masks face manufacturability issues requiring significant post-processing, EBOPC masks are manufacturable but have performance limitations. DiffOPC combines the advantages of both approaches, enhancing manufacturability and performance. computational efficiency and accuracy. The algorithm is computationally intensive, scaling poorly with the size and complexity of IC layouts. Its foundational linearity assumptions often fail to account for the nonlinearities prevalent in advanced lithography, leading to subpar performance in complex cases where edge interactions are significant and not adequately captured. The MEEF matrix, further burdened by potential ill-conditioning and a static representation throughout optimization, may not adapt to dynamic process variations, thus trading off accuracy for computational manageability. PBOPC, also known as inverse lithography technology (ILT), pushes the boundaries of mask optimization by rasterizing the mask layout into a pixel array and optimizing the transmission of each mask pixel by gradient descent [3]. This approach allows for freeform curved edge contours and the addition of sub-resolution assist features (SRAF) [4-7] to improve imaging performance. ILT algorithms can be categorized into two classes based on their mask representation: end-to-end pixel-based methods for prediction [814] or acceleration, and implicit function-based methods using level sets to enhance acceleration and manufacturability [15-17]. Among the SOTA ILT methods, MultiILT [14] adopts a multi-level resolution strategy for better OPC performance and manufacturability. Despite the advancements in ILT algorithms, they still face several challenges that hinder their widespread adoption in the semiconductor industry. As illustrated in Figure 1, the pixelated mask patterns generated by ILT are often complex and difficult to manufacture, requiring costly rectangular decomposition into manufacturable Manhattan polygons. Further, the application of decomposition and mask rule check (MRC) methods to regularize the mask patterns may lead to a decline in OPC performance and introduce new hotspots, negating the performance advantages of ILT. Moreover, ILT algorithms tend to over-optimize shape corners because the simulated line-ends will never match the Manhattan rectangles at the line-end. Nevertheless, these challenges have been largely overlooked, preventing ILT's large-scale adoption in the industry, which tends to favor EBOPC due to lower manufacturing costs. To bridge the gap between the manufacturability of EBOPC and the performance of ILT, we propose DiffOPC, a differentiable edgebased OPC method that leverages gradient information to optimize edge placement error (EPE) while considering process variation. By relaxing discrete edge movements and embedding mask rule constraints into the gradient computation, DiffOPC combines EBOPC's high manufacturability with ILT's performance. Additionally, it ensures MRC-clean results, allowing the optimized mask patterns to be directly used for mask fabrication without additional postprocessing. DiffOPC introduces efficient solutions to enhance the edge-based OPC process. In the forward algorithm, a flexible segmentation approach and CUDA-accelerated ray casting expedite differentiable layout rasterization, while a novel SRAF seed generation algorithm optimizes SRAF placement. In the backward algorithm, DiffOPC computes lithography gradients for edge movements using a chain-rule approach and incorporates mask rule constraints to ensure manufacturability. By combining these improvements, DiffOPC achieves superior OPC performance with high manufacturability. In summary, our main contributions are as follows: We propose DiffOPC, a differentiable edge-based OPC framework that integrates EPE loss and leverages MRC-aware gradi- · ents for mask optimization. · A flexible segmentation approach and a CUDA-accelerated ray casting algorithm are introduced to expedite layout rasterization. · DiffOPC efficiently computes edge segment gradients using a chain-rule approach to ensure manufacturability. · A novel SRAF seed generation algorithm leveraging gradients for optimal SRAF placement and further optimization. · DiffOPC bridges the gap between EBOPC's manufacturability and ILT's performance, offering a promising solution for highquality and efficient OPC corrections. The experimental results show that DiffOPC reduces EBOPC's EPE by half, and even achieves lower EPE than ILT while maintaining manufacturing costs that are half of ILT's.",
  "2 Preliminaries": "",
  "2.1 Forward Lithography Model": "We employ the sum of coherent systems (SOCS) decomposition of a 193 𝑛𝑚 wavelength system as the optical model for lithography modeling, following the same approach as [18]. The aerial image intensity 𝑰 is represented by the convolution of the mask 𝑴 and a set of optical kernels 𝑯 . The 𝑁 𝑡ℎ 𝑘 order approximation to the partially coherent system is obtained using eq. (1):  where ⊗ denotes the convolution operation, ℎ 𝑖 is the 𝑖 𝑡ℎ kernel of 𝑯 , 𝜎 𝑖 is the corresponding weight of the coherent system, and ( 𝑥,𝑦 ) is the index notation of the matrix. 𝑴 ( 𝑥,𝑦 ) represents the pixel value at the point ( 𝑥,𝑦 ) of the mask image 𝑴 . A constant threshold resist model (CTR) is applied to convert the aerial image intensity 𝑰 to the printed resist image 𝒁 .  where 𝐼 𝑡ℎ is the intensity threshold.",
  "2.2 Evaluation Metrics": "In this paper, we use squared 𝐿 2 error, process variation band (PVB) and edge placement error (EPE) as three typical metrics to evaluate OPC performance. Moreover, the mask fracturing shot count (#shot) proposed in [10] is also applied in this work to evaluate mask complexity and manufacturability. Squared 𝐿 2 error 𝐿 2 measures the difference between the nominal resist image 𝒁 𝑛𝑜𝑚 and the target image 𝑻 , defined as:  PVB evaluates the robustness of the mask against different process conditions. A smaller PVB indicates a more robust mask. PVB ( 𝒁 𝑚𝑎𝑥 , 𝒁 𝑚𝑖𝑛 ) = ∥ 𝒁 𝑚𝑎𝑥 -𝒁 𝑚𝑖𝑛 ∥ 2 2 . Edge placement error The Edge Placement Error (EPE) [18] quantifies the geometric distortion of the resist image. Shot count #Shot [10] is the number of decomposed rectangles that replicate the original mask exactly.",
  "2.3 Problem Formulation": "Given a target design 𝑻 , we aim to find a set of boundary segments 𝑺 = { 𝒔 1 , 𝒔 2 , . . . , 𝒔 𝑖 } , and a binary mask 𝑴 ∈ { 0 , 1 } 𝑚 × 𝑛 formed by the matrix inside the boundary composed of these segments 𝑺 , where 𝑚 and 𝑛 are the dimensions of 𝑻 . The objective is to determine the corresponding printed image 𝒁 that minimizes the weighted sum of EPE, 𝐿 2 , PVB, and #shots.",
  "3 DiffOPC Algorithm": "To enable the application of differentiable EBOPC to arbitrary layout patterns while utilizing minimal additional information, such as the EPE measure points, several challenges need to be addressed: 1) Ensuring a more flexible movement of segments in Manhattan geometries, particularly at pattern corners. 2) Mapping discrete edge movements to a continuous space for efficient updates. 3) Maintaining compatibility with the chain rule for differentiation during the rasterization process, which converts edge parameters to pixel binary masks. In this section, we introduce the movement and update mechanisms for edge segments, describe a CUDA-accelerated ray casting algorithm for rasterization, demonstrate how lithography gradients can be utilized to update the movement of edge segments, and introduce an algorithm for SRAF placement.",
  "3.1 Edge Segmentation and Movement": "We present Algorithm 1 for segmenting target polygon edges into smaller segments of a pre-defined length. The algorithm returns a minimal set of segments, denoted as 𝑺 ∈ R 𝑁 𝑠 × 2 × 2 , where R represents the real number domain and 𝑁 𝑠 is the number of segments. Each segment 𝒔 𝑖 ∈ 𝑺 is represented by its starting and ending coordinates in vector form: [[ 𝑥 1 , 𝑦 1 ] , [ 𝑥 2 , 𝑦 2 ]] . These segments 𝑺 serve Figure 2: DiffOPC: differentiable edge-based OPC framework. Initial Segments Optimized Segments Mask gradient Mask Resist Initialize Update STE Corner Merge Rasterization Forward Lithography Lithography Gradient Calculate Loss Gradient Interpolation GDS OASIS Layout Corner Segments Horizontal & Vertical Segments DiffOPC Forward DiffOPC Backward Segment Gradients & Velocities as the optimization parameters for DiffOPC, providing increased flexibility in handling corner edges compared to traditional EBOPC methods which only optimize the edge movement distance. As illustrated in Figure 2, each segment 𝒔 𝑖 is associated with a direction vector 𝒅 𝑖 ∈ D , which enables better reconstruction of segments back into polygons and determines the direction of movement. Furthermore, the algorithm ensures compliance with the MRC by merging excessively short segments when necessary.",
  "Algorithm 1 Edge Parameter Initialization.": "Input: 𝑝𝑜𝑙𝑦𝑔𝑜𝑛𝑠 : mask polygon coordinates; 𝑠𝑒𝑔 _ 𝑙𝑒𝑛𝑔𝑡ℎ : segment length. Output: 𝑎𝑙𝑙 _ 𝑠𝑒𝑔𝑚𝑒𝑛𝑡𝑠 : List of polygons with segmented lines & directions; 1: for 𝑝𝑜𝑙𝑦 in 𝑝𝑜𝑙𝑦𝑔𝑜𝑛𝑠 do 2: for 𝑒𝑑𝑔𝑒 in 𝑝𝑜𝑙𝑦 do 3: 𝑚𝑖𝑑𝑝𝑜𝑖𝑛𝑡 ← Calculate the midpoint of the edge; 4: 𝑙𝑒𝑛𝑔𝑡ℎ ← Calculate the length of the edge; 5: 𝑑𝑖𝑟𝑒𝑐𝑡𝑖𝑜𝑛 ← Get edge direction vector (horizontal or vertical); 6: if 𝑙𝑒𝑛𝑔𝑡ℎ ≤ 2 ∗ 𝑠𝑒𝑔 _ 𝑙𝑒𝑛𝑔𝑡ℎ then 7: Create two segments from 𝑚𝑖𝑑𝑝𝑜𝑖𝑛𝑡 ; 8: else 9: 𝑠𝑡𝑒𝑝𝑠 ← Calculate the number of steps based on edge 𝑙𝑒𝑛𝑔𝑡ℎ and 𝑠𝑒𝑔 _ 𝑙𝑒𝑛𝑔𝑡ℎ ; 10: for 𝑖 ←- 𝑠𝑡𝑒𝑝𝑠 to 𝑠𝑡𝑒𝑝𝑠 do 11: Calculate the start and end points of the segment based on 𝑚𝑖𝑑𝑝𝑜𝑖𝑛𝑡 and step size; 12: if segment length > 𝑠𝑒𝑔 _ 𝑙𝑒𝑛𝑔𝑡ℎ then 13: Split the segment into two segments at the 𝑚𝑖𝑑𝑝𝑜𝑖𝑛𝑡 ; 14: else 15: Create a single segment; 16: Mark the start or the end of edge segments as corner segments; 17: Add the segments and directions to polygon segments list; 18: Add the polygon segments and directions to 𝑎𝑙𝑙 _ 𝑠𝑒𝑔𝑚𝑒𝑛𝑡𝑠 ; 19: return 𝑎𝑙𝑙 _ 𝑠𝑒𝑔𝑚𝑒𝑛𝑡𝑠 ; In DiffOPC, after determining the segments 𝑺 and their corresponding directions D , it is crucial to establish the velocity vector 𝒗 𝑖 for each segment 𝒔 𝑖 . The velocity vector connects the movement of edge segments with the gradients obtained from lithography simulations. The concept of velocity vectors is inspired by level set-based ILT (LSILT). In LSILT, the velocity component is the projection of the gradient of the implicit level set function 𝜙 onto the mask plane, denoted as ∇ 𝜙 , which can be a vector in any direction. However, in DiffOPC, the movement direction 𝒗 𝑖 of an edge segment 𝒔 𝑖 is restricted to be perpendicular to its direction vector 𝒅 𝑖 , (either horizontal or vertical), satisfying the condition 𝒗 𝑖 · 𝒅 𝑖 = 0. Additionally, we set the default orientation of all velocity vectors 𝒗 𝑖 to point outward from the polygon, as illustrated in Figure 2.",
  "3.2 Differentiable Edge-Based OPC": "The preprocessed data consists of segments 𝑺 and corresponding velocity vectors 𝑽 . 𝑺 is stored as learnable parameters in tensor 𝑺 ∈ R 𝑁 𝑠 × 2 × 2 , while 𝑽 is a fixed tensor 𝑽 ∈ R 𝑁 𝑠 × 2 used in computations, where 𝑁 𝑠 is the number of segments. In DiffOPC, the forward pass from edge parameters 𝑺 to the resist image 𝒁 involves five differentiable steps: 1) Edge parameter rounding. 2) Merging corner edges. 3) Edge-to-mask rasterization. 4) Forward lithography simulation. 5) Loss calculation. Each step's forward and backward computations will be discussed in detail in this chapter. Differentiable edge parameter rounding . Since the edge parameters 𝑺 are real-valued, while the edge coordinate system is integervalued, the rounding operation is non-differentiable. To address this issue and enable a differentiable process, we employ the straightthrough estimator (STE) for rounding 𝑺 .  STE is defined as:   The forward pass illustrated in Figure 3(a) applies the rounding function to 𝑺 , while the backward pass directly propagates the gradients from ¯ 𝑺 to 𝑺 , as shown in Figure 3(b). Figure 3: (a) STE forward; (b) STE backward. 1 2 3 4 1 2 3 0 𝑥 STE ( 𝑥 ) (a) 1 2 3 1 2 3 0 𝜕𝐿 𝜕𝑥 𝜕𝐿 𝜕 STE ( 𝑥 ) (b) Corner edge merging . During the optimization, as edges move, the endpoints of different segments separate. For non-corner segments, the segment length remains unchanged since they only move along the normal direction. The newly formed edges between adjacent segments can be obtained from the endpoints of the neighboring edges without additional processing. However, for segments adjacent to corners, the movement directions differ, requiring extra handling. After the movement, the new intersection point may lie outside the two segments. Therefore, it is necessary to additionally connect the segments adjacent to the corners. The adjusted algorithm is presented in Algorithm 2. After the forward pass of the corner merging operation, the modified edge parameters ˆ 𝑺 ensure that all adjacent segments at the corners are re-connected. The backward pass is straightforward, as the gradients are directly propagated to the rounded edge parameters ¯ 𝑺 .",
  "Algorithm 2 Find Intersection and Adjust Corner Segments": "function FindIntersectionAndAdjust(¯ 𝑠 1 , ¯ 𝑠 2 ) 1: 2: 𝑠 𝑣 ← vertical segment; 𝑠 ℎ ← horizontal segment; 3: 𝑝 † ← the intersection point ( 𝑥 of 𝑠 𝑣 , 𝑦 of 𝑠 ℎ ); 4: if ¯ 𝑠 1 is vertical then 5: Adjust the end point of the vertical line 𝑠 𝑣 to 𝑝 † ; 6: Adjust the start point of the horizontal line 𝑠 ℎ to 𝑝 † ; 7: else 8: Adjust the end point of the horizontal line 𝑠 ℎ to 𝑝 † ; 9: Adjust the start point of the vertical line 𝑠 𝑣 to 𝑝 † ; 10: return the adjusted segments ( ˆ 𝑠 1 , ˆ 𝑠 2 ) ;",
  "Differentiable rasterization using CUDA-accelerated ray cast-": "ing . The core challenge in DiffOPC is the edge-to-pixel rasterization, as the lithography model in eq. (1) only accepts pixel-based mask input 𝑴 . This rasterization process must be differentiable to allow the gradient flow to reach the edge parameters from the mask, and it should be as fast as possible since it is performed in every optimization epoch. Traditional EBOPC methods involve moving segments and then filling or subtracting the corresponding binary matrix at the new positions. However, this approach is time-consuming due to the need to sequentially access each segment and convert the segment's displacement into mask indices, repeatedly reading and modifying the corresponding locations. To address these issues, a method that effectively generates a binary mask from rounded edge parameters using CUDA-accelerated ray casting is proposed in Algorithm 3. Algorithm 3 presents an efficient, fully parallelized method for generating a binary mask from edge parameters using ray casting. The main function, Rasterize , initializes an empty mask and a count matrix, then extracts horizontal segments from the edge parameters. Since the polygons in the mask are Manhattan rectangles and closed shapes, the algorithm only needs to process segments along one direction (either horizontal or vertical), reducing the computational cost by half. For each segment, the algorithm performs parallel computation across all grid points within the bounding box, calling the check_cross function to determine ray-segment intersections. The check_cross function uses cross products to efficiently check if a ray from a point intersects a segment. After processing all segments, the even-odd rule is applied to finalize the binary mask based on the parity of intersections at each point. The algorithm leverages parallel computation, efficient ray-segment intersection checks, and the properties of Manhattan rectangles to enable fast and accurate mask generation, making it suitable for use in the DiffOPC framework. Algorithm 3 Parallelized Ray Casting for Edge to Mask Rasterization Input: Merged edge parameters: ˆ 𝑺 , width 𝑊 , height 𝐻 ; Output: Binary mask: 𝑚𝑎𝑠𝑘 ; 1: function Rasterize ( ˆ 𝑺 , 𝑊 , 𝐻 ) 2: 𝑚𝑎𝑠𝑘 ← zeros (( 𝑊,𝐻 )) ; 𝑏𝑏𝑜𝑥 ← bounding_box ( ˆ 𝑺 ) ; 3: 𝑝𝑜𝑖𝑛𝑡𝑠 ← grid_within ( 𝑏𝑏𝑜𝑥 ) ; 𝑐𝑜𝑢𝑛𝑡 ← zeros (( 𝑊,𝐻 )) ; 4: ▷ Create grid points and initialize count 5: ˆ 𝑺 ℎ ← extract horizontal segments from ˆ 𝑺 ; 6: for 𝒔 𝑖 in ˆ 𝑺 ℎ parallelly do ▷ Parallel computation 7: for 𝑝 in 𝑝𝑜𝑖𝑛𝑡𝑠 parallelly do 8: 𝑐𝑟𝑜𝑠𝑠 ← check_cross ( 𝑝, 𝒔 𝑖 ) ; 9: 𝑐𝑜𝑢𝑛𝑡 [ 𝑝 ]← 𝑐𝑜𝑢𝑛𝑡 [ 𝑝 ] + 𝑐𝑟𝑜𝑠𝑠 ▷ Accumulate checks 10: __syncthreads() ; ▷ Synchronize threads 11: 𝑚𝑎𝑠𝑘 ← mod ( 𝑐𝑜𝑢𝑛𝑡, 2 ) == 1; ▷ Apply even-odd rule 12: return 𝑚𝑎𝑠𝑘 ; 13: function check_cross ( 𝑝 , 𝑺 ) 14: 𝑣 1 ← 𝑝 - 𝑠.𝑠𝑡𝑎𝑟𝑡 ; 𝑣 2 ← 𝑝 - 𝑠.𝑒𝑛𝑑 ; ▷ Vectors from 𝑝 to 𝑺 15: 𝑐𝑟𝑜𝑠𝑠 ← 𝑣 1 .𝑥 × 𝑣 2 .𝑦 - 𝑣 1 .𝑦 × 𝑣 2 .𝑥 ; ▷ Cross product 16: 𝑐𝑜𝑛𝑑 1 ←( 𝑣 1 .𝑥 < 0 ) and ( 𝑣 2 .𝑥 ≥ 0 ) and ( 𝑐𝑟𝑜𝑠𝑠 < 0 ) ; 17: 𝑐𝑜𝑛𝑑 2 ←( 𝑣 1 .𝑥 ≥ 0 ) and ( 𝑣 2 .𝑥 < 0 ) and ( 𝑐𝑟𝑜𝑠𝑠 > 0 ) ; 18: return 𝑐𝑜𝑛𝑑 1 or 𝑐𝑜𝑛𝑑 2; ▷ True if ray crosses the segment The forward pass of the rasterization process converts the edge parameters, represented as a tensor of shape [ 𝑁 𝑠 , 2 , 2 ] , into a mask tensor of shape [ 𝑊,𝐻 ] , where 𝑁 𝑠 is the number of segments, and 𝑊 and 𝐻 are the width and height of the mask, respectively. In contrast, the backward pass requires transforming the gradients from the lithography model, which are of shape [ 𝑊,𝐻 ] , into gradients for the segments, represented as a tensor of shape [ 𝑁 𝑠 , 2 , 2 ] . To accomplish this, the algorithm first computes the gradient of the mask tensor with respect to the edge parameters using automatic differentiation. Let 𝜕𝐿 𝜕 𝑴 be the gradient of the loss function 𝐿 with respect to the mask tensor 𝑴 , obtained from the lithography model. The goal is to calculate 𝜕𝐿 𝜕 ˆ 𝑺 , the gradient of the loss function with respect to the edge parameters ˆ 𝑺 . Applying the chain rule, we have:  The term 𝜕 𝑴 𝜕 ˆ 𝑺 represents the Jacobian matrix of the rasterization process, which maps changes in edge parameters to changes in the mask tensor. This Jacobian matrix is computed efficiently using Algorithm 4. In our implementation, as in the Interpolate function in line 10, we choose the gradient at the midpoint of each segment as the representative gradient for that segment, as stated in eq. (10). Once the Jacobian matrix is obtained, the gradient of the loss function with respect to the edge parameters can be calculated by multiplying the gradient of the loss function with respect to the mask tensor, 𝜕𝐿 𝜕 𝑴 , by the Jacobian matrix 𝜕 𝑴 𝜕 𝑺 . This operation effectively backpropagates the gradients from the lithography model to the edge parameters, enabling the optimization of the edge-based OPC problem using gradient-based methods. MRC aware optimization . One of the significant advantages of EBOPC is the ability to obtain boundary information in real-time during the optimization process, including edges, line ends, jogs, notches, and other features. This is not possible with PBOPC. While Algorithm 4 Transform Mask to Edge Gradients with Velocity 1: Input: Gradient matrix 𝜕𝐿 𝜕 𝑴 of size 𝑊 × 𝐻 ; 2: Input: Edge segments ˆ 𝑺 of shape [ 𝑁 𝑠 , 2 , 2 ] , where each edge is defined by two points: start ( 𝑥 1 , 𝑦 1 ) and end ( 𝑥 2 , 𝑦 2 ) ; 3: Input: Pre-defined velocity list 𝑽 for each segment 𝒔 𝑖 ; 4: Output: Edge gradients 𝜕𝐿 𝜕 ˆ 𝑺 of shape [ 𝑁 𝑠 , 2 , 2 ] ; 5: function ComputeEdgeGradients( 𝜕𝐿 𝜕 , ˆ 𝑺 , 𝑽  level set-based methods can control boundaries globally, they lack the ability to fine-tune specific locations. DiffOPC generates MRCclean optimization results by explicitly controlling manufacturability through the velocity term 𝒗 𝑖 during optimization. Before the experiment, we divide the MRC edges into corresponding check pairs. We classify mask rules into two categories: spacing checks, such as minimum spacing, end of line spacing, jog to jog spacing, and special notch spacing, and width checks, such as minimum width check. Let 𝜹 denote the distance vector between check pairs. The projection of 𝜹 along the y-direction is given by proj 𝑦 𝜹 = ( 𝜹 · 𝒋 ) 𝒋 , where 𝒋 is the unit vector in the y-direction. The projection along the x-direction is similarly defined. We achieve MRC-aware optimization by controlling the velocity 𝒗 𝑖 as follows: 𝒗 ′ 𝑖 = 𝒗 𝑖 · 𝜏 ( 𝜹 ) where 𝜏 ( 𝜹 ) is a function related to 𝜹 , defined as: 𝜏 ( 𝜹 ) = 𝜎 ( 𝛽 ( proj 𝜹 -𝐷 )) . Here, 𝐷 is a constant related to the mask rule, and proj is the projection operator in either 𝑥 or 𝑦 direction, 𝛽 is the steepness of sigmoid function 𝜎 (·) . For the spacing and width check, when the distance proj 𝜹 is smaller than 𝐷 , the velocity term rapidly decays to 0, preventing further reduction in the distance. When proj 𝜹 is greater than 𝐷 , 𝜏 ( 𝜹 ) returns to 1, allowing normal optimization to proceed without interference. By controlling the velocity term based on the distance between check pairs and mask rule constants, DiffOPC effectively incorporates MRC constraints into the optimization process. Lithography simulations . After obtaining the mask 𝑴 through the rasterization process, we can utilize forward lithography model in eq. (1) to calculate the aerial intensity 𝑰 . To obtain a continuousvalued printed image 𝒁 , we employ the sigmoid function 𝜎 (·) to scale eq. (2) into a continuous space: 𝒁 = 𝜎 ( 𝛼 ( 𝑰 -𝐼 𝑡ℎ )) , where 𝛼 is the steepness of 𝜎 (·) , and 𝐼 𝑡ℎ is the threshold intensity value. Objective function . We employ a combination of three loss functions: 𝐿 2 loss, PVB loss, and EPE loss. The 𝐿 2 loss and PVB loss are defined as:  For the EPE loss, measured points are sampled along the boundary of the target patterns, which includes a set of samples on horizontal edges (HS) and a set of samples on vertical edges (VS). To map the EPE loss to the continuous-value domain, we utilize the sigmoid function. First, we calculate the distance between 𝒁 𝑛𝑜𝑚 and the target pattern 𝑻 at the sampled points in VS and HS:   where 𝑫 𝑖𝑘 and 𝑫 𝑘𝑗 represent the distances between the printed image and the target pattern at the corresponding locations, and 𝑡ℎ 𝑒𝑝𝑒 is a threshold value that determines the neighborhood size for the distance calculation. 𝑫 is calculated by 𝑫 = ( 𝒁 𝑛𝑜𝑚 -𝑻 ) 2 . Next, we apply the sigmoid function to the calculated distances to obtain the continuous-valued EPE loss:  where 𝛾 is a scaling factor that controls the steepness of the sigmoid function. The total loss function is then defined as a weighted sum of the three individual loss components:  where 𝑤 1 , 𝑤 2 , and 𝑤 3 are the weights assigned to each loss component. The use of the sigmoid function in the EPE loss allows for a smooth integration of the EPE into the continuous-value domain, enabling efficient gradient-based optimization. For the backward pass, the gradients of the total loss function with respect to the segment 𝒔 𝑖 are calculated using the chain rule:  where ⌊·⌋ is floor operation and  For the 𝐿 2 loss, the gradient is calculated as:  where the 𝑯 ′ is the flipped kernel set 𝑯 , and the 𝑯 ∗ is the conjugate of 𝑯 . Similarly, for the PVB loss, the gradient is calculated as:  The derivation of 𝜕 𝒁 𝑚𝑖𝑛 𝜕 𝑴 and 𝜕 𝒁 𝑚𝑎𝑥 𝜕 𝑴 is similar to that of 𝜕 𝒁 𝜕 𝑴 in eq. (12). For the EPE loss, the gradient is calculated by summarizing the gradients at the measure points ( 𝑖, 𝑗 ) :  where  and  with 𝜕 𝑫 𝑖 𝑗 𝜕 𝑴 calculated as:  The detailed derivation of 𝜕 𝒁 𝑖 𝑗 𝜕 𝑴 can be found in eq. (12). SRAF generation . SRAFs in lithography enhance sub-resolution element printability by modifying diffraction and interference patterns in photoresist, leading to widened process windows, improved resolution, depth of focus, and reduced line edge roughness. The primary distinction among prior works lies in their handling of SRAFs. In level set-based ILT methods, the implicit function 𝜙 is tied to the primary pattern, preventing the generation of SRAFs during optimization. Conversely, pixel-based ILT methods like [14] can generate SRAFs during mask optimization due to their higher degree of freedom. However, pixel-based ILT cannot impose rule-based constraints on SRAFs, causing their growth to rely solely on gradients. This improves printability but can increase MRC violations and hotspots. To address these issues, we propose a two-stage SRAF optimization algorithm. The first stage involves efficient SRAF seed generation using gradient contours, and the second stage employs a differentiable edge-based optimization for the generated SRAFs. This approach effectively avoids the problems of missing SRAFs in level set-based methods and violations in pixel-based SRAFs. Gradient Contour-based SRAF Seed Generation: During the optimization process, we observe that certain regions near the main pattern exhibit gradients that flip the mask value, changing it from 0 to 1. However, since the edge-based segments do not include these regions, they remain at 0. Combining continuous transmission mask (CTM) [19] theory and the results from [14], we conclude that these gradients can contribute to SRAF generation. As depicted in Figure 4(a), the contour line of the mask gradient map shows the position of the extreme gradient points and indicates the gradient drop rate. The position of the extreme points can guide SRAF placement, while the gradient information can guide the subsequent SRAF cleanup process. The implementation involves extending the existing mask by a certain distance related to the mask rules to create a SRAF forbidden region. As illustrated in Figure 4(a), gradient contour lines are drawn outside the SRAF forbidden region. The extreme points and the corresponding contour aspect ratios are used as the center of the SRAF seeds. The initial SRAF minimum width/length is set to a fixed value, and the shape and placement of the SRAF are determined based on the aspect ratio. This step does not require precise SRAF generation; it only needs to determine the initial position and aspect ratio. Differentiable Edge-based SRAF Optimization: In the second stage, the generated seeds illustrated in Figure 4(a) are processed using the Algorithm 1 segmentation method to create new segments, which are then added to the main optimization process. The SRAFs are optimized together with the mask. To accelerate the SRAF optimization process, we adopt a multi-resolution strategy similar to [14]. SRAF seeds are generated at low resolution, and then the seeds and mask are refined in high resolution for more precise optimization. Sample results are shown in Figure 4(b). The proposed two-stage SRAF optimization algorithm enables the generation of SRAFs that Figure 4: DiffOPC SRAF insertion and optimization. SRAF Forbidden Region Initial SRAF Seeds Gradient map & Initial SRAFs (a) Final mask and SRAFs (b) enhance printability while minimizing MRC violations. We conducted a comprehensive comparison of DiffOPC, ILTs, and EBOPC in Table 1.",
  "4 Experimental Results": "In our implementation, we set 𝑁 𝑘 = 24 for the SOCS approximation. The parameters 𝛼 = 𝛽 = 𝛾 = 50, 𝑤 1 = 1 , 𝑤 2 = 0 . 9 , 𝑤 3 = 100. The default segment length is set to 80 nm. The lithography recipe is provided by the ICCAD 2013 [18] contest evaluation package. The mask fracturing tool is implemented based on a GPU-accelerated rectangular decomposition algorithm [20]. The entire framework is written in PyTorch and tested on an Nvidia RTX 3090 GPU. The mask rule check (MRC) is performed using KLayout. DiffOPC is tested on both metal layer and via layer designs. The metal layer evaluation designs for 32 nm M1 layout designs are from [18], and larger layouts from [14] for the same process node. The via layer evaluation designs are adopted from [21], containing ten 2 𝜇𝑚 × 2 𝜇𝑚 clips with different numbers of 70 𝑛𝑚 × 70 𝑛𝑚 via patterns. SRAF seeds are generated in a low resolution of 512 × 512 and optimized at a resolution of 2048 × 2048.",
  "4.1 Experimental Results on Metal Layer": "Comparison with ILT . Table 2 compares the performance of our proposed DiffOPC framework with state-of-the-art (SOTA) ILT approaches, namely NeuralILT [10] and MultiILT [14], on the ICCAD13 benchmark. The comparison is based on key metrics such as L2 ( 𝑛𝑚 2 ), PVB ( 𝑛𝑚 2 ), EPE ( 𝑛𝑚 ), number of shots, and turnaround time (TAT, seconds). DiffOPC demonstrates superior performance, achieving an average L2 of 28280, which is 1 . 5% and 27% lower than MultiILT and NeuralILT, respectively. Attributed to the utilization of EPE loss introduced in eq. (8), DiffOPC achieves lower EPE, with an average of 2.2, representing a 19% and 71% reduction compared to MultiILT and NeuralILT. Moreover, DiffOPC requires significantly fewer shots per case, with an average of 106.1 shots, representing a 62% and 81% reduction compared to MultiILT and NeuralILT, which translates to lower manufacturing costs. These results highlight the effectiveness of DiffOPC in generating mask patterns with improved printability while maintaining better manufacturability compared to ILT methods. As mentioned in Section 1 and illustrated in Figure 5, ILT approaches are prone to introducing MRC violations, which do not meet industrial requirements. We also present the post-MRC results for MultiILT in the \"Post-MRC\" column, where the TAT includes both the ILT runtime and the post-processing time for cleaning mask rule violations. It is noteworthy that the post-MRC stage for MultiILT leads to a significant performance degradation, evident from the Table 1: DiffOPC compared with ILTs and EBOPC. Table 2: Comparison with ILT methods on ICCAD13 dataset. Table 3: Comparison with ILT methods on larger dataset. increased average values of L2, PVB, EPE, and TAT compared to the original MultiILT results. The results of DiffOPC outperform all metrics of ILT in the post-MRC stage. This indicates that ILT-generated patterns may not optimize as desired and could introduce more violations, prolonging processing times due to MRC. In contrast, DiffOPC maintains superior performance without extra post-processing steps, highlighting its robustness and efficiency in generating high-quality, manufacturable mask patterns meeting industrial standards. Large dataset . To further validate the robustness and scalability of our proposed DiffOPC framework, we conduct experiments on a larger dataset and compare its performance with SOTA methods in Table 3. The results demonstrate that DiffOPC consistently outperforms the other methods, highlighting its effectiveness in handling complex and diverse patterns. DiffOPC achieves an average L2 of 50684, which is 4 . 7% and 28 . 2% lower than MultiILT and NeuralILT, Figure 5: MRC violations across methods and datasets NeuralILT [10] MultiILT [14] DiffOPC 0 10 20 30 8 . 9 11 . 7 0 18 . 6 25 . 4 0 4 22 0 Avg. MRC violations ICCAD13 Large Dataset Via respectively. Moreover, it exhibits superior performance in terms of EPE, with an average EPE of 2.7, representing a 23% and 75% reduction over MultiILT and NeuralILT. Notably, DiffOPC requires significantly fewer shots per case, with an average of 218.5 shots, which is 63% and 64% lower than MultiILT and NeuralILT. As observed in the previous experiment, the post-MRC stage for MultiILT leads to a deterioration in performance. This further underscores Table 4: Comparison with traditional MEEF EBOPC on ICCAD 2013 benchmark. the limitations of ILT-based methods in generating manufacturable patterns that comply with industrial requirements. Comparison with MEEF-based EBOPC on ICCAD2013 benchmark . To provide a fair comparison between proposed DiffOPC and the traditional MEEF-based EBOPC method [2], we evaluate both approaches on GPU without the inclusion of SRAFs. The results in Table 4 demonstrate that DiffOPC consistently outperforms MEEFEBOPC. On average, DiffOPC achieves an L2 of 30579.6, which is 6 . 5% lower than MEEF-EBOPC. Similarly, DiffOPC exhibits lower average PVB, EPE, and TAT with 3 . 9%, 58%, and 59% respectively. These findings highlight the superior printability of the mask patterns generated by DiffOPC compared to the traditional MEEF-EBOPC. It is worth noting that MEEF-EBOPC struggles to handle complex patterns. The limitation is evident from the results presented in Table 4, where MEEF-EBOPC exhibits particularly high EPE values for complex test cases such as c3 (EPE = 59) compared to simpler cases like c10 (EPE = 0). In contrast, DiffOPC demonstrates robust performance across all test cases while maintaining a competitive shot count compared to MEEF-EBOPC.",
  "4.2 Experimental Results on Via Layer": "In Table 5, we evaluate the performance of DiffOPC on the via layer against SOTA ILT and EBOPC methods, including a commercial tool, Calibre [22]. Comparison with ILT methods . DiffOPC outperforms ILT methods in terms of L2 and EPE, achieving the lowest values of 3957 and 13.5, respectively. Notably, DiffOPC achieves these improvements while maintaining a significantly lower shot count (9.7 shots on average), which is approximately 1/20th of the shot count required by [14] (225 shots). Comparison with EBOPC methods . Among the EBOPC methods, DiffOPC demonstrates superior performance, achieving the lowest L2 (3957), EPE (13.5), and TAT (2.8 seconds) compared to the commercial Calibre tool and the MEEF-based approach.",
  "4.3 Ablation Study": "Efficiency of CUDA-accelerated ray casting rasterization . We compare the runtime of our CUDA-accelerated ray casting rasterization approach with the traditional EBOPC method based on indexing and the find-then-move strategy. For a clip size of 2 𝜇𝑚 × 2 𝜇𝑚 , a single Table 5: Result comparison on via layer. ∗ EPE: EPE threshold set to 1 𝑛𝑚 . forward rasterization step in DiffOPC takes 16 milliseconds, while the traditional method requires 196 milliseconds, representing a 12 . 3 × speedup achieved by our CUDA ray casting implementation. Ablation Study on Segment Length . Segment length in DiffOPC also impacts optimization performance. In an ablation study using the ICCAD 2013 benchmark, segment lengths of 60 𝑛𝑚 , 80 𝑛𝑚 , and 100 𝑛𝑚 resulted in EPE of 2.6, 2.2, and 2.8, with runtimes of 8.95, 8.42, and 6.92 seconds. This shows that optimal segment length selection can enhance OPC performance. Future work could explore adaptive segment length strategies, adjusting lengths based on pattern complexity and optimization progress for better performance.",
  "4.4 Summary of Experimental Results": "The experimental results on both metal and via layers demonstrate DiffOPC's superiority over SOTA ILT, post-MRC ILT and EBOPC methods in terms of printability, manufacturability, and cost-efficiency. On metal layers, DiffOPC consistently outperforms SOTA ILT methods, exhibiting reduced EPE and shot count, along with lower manufacturing costs, while maintaining competitive TAT. The proposed framework eliminates the need for additional postprocessing to address MRC violations, making it an efficient and reliable edge-based OPC solution for large-scale OPC tasks. On via layers, DiffOPC achieves the best performance in L2, EPE, and TAT among EBOPC methods, surpassing even the commercial Calibre tool. Compared to ILT methods, DiffOPC shows the lowest L2 and EPE values while significantly reducing the number of shots, leading to lower manufacturing costs and improved throughput. These results highlight DiffOPC's enhanced printability, pattern fidelity, and computational efficiency.",
  "5 Conclusion": "We propose DiffOPC, a differentiable edge-based OPC framework that bridges the gap between the superior manufacturability of EBOPC and the enhanced performance of ILT. By leveraging a CUDA-accelerated ray casting algorithm, DiffOPC enables a differentiable rasterization process that allows gradients to propagate through the lithography model, facilitating the efficient optimization of edge segment positions. This innovative approach results in significant improvements in key metrics such as L2 and EPE while maintaining an exceptionally low shot count, leading to substantially reduced manufacturing costs. Moreover, DiffOPC incorporates an efficient SRAF generation method, which seamlessly integrates SRAF with the main pattern optimization for a holistic and effective OPC solution. Experimental results highlight DiffOPC's superior performance and efficiency over SOTA EBOPC and ILT methods, making it a promising advancement in semiconductor technologies.",
  "References": "[1] O. W. Otto, J. G. Garofalo, K. K. Low et al. , 'Automated optical proximity correction: a rules-based approach,' in Proc. SPIE , 1994, pp. 278-293. [2] J. Lei, L. Hong, G. Lippincott, and J. Word, 'Model-based opc using the meef matrix ii, ' in Optical Microlithography XXVII , vol. 9052. SPIE, 2014, pp. 170-178. [3] J.-R. Gao, X. Xu, B. Yu, and D. Z. Pan, 'MOSAIC: Mask optimizing solution with process window aware inverse correction,' in Proc. DAC , 2014, pp. 52:1-52:6. [4] T. E. Brist and J. A. Torres, 'Model-assisted placement of subresolution assist features: Experimental results,' in Proc. SPIE , vol. 5042, 2003, pp. 99-106. [5] X. Xu, Y. Lin, M. Li, T. Matsunawa, S. Nojima, C. Kodama, T. Kotani, and D. Z. Pan, 'Subresolution assist feature generation with supervised data learning,' IEEE TCAD , vol. 37, no. 6, pp. 1225-1236, 2017. [6] M. B. Alawieh, Y. Lin, Z. Zhang, M. Li, Q. Huang, and D. Z. Pan, 'GAN-SRAF: Sub-resolution assist feature generation using conditional generative adversarial networks,' in Proc. DAC , 2019, pp. 149:1-149:6. [7] H. Geng, W. Zhong, H. Yang, Y. Ma, J. Mitra, and B. Yu, 'Sraf insertion via supervised dictionary learning,' IEEE TCAD , 2020. [8] H. Yang, S. Li, Y. Ma, B. Yu, and E. F. Young, 'GAN-OPC: Mask optimization with lithography-guided generative adversarial nets,' in Proc. DAC , 2018, pp. 131:1131:6. [9] G. Chen, W. Chen, Y. Ma, H. Yang, and B. Yu, 'DAMO: Deep agile mask optimization for full chip scale, ' in Proc. ICCAD , 2020. [10] B. Jiang, L. Liu, Y. Ma, H. Zhang, E. F. Y. Young, and B. Yu, 'Neural-ILT: Migrating ILT to nerual networks for mask printability and complexity co-optimizaton',' in Proc. ICCAD , 2020. [11] W. Zhao, X. Yao, Z. Yu, G. Chen, Y. Ma, B. Yu, and M. D. F. Wong, 'AdaOPC: A selfadaptive mask optimization framework for real design patterns,' in Proc. ICCAD , 2022. [12] B. Zhu, S. Zheng, Z. Yu, G. Chen, Y. Ma, F. Yang, B. Yu, and M. D. F. Wong, 'L2O-ILT: Learning to optimize inverse lithography techniques,' IEEE TCAD , vol. 43, no. 3, pp. 944-955, 2024. [13] X. Zhang, S. Zheng, G. Chen, B. Zhu, H. Xu, and B. Yu, 'Fracturing-aware curvilinear ilt via circular e-beam mask writer,' 2024. [14] S. Sun, F. Yang, B. Yu, L. Shang, and X. Zeng, 'Efficient ILT via multi-level lithography simulation,' in Proc. DAC , 2023. [15] Z. Yu, G. Chen, Y. Ma, and B. Yu, 'A GPU-enabled level set method for mask optimization,' in Proc. DATE , 2021. [16] G. Chen, Z. Yu, H. Liu, Y. Ma, and B. Yu, 'DevelSet: Deep neural level set for instant mask optimization,' in Proc. ICCAD , 2021. [17] W. Lv, S. Liu, Q. Xia, X. Wu, Y. Shen, and E. Y. Lam, 'Level-set-based inverse lithography for mask synthesis using the conjugate gradient and an optimal time step,' Journal of Vacuum Science & Technology B, Nanotechnology and Microelectronics: Materials, Processing, Measurement, and Phenomena , vol. 31, no. 4, p. 041605, 2013. [18] S. Banerjee, Z. Li, and S. R. Nassif, 'ICCAD-2013 CAD contest in mask optimization and benchmark suite,' in Proc. ICCAD , 2013, pp. 271-274. [19] Z. Yu, P. Liao, Y. Ma, B. Yu, and M. D. F. Wong, 'CTM-SRAF: Continuous transmission mask-based constraint-aware subresolution assist feature generation,' IEEE TCAD , vol. 42, no. 10, pp. 3402-3411, 2023. [20] J. F. Chango, C. A. Navarro, and M. A. González-Montenegro, 'Gpu-accelerated rectangular decomposition for sound propagation modeling in 2d,' in 2019 38th International Conference of the Chilean Computer Science Society (SCCC) , 2019. [21] S. Zheng, H. Yang, B. Zhu, B. Yu, and M. D. Wong, 'LithoBench: Benchmarking AI computational lithography for semiconductor manufacturing,' in Proc. NeurIPS , 2023. [22] 'Calibre Design Solutions, Siemens,' https://eda.sw.siemens.com/en-US/ic/calibredesign/.",
  "keywords_parsed": [],
  "references_parsed": [
    {
      "ref_id": "b1",
      "title": "Automated optical proximity correction: a rules-based approach"
    },
    {
      "ref_id": "b2",
      "title": "Model-based opc using the meef matrix ii"
    },
    {
      "ref_id": "b3",
      "title": "MOSAIC: Mask optimizing solution with process window aware inverse correction"
    },
    {
      "ref_id": "b4",
      "title": "Model-assisted placement of subresolution assist features: Experimental results"
    },
    {
      "ref_id": "b5",
      "title": "Subresolution assist feature generation with supervised data learning"
    },
    {
      "ref_id": "b6",
      "title": "GAN-SRAF: Sub-resolution assist feature generation using conditional generative adversarial networks"
    },
    {
      "ref_id": "b7",
      "title": "Sraf insertion via supervised dictionary learning"
    },
    {
      "ref_id": "b8",
      "title": "GAN-OPC: Mask optimization with lithography-guided generative adversarial nets"
    },
    {
      "ref_id": "b9",
      "title": "DAMO: Deep agile mask optimization for full chip scale"
    },
    {
      "ref_id": "b10",
      "title": "Neural-ILT: Migrating ILT to nerual networks for mask printability and complexity co-optimizaton"
    },
    {
      "ref_id": "b11",
      "title": "AdaOPC: A selfadaptive mask optimization framework for real design patterns"
    },
    {
      "ref_id": "b12",
      "title": "L2O-ILT: Learning to optimize inverse lithography techniques"
    },
    {
      "ref_id": "b13",
      "title": "Fracturing-aware curvilinear ilt via circular e-beam mask writer"
    },
    {
      "ref_id": "b14",
      "title": "Efficient ILT via multi-level lithography simulation"
    },
    {
      "ref_id": "b15",
      "title": "A GPU-enabled level set method for mask optimization"
    },
    {
      "ref_id": "b16",
      "title": "DevelSet: Deep neural level set for instant mask optimization"
    },
    {
      "ref_id": "b17",
      "title": "Level-set-based inverse lithography for mask synthesis using the conjugate gradient and an optimal time step"
    },
    {
      "ref_id": "b18",
      "title": "ICCAD-2013 CAD contest in mask optimization and benchmark suite"
    },
    {
      "ref_id": "b19",
      "title": "CTM-SRAF: Continuous transmission mask-based constraint-aware subresolution assist feature generation"
    },
    {
      "ref_id": "b20",
      "title": "Gpu-accelerated rectangular decomposition for sound propagation modeling in 2d"
    },
    {
      "ref_id": "b21",
      "title": "LithoBench: Benchmarking AI computational lithography for semiconductor manufacturing"
    },
    {
      "ref_id": "b22",
      "title": "Calibre Design Solutions, Siemens"
    }
  ]
}