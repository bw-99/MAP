{"title": "k 2 Q: A Quadratic-Form Response Time and Schedulability Analysis Framework for Utilization-Based Analysis", "authors": "Jian-Jia Chen; Wen-Hung Huang; Cong Liu", "pub_date": "2016-09-23", "abstract": "In this paper, we present a general response-time analysis and schedulability-test framework, called k 2 Q (k to Q). It provides automatic constructions of closed-form quadratic bounds or utilization bounds for a wide range of applications in real-time systems under fixed-priority scheduling. The key of the framework is a k-point schedulability test or a k-point response time analysis that is based on the utilizations and the execution times of k -1 higher-priority tasks. The natural condition of k 2 Q is a quadratic form for testing the schedulability or analyzing the response time. The response time analysis and the schedulability analysis provided by the framework can be viewed as a \"blackbox\" interface that can result in sufficient utilization-based analysis. Since the framework is independent from the task and platform models, it can be applied to a wide range of applications. We show the generality of k 2 Q by applying it to several different task models. k 2 Q produces better uniprocessor and/or multiprocessor schedulability tests not only for the traditional sporadic task model, but also more expressive task models such as the generalized multi-frame task model and the acyclic task model. Another interesting contribution is that in the past, exponential-time schedulability tests were typically not recommended and most of time ignored due to high complexity. We have successfully shown that exponential-time schedulability tests may lead to good polynomial-time tests (almost automatically) by using the k 2 Q framework. Analogously, a similar concept to test only k points with a different formulation has been studied by us in another framework, called k 2 U, which provides hyperbolic bounds or utilization bounds based on a different formulation of schedulability test. With the quadratic and hyperbolic expressions, k 2 Q and k 2 U frameworks can be used to provide many quantitive features to be measured, like the total utilization bounds, speed-up factors, etc., not only for uniprocessor scheduling but also for multiprocessor scheduling.", "sections": [{"heading": "Introduction", "text": "Analyzing the worst-case timing behaviour to ensure the timeliness of embedded systems is essential for building reliable and dependable components in cyber-physical systems. Due to the interaction and integration with external and physical devices, many real-time and embedded systems are expected to handle a large variety of workloads. Towards such dynamics, several formal real-time task models are established to represent these workloads with various characteristics, such as the the generalized multi-frame task model [8], [45] and the self-suspending task model [37]. To analyze the worstcase response time or to ensure the timeliness of the system, for each of these task models, researchers tend to develop dedicated techniques that result in schedulability tests with different computation complexity and accuracy of the analysis. Although many successful results have been developed, after many real-time systems researchers devoted themselves for many years, there does not exist a general framework that can provide efficient and effective analyses for different task models.\nPrior to this paper, we have presented a general schedulability analysis framework [19], [20], called k 2 U, that can be applied in uniprocessor scheduling and multiprocessor scheduling, as long as the schedulability condition can be written in a specific form to test only k points. For example, to verify the schedulability of a (constrained-deadline) sporadic real-time task \u03c4 k under fixed-priority scheduling in uniprocessor systems, the time-demand analysis (TDA) developed in [35] can be adopted.\nThe general concept to obtain sufficient schedulability tests in the k 2 Q framework is to test only a subset of time points for verifying the schedulability. This idea is implemented in the k 2 Q framework by providing a k-point last-release schedulability test, which only needs to test k points under any fixed-priority scheduling when checking schedulability of the task with the k th highest priority in the system. Moreover, this concept is further extended to provide a safe upper bound of the worst-case response time. The response time analysis and the schedulability analysis provided by the framework can be viewed as a \"blackbox\" interface that can result in sufficient utilization-based analysis.\nRelated Work. There have been several results in the literature with respect to utilization-based, e.g., [13], [30], [32], [33], [38], [39], [47], and non-utilization-based, e.g., [17], [27], schedulability tests for the sporadic real-time task model and its generalizations in uniprocessor systems. Most of the existing utilization-based schedulability analyses focus on the total utilization bound. That is, if the total utilization of the task system is no more than the derived bound, the task system is schedulable by the scheduling policy. For example, the total utilization bounds derived in [16], [30], [39] are mainly for rate-monotonic (RM) scheduling, in which the results in [30] can be extended for arbitrary fixed-priority scheduling. Kuo et al. [32] further improve the total utilization bound by using the notion of divisibility. Lee et al. [33] use linear programming formulations for calculating total utilization bounds when the period of a task can be selected. Moreover, Wu et al. [47] adopt the Network Calculus to analyze the total utilization bounds of several real-time task models.\nBini and Buttazzo [12] propose a framework of schedulability tests that can be tuned to balance the time complexity and the acceptance ratio of the schedulability test for uniprocessor sporadic task systems. The efficient tests in [12] are based on an observation to test whether the parameters of a task set fall into a schedulable region of the fixed-priority scheduling policy. Our strategy and philosophy are simpler than [12]. First, we only look at the parameters of task \u03c4 k (the task defined as the k th highest priority) that is under analysis by assuming that the higher-priority tasks are already verified to be schedulable. Second, similar to our recent general schedulability analysis framework k 2 U [20], we also apply the key idea of evaluating only k points. The tunable strategies in [12] consider to examine a subset of the time points for schedulability tests.\nDistinct from the results in [12], our objective in this paper is to find closed-form schedulability tests and responsetime analyses that can be independent from task and platform models. We target at sufficient schedulability tests and response time analyses that are not exact but can be calculated efficiently in linear-time or polynomial-time complexity.\nComparison to k 2 U: Even though k 2 Q and k 2 U share the same idea to test and evaluate only k points, they are based on completely different criteria for testing. In k 2 U, all the testings and formulations are based on only the higher-priority task utilizations. In k 2 Q, the testings are based not only on the higher-priority task utilizations, but also on the higher-priority task execution times. The above difference in the formulations results in completely different properties and mathematical closed-forms. The natural condition of k 2 Q is a quadratic form for testing the schedulability or the response time of a task, whereas the natural condition of k 2 U is a hyperbolic form for testing the schedulability of a task.\nIf one framework were dominated by another or these two frameworks were just with minor difference in mathematical formulations, it wouldn't be necessary to separate and present them as two different frameworks. Both frameworks are in fact needed and have to be applied for different cases. Here, we only shortly explain their differences, advantages, and disadvantages in this paper. For completeness, another document has been prepared in [18] to present the similarity, the difference and the characteristics of these two frameworks in details.\nSince the formulation of k 2 U is more restrictive than k 2 Q, its applicability is limited by the possibility to formulate the tests purely by using higher-priority task utilizations without referring to their execution times. There are cases, in which formulating the higher-priority interference by using only task utilizations for k 2 U is troublesome or over-pessimistic. For such cases, further introducing the upper bound of the execution time by using k 2 Q is more precise. Most of the presented cases, except the one in uniprocessor constraineddeadline systems in Appendix B are in the above category. Although k 2 Q is more general, it is not as precise as k 2 U, if we can formulate the schedulability tests into both frameworks with the same parameters. In such cases, the same pseudopolynomial-time (or exponential time) test is used, and the utilization bound or speed-up factor analysis derived from the k 2 U framework is, in general, tighter and better.\nIn a nutshell, k 2 Q is more general, whereas k 2 U is more precise. If an exact schedulability test can be constructed and the test can be converted into k 2 U, e.g., uniprocessor scheduling for constrained-deadline task sets, then, adopting k 2 U leads to tight results. For example, by using k 2 Q, we can reach the conclusion that the utilization bound for ratemonotonic scheduling is 2-\u221a 2 \u2248 0.586, which is less precise than the Liu and Layland bound ln 2 \u2248 0.693, a simple implication by using k 2 U. However, if we are allowed to change the execution time and period of a task for different job releases (called acyclic task model in [1]), then the tight utilization bound 2-\u221a 2 can be easily achieved by using k 2 Q.\nDue to the fact the k 2 U is more precise (with respect to the utilization bound) when the exact tests can be constructed, even though k 2 U is more restrictive, both are needed for different cases. Both k 2 U and k 2 Q are general enough to cover a range of spectrum of applications, ranging from uniprocessor systems to multiprocessor systems. For more information and comparisons, please refer to [18].", "publication_ref": ["b7", "b44", "b36", "b18", "b19", "b34", "b12", "b29", "b31", "b32", "b37", "b38", "b46", "b16", "b26", "b15", "b29", "b38", "b29", "b31", "b32", "b46", "b11", "b11", "b11", "b19", "b11", "b11", "b17", "b0", "b17"], "figure_ref": [], "table_ref": []}, {"heading": "Contributions.", "text": "The key contribution of this paper is a general schedulability and response-time analysis framework, k 2 Q, that can be easily applied to analyze a number of complex real-time task models, on both uniprocessor and multiprocessor systems. A key novelty of k 2 Q that allows a rather general analysis framework is that we do not specifically seek for the total utilization bound. Instead, we look for the critical value in the specified sufficient schedulability test while verifying the schedulability of task \u03c4 k . This critical value of task \u03c4 k gives the difficulty of task \u03c4 k to be schedulable under the scheduling policy. We present several properties of k 2 Q, which provide a series of closed-form solutions to be adopted for sufficient tests and worst-case response time analyses for real-time task models, as long as a corresponding k-point last-release schedulability test (Definition 2) or a k-point last-release responsetime analysis (Definition 3) can be constructed. The generality of k 2 Q is supported by demonstrating that either new or better results compared to the state-of-the-art can be easily obtained using k 2 Q. Examples include:\n\u2022 Several utilization-based schedulability and response analyses for uniprocessor sporadic task systems are provided in Section 5 The utilization-based worst-case response-time analysis in Theorem 4 in Section 5 is identical to the response-time analysis by Bini et al. [15] developed in parallel. \u2248 2.823 for implicit-deadline sporadic task systems, which improves upon the existing best speed-up factor 3 presented in [10].\n\u2022 We provide, to the best of our knowledge, the first polynomial-time worst-case response time analysis for sporadic real-time tasks with jitters [3], [9] in Appendix D.\n\u2022 We also demonstrate how to convert exponential-time schedulability tests of generalized multi-frame task models [8], [46] to polynomial-time tests by using the k 2 Q framework in Appendix E. \u2022 The above results are for task-level fixed-priority scheduling policies. We further explore mode-level fixed-priority scheduling policies by studying the acyclic task model [1] and the multi-mode task model [24]. 1 We conclude a quadratic bound and a utilization bound 2 -\u221a 2 for RM scheduling policy. The utilization bound is the same as the result in [1]. They can be further generalized to handle more generalized task models, including the digraph task model [44], the recurring real-time task model [6]. This is presented in Appendix F.\nThe emphasis of this paper is to show the generality of the k 2 Q framework by demonstrating via several task models. The tests and analytical results in the framework are with low complexity, but can still be shown to provide good results through speed-up factor or utilization bound analyses. We also note a somehow surprising finding through developing this framework: in the past, exponential-time schedulability tests were typically not recommended and most of time ignored, as this requires very high complexity. We have successfully shown in this paper that exponential-time schedulability tests may lead to good polynomial-time tests (almost automatically) by using the k 2 Q framework. Therefore, this framework may also open the possibility to re-examine some tests with exponentialtime complexity to improve their applicability.", "publication_ref": ["b14", "b9", "b2", "b8", "b7", "b45", "b0", "b23", "b0", "b43", "b5"], "figure_ref": [], "table_ref": []}, {"heading": "Basic Task and Scheduling Models", "text": "This section presents the sporadic real-time task model, as the basis for our presentations. Even though the framework targets at more general task models, to ease the presentation flow, we will start with the sporadic task models. A sporadic task \u03c4 i is released repeatedly, with each such invocation called a job. The j th job of \u03c4 i , denoted \u03c4 i,j , is released at time r i,j and has an absolute deadline at time d i,j . Each job of any task \u03c4 i is assumed to have execution time C i . Here in this paper, whenever we refer to the execution time of a job, we mean for the worst-case execution time of the job, since all the analyses we use are safe by only considering the worst-case execution time. The response time of a job is defined as its finishing time minus its release time. Successive jobs of the same task are required to be executed in sequence. Associated with each task \u03c4 i are a period T i , which specifies the minimum time between two consecutive job releases of \u03c4 i , and a deadline D i , which specifies the relative deadline of each such job, i.e., d i,j = r i,j + D i . The worst-case response time of a task \u03c4 i is the maximum response time among all its jobs. The utilization of a task \u03c4 i is defined as\nU i = C i /T i .\nA sporadic task system \u03c4 is an implicit-deadline system if D i = T i holds for each \u03c4 i . A sporadic task system \u03c4 is a constrained-deadline system if D i \u2264 T i holds for each \u03c4 i . Otherwise, such a sporadic task system \u03c4 is an arbitrarydeadline system.\nA task is said schedulable by a scheduling policy if all of its jobs can finish before their absolute deadlines, i.e., the worst-case response time of the task is no more than its relative deadline. A task system is said schedulable by a scheduling policy if all the tasks in the task system are schedulable. A schedulability test expresses sufficient schedulability conditions to ensure the feasibility of the resulting schedule by a scheduling policy.\nThroughout the paper, we will focus on fixed-priority preemptive scheduling. That is, each task is associated with a priority level (except in Appendix F). For a uniprocessor system, the scheduler always dispatches the job with the highest priority in the ready queue to be executed. For a multiprocessor system, we consider multiprocessor global scheduling on M identical processors, in which each of them has the same computation power. For global multiprocessor scheduling, there is a global queue and a global scheduler to dispatch the jobs. We consider only global fixed-priority scheduling. At any time, the M -highest-priority jobs in the ready queue are dispatched and executed on these M processors.\nNote that the framework is not only limited to the above task and platform models. These terminologies are introduced only for the simplicity of presentation and illustrating some examples.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Speed-Up Factor and Capacity Augmentation Factor:", "text": "To quantify the error of the schedulability tests or the scheduling policies, the concept of resource augmentation by using speedup factors [43] and the capacity augmentation factors [36] has been adopted. For example, global DM in general does not have good utilization bounds to schedule a set of sporadic tasks on M identical processors, due to \"Dhall's effect\" [26]. However, if we constrain the total utilization \u03c4i Ci M Ti \u2264 1 b , the density\nC k + \u03c4 i \u2208hp(\u03c4 k ) Ci M D k \u2264 1\nb for each task \u03c4 k , and the maximum utilization max \u03c4i Ci min{Ti,Di} \u2264 1 b , it is possible to provide the schedulability guarantee of global RM by setting b to 3-1 M [2], [4], [10]. Such a factor b has been recently named as a capacity augmentation factor [36]. Note that the capacity augmentation bound was defined without taking this simple condition\nC k + \u03c4 i \u2208hp(\u03c4 k ) Ci M D k \u2264 1\nb in [36], as they focus on implicit-deadline systems. For constrained-deadline systems, adding such a new constraint is a natural extension.\nAn algorithm A is with speed-up factor b: If there exists a feasible schedule for the task system, it is schedulable by algorithm A by speeding up (each processor) to b times as fast as in the original platform (speed). A sufficient schedulability test for scheduling algorithm A is with speed-up factor b: If the task system cannot pass the sufficient schedulability test, the task set is not schedulable by any scheduling algorithm if (each processor) is slowed down to 1 b times of the original platform speed. Note that if the capacity augmentation factor is b, the speed-up factor is also upper-bounded by b.", "publication_ref": ["b42", "b35", "b25", "b3", "b9", "b35", "b35"], "figure_ref": [], "table_ref": []}, {"heading": "Analysis Flow", "text": "The framework focuses on testing the schedulability and the response time for a task \u03c4 k , under the assumption that the required properties (i.e., worst-case response time or the schedulability) of the higher-priority tasks are already verified and provided. We will implicitly assume that all the higherpriority tasks are already verified and the required properties are already obtained. Therefore, this framework has to be applied for each of the given tasks. To ensure whether a task system is schedulable by the given scheduling policy, the test has to be applied for all the tasks. Of course, the results can be extended to test the schedulability of a task system in linear time complexity or to allow on-line admission control in constant time complexity if the schedulability condition (or with some more pessimistic simplifications) is monotonic. Such extensions are presented only for trivial cases.\nWe will only present the schedulability test of a certain task \u03c4 k , that is analyzed, under the above assumption. For notational brevity, in the framework presentation, we will implicitly assume that there are k-1 tasks, say \u03c4 1 , \u03c4 2 , . . . , \u03c4 k-1 with higher-priority than task \u03c4 k . We will use hp(\u03c4 k ) to denote the set of these k-1 higher-priority tasks, when their orderings do not matter. Moreover, we only consider the cases when k \u2265 2, since k = 1 is pretty trivial.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "k 2 Q", "text": "This section presents the basic properties of the k 2 Q framework for testing the schedulability of task \u03c4 k in a given set of real-time tasks (depending on the specific models given in each application). Before presenting the framework, we first give a simple example to explain the underlying concepts by using an implicit-deadline sporadic task system \u03c4 , in which D i = T i for every \u03c4 i \u2208 \u03c4 . The exact schedulability test to verify whether task \u03c4 k can meet its deadline under fixedpriority scheduling on uniprocessor systems is to check\n\u2203t with 0 < t \u2264 T k and C k + \u03c4i\u2208hp(\u03c4 k ) t T i C i \u2264 t,(1)\nwhere hp(\u03c4 k ) is the set of tasks with higher priority than \u03c4 k . Instead of testing all the time points t in the range of 0 and T k , for a sufficient schedulability test, we can greedily only consider to test the time points\n( T k Ti -1)T i for \u03c4 i \u2208 hp(\u03c4 k ) and t = T k . If C k + \u03c4i\u2208hp(\u03c4 k )\nt Ti C i \u2264 t holds in one of those k tested time points, then we can conclude that \u03c4 k can be feasibly scheduled under this scheduling policy.\nTo implement to above testing concept, we need two definitions: 1) Definition 1 defines the last release time ordering so that we can formulate the problem with linear algebra, 2) Definition 2 defines an abstracted schedulability test that can be used to model general schedulability tests regardless of the task and platform model. Definition 1 (Last Release Time Ordering). Let \u03c0 be the last release time ordering assignment as a bijective function \u03c0 : hp(\u03c4 k ) \u2192 {1, 2, . . . , k -1} to define the last release time ordering of task \u03c4 j \u2208 hp(\u03c4 k ) in the window of interest. Last release time orderings are numbered from 1 to k -1, i.e., |hp(\u03c4 k )|, where 1 is the earliest and k -1 the latest.\nThe last release time ordering is a very important property in the whole framework. When testing the schedulability or analyzing the worst-case response time of task \u03c4 k , we do not need the priority ordering of the higher-priority tasks in hp(\u03c4 k ). But, we need to know how to order the k -1 higherpriority tasks so that we can formulate the test with simple and linear arithmetics based on the total order. For the rest of this paper, the ordering of the k -1 higher-priority tasks implicitly refers to their last release time ordering (except explanations regarding the last release time ordering when referring to Example 4). In the k 2 Q framework, we are only interested to test only k time points. More precisely, we are only interested to test whether task \u03c4 k can be successfully executed before the last release time of a higher-priority task in the testing window. Therefore, the last release time ordering provides a total order so that we can transform the schedulability tests into the following definition. Definition 2. A k-point last-release schedulability test under a given last release time ordering \u03c0 of the k -1 higherpriority tasks is a sufficient schedulability test of a fixedpriority scheduling policy, that verifies the existence of t j with j = 1, 2, . . . , k such that\n0 \u2264 t 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 t k and C k + k-1 i=1 \u03b1 i t i U i + j-1 i=1 \u03b2 i C i \u2264 t j ,(2)\nwhere C k > 0, for i = 1, 2, . . . , k-1, \u03b1 i > 0, U i > 0, C i \u2265 0, and \u03b2 i > 0 are dependent upon the setting of the task models and task \u03c4 i .\nExample 1. Implicit-deadline task systems: For an implicitdeadline sporadic task system \u03c4 , suppose that we are interested to test whether task \u03c4 k can meet its deadline or not under a fixed-priority scheduling algorithm on a uniprocessor platform. Let |hp(\u03c4 k )| be k -1 and the tasks in hp(\u03c4 k ) be ordered by\n( T k Ti -1)T i non-decreasingly, i.e., t 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 t k = T k .\nFor a specific testing point at time t j for a certain j = 1, 2, . . . , k, the function tj Ti C i (to quantify the workload due to the jobs released by a higher-priority task \u03c4 i \u2208 hp(\u03c4 k )) has two cases: 1) if i < j, due to the definition of t i as ( T k Ti -1)T i and t i \u2264 t j \u2264 T k , we know that tj Ti C i is upper bounded by\nti Ti C i + C i = t i U i + C i ; 2) if i \u2265 j, due to the definition of t i as ( T k Ti -1)T i and t j \u2264 t i \u2264 T k , we know that tj Ti C i is upper bounded by ti Ti C i = t i U i . 2\nBy the above analysis, for a given j = 1, 2, . . . , k, we know that\nC k + k-1 i=1 tj Ti C i \u2264 C k + k-1 i=1 t i U i + j-1 i=1 C i .\nTherefore, we know that task \u03c4 k is schedulable by the fixedpriority scheduling if there exists j \u2208 {1, 2, . . . , k} such that\nC k + k-1 i=1 t i U i + j-1 i=1 C i \u2264 t j .\nIn other words, by the specific index rule of the tasks in hp(\u03c4 k ) and setting \u03b1 i = 1 and \u03b2 i = 1 for every task \u03c4 i in hp(\u03c4 k ), we reach a concrete example for Definition 2.\nA concrete example is provided here for illustrating Example 1.\nExample 2. Consider that k = 3 and |hp(\u03c4 k )| is 2. For the two tasks in hp(\u03c4 k ), let C 1 = 2, U 1 = 0.2, T 1 = 10 and C 2 = 4, U 2 = 0.5, T 2 = 8. Suppose that t 3 = D 3 = T 3 = 36. By the transformation in Example 1, we know that t 1 = 30 and t 2 = 32. The last release time ordering \u03c0 of {\u03c4 1 , \u03c4 2 } follows the index, i.e., \u03c0 :\n{\u03c4 1 , \u03c4 2 } \u2192 {1, 2}. Moreover, \u03b1 1 = \u03b1 2 = \u03b2 1 = \u03b2 2 = 1.\nSimilar to Definition 2, we can also define an abstracted worst-case response time analysis as follows: Definition 3. A k-point last-release response time analysis is a safe response time analysis of a fixed-priority scheduling policy under a given last release time ordering \u03c0 of the k -1 higher-priority tasks by finding the maximum\nt k = C k + k-1 i=1 \u03b1 i t i U i + k-1 i=1 \u03b2 i C i ,(3)\nwith 0 \u2264 t 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 t k and C k + k-1 i=1 \u03b1 i t i U i + j-1 i=1 \u03b2 i C i > t j ,\u2200j = 1, 2, . . . , k -1,(4)\nwhere C k > 0, \u03b1 i > 0, U i > 0, C i \u2265 0, and \u03b2 i > 0 are dependent upon the setting of the task models and task \u03c4 i .\nExample 3. Response-time for constrained-deadline task systems: Suppose that R k is the exact worst-case response 2 Since t i is an integer multiple of T i , the property\nt i T i C i = t i U i holds.\ntime for task \u03c4 k and R k \u2264 T k under uniprocessor fixed-priority scheduling. That is, by Eq. (1),\nC k + \u03c4i\u2208hp(\u03c4 k ) t Ti C i > t for any 0 < t < R k and C k + \u03c4i\u2208hp(\u03c4 k ) R k Ti C i = R k .\nSimilar to Example 1, let |hp(\u03c4 k )| be k -1 and the tasks in hp(\u03c4 k ) be ordered by ( R k Ti -1)T i non-decreasingly, i.e.,\nt 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 R k . With the same analysis in Example 1, we know that C k + k-1 i=1 t i U i + j-1 i=1 C i > t j for j = 1, 2, . . . , k -1 and R k \u2264 C k + k-1 i=1 t i U i + k-1 i=1 C i .\nAs a result, by the specific index rule of the tasks in hp(\u03c4 k ) and setting \u03b1 i = 1 and \u03b2 i = 1 for every task \u03c4 i in hp(\u03c4 k ), we reach a concrete example for Definition 3.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Important Notes", "text": "Before presenting the analyses based on Definition 2 and Definition 3, we would like to first explain the important assumptions and the flow to use the analytical results. Throughout the paper, we implicitly assume that t k > 0 when Definition 2 is used. Moreover, we only consider non-trivial cases, in which C k > 0 and 0 < U i \u2264 1 for i = 1, 2, . . . , k-1. The definition of t k depends on how Definition 2 is constructed based on the original schedulability test, usually equal to the length of the interval (of the points to be tested in the original schedulability test), e.g., t k = T k = D k in Example 1. In most of the cases, we can set t k as D k . But, it can also be set to other cases, to be demonstrated in Appendix C for global RM scheduling.\nIn Definition 2, the k-point last-release schedulability test is a sufficient schedulability test that tests only k time points, defined by the k-1 higher-priority tasks and task \u03c4 k . Similarly, in Definition 3, a k-point last-release response time analysis provides a safe response time by only testing whether task \u03c4 k has already finished earlier at k -1 points, each defined by a higher-priority task.\nIn both cases in Definitions 2 and 3, the last release time ordering \u03c0 is assumed to be given. In some cases, this ordering can be easily obtained. For such cases, all the lemmas in this section can be directly adopted. However, in most of the cases in our demonstrated task models, we have to test all possible last release time orderings and take the worst case. Fortunately, we will show that finding the worst-case ordering is not a difficult problem, which requires to sort the k -1 higherpriority tasks under a simple criteria, in Lemmas 2 and 7. Therefore, for such cases, the lemmas in this section have to be adopted by combining with Lemma 2 or 7.\nWe first assume that the corresponding coefficients \u03b1 i and \u03b2 i in Definitions 2 and 3 are given. How to derive them will be discussed in the following sections. Clearly their values are highly dependent upon the task models and the scheduling policies. Provided that these coefficients \u03b1 i , \u03b2 i , C i , U i for every higher-priority task \u03c4 i \u2208 hp(\u03c4 k ) are given, we analyze (1) the response time by finding the extreme case for a given C k (under Definition 3), or (2) the schedulability by finding the extreme case for a given C k and D k . Therefore, the k 2 Q framework provides utilization-based schedulability analyses and response time analyses automatically if the corresponding parameters \u03b1 i and \u03b2 i can be defined to ensure that the tests in Definitions 2 and 3 are safe.\nk 2 Q can be used by a wide range of applications, as Demonstrated Applications:\nSec. 5: Arbitrary-deadline sporadic tasks Sec. 5:\nMultiprocessor RM App. D: Periodic tasks with jitters App. E: Generalized multiframe App. F: Acyclic and Multi-Mode Models long as the users can properly specify the corresponding task properties C i and U i and the constant coefficients \u03b1 i and \u03b2 i of every higher-priority task \u03c4 i . More precisely, the formulation in Definitions 2 and 3 does not actually care what C i and U i actually mean. When sporadic task models are considered, we will use these two terms as they were defined in Section 2, i.e., C i stands for the execution time and U i is Ci Ti . When we consider more general cases, such as the generalized multiframe and multi-mode task models, we have to properly define the values of U i and C i to apply the framework.\nU i , \u2200i < k C i , \u2200i < k \u03b1 i , \u2200i < k \u03b2 i , \u2200i < k C k t k (for Lemmas 1-\nThe use cases of k 2 Q can be achieved by using the known schedulability tests (that are in the form of pseudo polynomialtime or exponential-time tests) or some simple modifications of the existing results. We will provide the explanations of the correctness of the selection of the parameters, \u03b1 i , \u03b2 i , C i , U i for a higher-priority task \u03c4 i to support the correctness of the results. Such a flow actually leads to the elegance and the generality of the framework, which works as long as Definition 2 (Definition 3, respectively) can be successfully constructed for the sufficient schedulability test (response time, respectively) of task \u03c4 k in a fixed-priority scheduling policy. The procedure is illustrated in Figure 1. With the availability of the k 2 Q framework, the quadratic bounds or utilization bounds can be automatically derived as long as the safe upper bounds \u03b1 and \u03b2 can be safely derived, regardless of the task model or the platforms.\nWe are not going to present how to systematically and automatically derive these parameters to be applied for the k 2 Q framework. For most of the typical schedulability tests and response time analyses in real-time systems, such a derivation procedure is similar to the automatic parameter generation for the k 2 U in [21].", "publication_ref": ["b20"], "figure_ref": ["fig_0"], "table_ref": []}, {"heading": "Schedulability Test Framework", "text": "This section provides five important lemmas for deriving the utilization-based schedulability test based on Definition 2. Lemma 1 is the most general test, whereas Lemmas 3, 4, and 5 work for certain special cases when \u03b2 i C i \u2264 \u03b2U i t k for any higher-priority task \u03c4 i . Lemma 2 gives the worst-case last release time ordering, which can be used when the last release time ordering for testing task \u03c4 k is unknown.\nLemma 1. For a given k-point last-release schedulability test, defined in Definition 2, of a scheduling algorithm, in which 0 < \u03b1 i , and\n0 < \u03b2 i for any i = 1, 2, . . . , k -1, 0 < t k , k-1 i=1 \u03b1 i U i \u2264 1, and k-1 i=1 \u03b2 i C i \u2264 t k , task \u03c4 k is\nschedulable by the fixed-priority scheduling algorithm if the following condition holds\nC k t k \u2264 1- k-1 i=1 \u03b1 i U i - k-1 i=1 (\u03b2 i C i -\u03b1 i U i ( k-1 =i \u03b2 C )) t k .(5)\nProof: We prove this lemma by showing that the condition in Eq. ( 5) leads to the satisfactions of the schedulability conditions listed in Eq. ( 2) by using contrapositive. By taking the negation of the schedulability condition in Eq. ( 2), we know that if task \u03c4 k is not schedulable by the scheduling policy, then for each j = 1, 2, . . . , k\nC k + k-1 i=1 \u03b1 i t i U i + j-1 i=1 \u03b2 i C i > t j .(6)\nTo enforce the condition in Eq. ( 6), we are going to show that C k must have some lower bound, denoted as C * k . Therefore, if C k is no more than this lower bound, then task \u03c4 k is schedulable by the scheduling policy. For the rest of the proof, we replace > with \u2265 in Eq. ( 6), as the infimum and the minimum are the same when presenting the inequality with \u2265. The unschedulability for satisfying Eq. ( 6) implies that\nC k > C * k , where C * k is defined in the optimization problem: min C * k (7a) s.t. C * k + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i \u2265 t * j , \u2200j = 1, 2, . . . , k -1, (7b) t * 1 \u2265 0 (7c) t * j \u2265 t * j-1 , \u2200j = 2, 3, . . . , k -1,(7d)\nC * k + k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i \u2265 t k ,(7e)\nwhere t * 1 , t * 2 , . . . , t * k-1 and C * k are variables, \u03b1 i , \u03b2 i , U i , and C i are constants, and t k is a given positive constant. Moreover, it is obvious that relaxing the constraint t * j \u2265 t * j-1 for j = 2, 3, . . . , k -1 by using t * j \u2265 0 does not increase the corresponding objective function in the linear programming. Therefore, we have\nmin C * k (8a) s.t. C * k + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i \u2265 t * j , \u2200j = 1, 2, . . . , k -1, (8b) t * j \u2265 0, \u2200j = 1, 2, . . . , k -1,(8c)\nC * k + k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i \u2265 t k .(8d)\nLet s \u2265 0 be a slack variable such that\nC * k = t k + s - ( k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i ).\nTherefore, we can replace the objective function and the constraints with the above equality of C * k . The objective function (i.e., Eq. ( 8a)) is to find the minimum value of\nt k + s -( k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i ) such that Eq. (8b) holds, which is equivalent to t k + s -( k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i ) + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i = t k + s - k-1 i=j \u03b2 i C i \u2265 t * j , \u2200j = 1, 2, . . . , k -1.(9)\nFor notational brevity, let t * k be t k +s. Therefore, the linear programming in Eq. ( 8) can be rewritten as follows:\nmin t * k -( k-1 i=1 \u03b1 i U i t * i + k-1 i=1 \u03b2 i C i ) (10a) s.t. t * k - k-1 i=j \u03b2 i C i \u2265 t * j , \u22001 \u2264 j \u2264 k -1, (10b) t * j \u2265 0 \u22001 \u2264 j \u2264 k -1. (10c) t * k \u2265 t k (10d)\nThe remaining proof is to solve the above linear programming to obtain the minimum C * k . Our proof strategy is to solve the linear programming analytically as a function of t * k . This can be imagined as if t * k is given. At the end, we will prove the optimality by considering all possible t * k \u2265 t k . This involves three steps:\n\u2022 Step 1: we analyze certain properties of optimal solutions based on the extreme point theorem for linear programming [40] under the assumption that t * k is given as a constant, i.e., s is known.\n\u2022 Step 2: we present a specific solution in an extreme point, as a function of t * k . \u2022 Step 3: we prove that the above extreme point solution gives the minimum\nC * k if k-1 i=1 \u03b1 i U i \u2264 1.\n[Step 1:] After specifying the value t * k as a given constant, the new linear programming without the constraint in Eq. (10d) has only k -1 variables and 2(k -1) constraints. Thus, according to the extreme point theorem for linear programming [40], the linear constraints form a polyhedron of feasible solutions. The extreme point theorem states that either there is no feasible solution or one of the extreme points in the polyhedron is an optimal solution when the objective of the linear programming is finite. To satisfy Eqs. (10b) and (10c), we know that t * j \u2264 t * k for j = 1, 2, . . . , k -1, due to t * i \u2265 0, 0 < \u03b2, and C i \u2265 0 for i = j, j + 1, . . . , k -1. As a result, the objective of the above linear programming is finite since a feasible solution has to satisfy t\n* i \u2264 t * k for i = 1, 2, . . . , k -1,.\nAccording to the extreme point theorem, one of the extreme points is the optimal solution of Eq. (10). There are k -1 variables with 2k -2 constraints in Eq. ( 10). An extreme point must have at least k -1 active constraints in Eqs. (10b) and (10c), in which their \u2265 are set to equality =.\n[Step 2:] One special extreme point solution by setting\nt * j > 0 is to put t * k - k-1 i=j \u03b2 i C i = t * j for every j = 1, 2, . . . , k -1, i.e., \u22001 \u2264 i \u2264 k -1, t * i+1 -t * i = \u03b2 i C i ,(11)\nwhich implies that\nt * k -t * i = k-1 =i (t * +1 -t * ) = k-1 =i \u03b2 C(12)\nThe above extreme point solution is always feasible in the linear programming due to the assumption that\nk-1 j=1 \u03b2 j C j \u2264 t k \u2264 t * k .\nTherefore, in this extreme point solution, the objective function of Eq. ( 10) by rephrasing based on the condition in Eq. ( 12) is\nt * k - k-1 i=1 (\u03b1iUit * i + \u03b2iCi) (13) =t * k - k-1 i=1 \u03b1iUi t * k - k-1 =i \u03b2 C + \u03b2iCi (14) =t * k - k-1 i=1 \u03b1iUit * k + k-1 i=1 \u03b2iCi - k-1 i=1 \u03b1iUi k-1 =i \u03b2 C(15)\nwhich means that\nC * k \u2265 t * k (1 - k-1 i=1 \u03b1 i U i ) - k-1 i=1 (\u03b2 i C i - \u03b1 i U i ( k-1 =i \u03b2 C )).\n[Step 3:] The rest of the proof shows that other feasible extreme point solutions (that allow t * j to be 0 for some higherpriority task \u03c4 j ) are with worse objective values for Eq. (10). Under the assumption that\nk-1 i=1 \u03b2 i C i \u2264 t k \u2264 t * k , if t * j is set to 0, there are two cases: (1) t * k - k-1 i=j \u03b2 i C i > 0 or (2) t * k - k-1 i=j \u03b2 i C i = 0. In the former case, we can simply set t * j to t * k - k-1\ni=j \u03b2 i C i to improve the objective function without introducing any violation of the constraints. In the latter case, the value of t * j can only be set to 0 in any feasible solutions. Therefore, we conclude that any other feasible extreme point solutions for Eq. ( 10) are worse.", "publication_ref": ["b39", "b39", "b9", "b9"], "figure_ref": [], "table_ref": []}, {"heading": "Note that the above solution of C *", "text": "k is still a function of t * k . We need to find the minimization of C * k with respect to t * k based on the fact t * k \u2265 t k . Due to the assumption that 1 -\nk-1 i=1 \u03b1 i U i \u2265 0 and t * k \u2265 t k , we know that t * k (1 - k-1 i=1 \u03b1 i U i ) \u2265 t k (1 - k-1 i=1 \u03b1 i U i ). Therefore, C * k = t k (1 - k-1 i=1 \u03b1 i U i ) - k-1 i=1 (\u03b2 i C i -\u03b1 i U i ( k-1 =i \u03b2 C )) when 1 - k-1 i=1 \u03b1 i U i \u2265 0 and k-1 i=1 \u03b2 i C i \u2264 t k , which concludes the proof.\nLemma 1 can be applied only when the last release time ordering of the k -1 higher-priority tasks is given. We demonstrate the importance of the last release time ordering by using the following example. 3   Example 4.\nConsider that k = 3 and |hp(\u03c4 k )| is 2. For the two tasks in hp(\u03c4 k ), let C 1 = 2, U 1 = 0.2, T 1 = 10 and C 2 = 4, U 2 = 0.5, T 2 = 8. Suppose that t 3 = D 3 = T 3 = 36.\nBy the transformation in Example 1, we know that \u03b1 i = 1 and\n\u03b2 i = 1 for i = 1, 2.\nThere are two last release time orderings. Suppose that \u03c0 1 : {\u03c4 1 , \u03c4 2 } \u2192 {1, 2} and \u03c0 2 : {\u03c4 1 , \u03c4 2 } \u2192 {2, 1}. That is, the last release time ordering is \u03c4 1 , \u03c4 2 in \u03c0 1 , and the last release time ordering is \u03c4 2 , \u03c4 1 in \u03c0 2 . Now, we can use Lemma 1 based on \u03c0 1 and \u03c0 2 : 3 To demonstrate the impact of the last release time ordering, we use the original task indexes before applying \u03c0 1 or \u03c0 2 whenever referring to Example 4.\n\u2022 For \u03c0 1 , the schedulability condition in Lemma 1 shows that task \u03c4 3 in Example 4 can meet the deadline if\nC 3 \u2264 t 3 \u2022 (1 -U 1 -U 2 ) -(C 1 -U 1 (C 1 + C 2 ) + C 2 -U 2 C 2 ) = 0.3t 3 -2.8 = 8. \u2022 For \u03c0 2 , the schedulability condition in Lemma 1 shows that task \u03c4 3 in Example 4 can meet the deadline if C 3 \u2264 t 3 \u2022 (1 -U 2 -U 1 ) -(C 2 -U 2 (C 2 + C 1 ) + C 1 -U 1 C 1 ) = 0.3t 3 -2.6 = 8.2.\nThe immediate question is whether both C 3 \u2264 8 based on \u03c0 1 and C 3 \u2264 8.2 based on \u03c0 2 are safe. When t k = 36, the transformation in Example 1 in fact adopts the last release time ordering \u03c0 1 . Therefore, Lemma 1 is only safe under \u03c0 1 in this example. As a result, the test in Lemma 1 for the above example is only valid when we apply \u03c0 1 .\nHowever, in practice, we usually do not know how these tasks are indexed according to the required last release in the window of interest. It may seem at first glance that we need to test all the possible orderings. Fortunately, with the following lemma, we can safely consider only one specific last release time ordering of the k -1 higher-priority tasks.\nLemma 2. The worst-case ordering \u03c0 of the k -1 higherpriority tasks under the schedulability condition in Eq. ( 5) in Lemma 1 is to order the tasks in a non-increasing order of \u03b2iCi \u03b1iUi , in which 0 < \u03b1 i and 0 < \u03b2 i for any i = 1, 2, . . . , k -1, 0 < t k .\nProof: This lemma is proved by showing that the schedulability condition in Lemma 1, i.e., 1 -\nk-1 i=1 \u03b1 i U i - k-1 i=1 \u03b2iCi t k + \u03b1iUi( k-1 =i \u03b2 C ) t k\n, is minimized, when the k -1 higher-priority tasks are indexed in a non-increasing order of \u03b2iCi \u03b1iUi . Suppose that there are two adjacent tasks \u03c4 h and \u03c4 h+1 with\n\u03b2 h C h \u03b1 h U h < \u03b2 h+1 C h+1 \u03b1 h+1 U h+1 . Let us now examine the difference of k-1 i=1 \u03b1iUi( k-1 =i \u03b2 C ) t k\nby swapping the index of task \u03c4 h and task \u03c4 h+1 .\nIt can be easily observed that the other tasks \u03c4 i with i = h and i = h + 1 do not change their corresponding values \u03b1 i U i ( k-1 =i \u03b2 C ) in both orderings (before and after swapping \u03c4 h and \u03c4 h+1 ). The difference in the term\n\u03b1 h U h ( k-1 =h \u03b2 C )+\u03b1 h+1 U h+1 ( k-1 =h \u03b2 C\n) before and after swapping tasks \u03c4 and \u03c4 +1 (before -after) is\n((\u03b1 h U h \u03b2 h+1 C h+1 -\u03b1 h+1 U h+1 \u03b2 h C h ) =\u03b1 h \u03b1 h+1 U h U h+1 \u03b2 h+1 C h+1 \u03b1 h+1 U h+1 - \u03b2 h C h \u03b1 h U h > 0.\nTherefore, we reach the conclusion that swapping \u03c4 h and \u03c4 h+1 in the ordering makes the schedulabilty condition more stringent. By applying the above swapping repetitively, we reach the conclusion that ordering the tasks in a non-increasing order of \u03b2iCi \u03b1iUi has the most stringent schedulability condition in Eq. ( 5).\nWe again use the configuration in Example 4 to demonstrate the rationale behind Lemma 2. In this example, let us consider that t 3 = T 3 = 23. When t k = 23, the transformation in Example 1 in fact adopts the last release time ordering \u03c0 2 , i.e., \u03c4 3 is schedulable if C 3 \u2264 0.3t 3 -2.6 = 4.3. The schedulability condition based on the last release time ordering \u03c0 1 , i.e., \u03c4 3 is schedulable if C 3 \u2264 0.3t 3 -2.8 = 4.1, is always worse than that based on \u03c0 2 by Lemma 2. Therefore, it is always safe to use \u03c0 1 , even though it can be sometimes more pessimistic, e.g., when t 3 is 23.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Different Utilization Bounds", "text": "The analysis in Lemma 1 uses the execution time and the utilization of the tasks in hp(\u03c4 k ) to build an upper bound of C k /t k for schedulability tests. It is also very convenient in real-time systems to build schedulability tests only based on utilization of the tasks. We explain how to achieve that in the following lemmas under the assumptions that 0 < \u03b1 i \u2264 \u03b1, and 0 < \u03b2 i C i \u2264 \u03b2U i t k for any i = 1, 2, . . . , k -1. These lemmas are useful when we are interested to derive utilization bounds, speed-up factors, resource augmentation factors, etc., for a given scheduling policy by defining the coefficients \u03b1 and \u03b2 according to the scheduling policies independently from the detailed parameters of the tasks. Since the property repeats in all the statements, we make a formal definition before presenting the lemmas. Definition 4. Lemmas 3 to 5 are based on the following kpoint last-release schedulability test of a scheduling algorithm, defined in Definition 2, in which 0 < \u03b1 i \u2264 \u03b1, and 0\n< \u03b2 i C i \u2264 \u03b2U i t k for any i = 1, 2, . . . , k -1, 0 < t k , \u03b1 k-1 i=1 U i \u2264 1, and \u03b2 k-1 i=1 U i \u2264 1. Lemma 3.\nFor a given k-point last-release schedulability test of a scheduling algorithm, with the properties in Definition 4, task \u03c4 k is schedulable by the scheduling algorithm if the following condition holds\nC k t k \u22641 -(\u03b1 + \u03b2) k-1 i=1 Ui + \u03b1\u03b2 k-1 i=1 Ui( k-1 =i U )(16)\n=1 -(\u03b1 + \u03b2) k-1 i=1 Ui + 0.5\u03b1\u03b2 ( k-1 i=1 Ui) 2 + ( k-1 i=1 U 2 i )(17)\nProof: The condition in Eq. ( 16) comes by reformulating the proof of Lemma 1 with \u03b2U i t * k instead of \u03b2 i C i . All the procedures remain the same, and, therefore, \u03b2 i C i for task \u03c4 i in the right-hand side of Eq. ( 5) can be replaced by \u03b2U i .\nWe focus on the condition in Eq. ( 17) by showing that\nk-1 i=1 U i ( k-1 =i U ) = 0.5 ( k-1 i=1 U i ) 2 + ( k-1 i=1 U 2 i ) . This condition clearly holds when k = 2 since U 2 1 = 0.5(U 2 1 + U 2 1\n). We consider k \u2265 3. This is due to\nk-1 i=1 U i ( k-1 =i U ) = k-1 i=1 U 2 i + k-2 i=1 U i ( k-1 =i+1 U ) = 1 k-1 i=1 U 2 i + 0.5 \uf8eb \uf8ed k-1 i=1 U i 2 - k-1 i=1 U 2 i \uf8f6 \uf8f8 = 0.5 ( k-1 i=1 U i ) 2 + ( k-1 i=1 U 2 i ) ,\nwhere = 1 follows from the fact\nk-2 i=1 U i ( k-1 =i+1 U ) = k-1 i=2 U i ( i-1 =1 U ) = 0.5 k-1 i=1 U i 2 - k-1 i=1 U 2 i .\nLemma 3 provides a schedulability test based on a quadratic form by using only the utilization of the higherpriority tasks with the properties in Definition 4. The following two lemmas are applicable for testing the utilization bound(s), i.e., the summation of the task utilization.\nLemma 4. For a given k-point last-release schedulability test of a scheduling algorithm, with the properties in Definition 4, task \u03c4 k is schedulable by the scheduling algorithm if\nk-1 i=1 Ui \u2264 k -1 k \uf8eb \uf8ed \u03b1 + \u03b2 -(\u03b1 + \u03b2) 2 -2\u03b1\u03b2(1 -C k t k ) k k-1 \u03b1\u03b2 \uf8f6 \uf8f8 .(18)\nProof: This can be formally proved by using the Lagrange Multiplier Method. However, it can also be proved by using a simpler mathematical observation. Suppose that x = k-1 i=1 U i is given. For given \u03b1, \u03b2, and x, we know that Eq. ( 17) becomes 1 -\n(\u03b1 + \u03b2)x + 0.5\u03b1\u03b2(x 2 + k-1 i=1 U 2 i ). That is, only the last term 0.5\u03b1\u03b2( k-1 i=1 U 2 i ) depends on how U i values are actually assigned. Moreover, k-1 i=1 U 2 i is a well-known convex function with respect to U 1 , U 2 , . . . , U k-1 . That is, \u03c1U 2 i + (1 -\u03c1)U 2 j \u2265 (\u03c1U i + (1 -\u03c1)U j ) 2 for any 0 \u2264 \u03c1 \u2264 1.\nTherefore,\nk-1 i=1 U 2 i is minimized when U 1 = U 2 = \u2022 \u2022 \u2022 = U k-1 = x k-1 .\nHence, what we have to do is to find the infimum x such that the condition in Eq. ( 17) does not hold. That is,\ninfimum x s. t. C k t k > 1 -(\u03b1 + \u03b2)x + 0.5\u03b1\u03b2 x 2 + x 2 k -1 .\nThis means that as long as\nk-1\ni=1 U i is no more than such infimum x, the condition in Eq. ( 17) always holds and the schedulability can be guaranteed. Provided that C k t k is given, we can simply solve the above problem by finding the x with\n0 = 1 -C k t k -(\u03b1 + \u03b2)x + 0.5\u03b1\u03b2 k k-1 x 2 .\nThere are two roots in the above quadratic equation. The smaller root, i.e., the righthand side of Eq. ( 18), is the infimum by definition.\nLemma 5. For a given k-point last-release schedulability test of a scheduling algorithm, with the properties in Definition 4, provided that \u03b1 + \u03b2 \u2265 1, then task \u03c4 k is schedulable by the scheduling algorithm if\nC k t k + k-1 i=1 Ui \u2264 \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f3 k-1 k \uf8eb \uf8ed \u03b1 + \u03b2 -(\u03b1 + \u03b2) 2 -2\u03b1\u03b2 k k-1 \u03b1\u03b2 \uf8f6 \uf8f8 , if k > (\u03b1+\u03b2) 2 -1 \u03b1 2 +\u03b2 2 -1 and \u03b1 2 + \u03b2 2 > 1 1 + (k-1)((\u03b1+\u03b2-1)-1 2 (\u03b1+\u03b2) 2 +0.5) k\u03b1\u03b2 otherwise(19)\nProof: The proof is similar to the proof of Lemma 4, but slightly more involved. We detail the proof in Appendix A.\nBy the fact that\n(\u03b1 + \u03b2) 2 -2\u03b1\u03b2 k k-1 = (\u03b1 + \u03b2) 2 -2\u03b1\u03b2 -2\u03b1\u03b2 1 k-1\n, which is an increasing function with respect to k, and the fact that k-1 k is a decreasing function with respect to k, we know that the right-hand side of Eq. ( 19) (when \u03b1 2 + \u03b2 2 > 1) decreases with respect to k. Similarly, the right-hand side of Eq. ( 18) also decreases with respect to k. Therefore, for evaluating the utilization bounds, it is alway safe to take k \u2192 \u221e as a safe upper bound. The right-hand side of Eq. ( 18) converges to\n\u03b1+\u03b2-\u03b1 2 +\u03b2 2 +2\u03b1\u03b2 C k t k \u03b1\u03b2 when k \u2192 \u221e. The right-hand side of Eq. (19) (when \u03b1 2 + \u03b2 2 > 1) converges to \u03b1+\u03b2- \u221a \u03b1 2 +\u03b2 2 \u03b1\u03b2 when k \u2192 \u221e.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Response Time Analysis Framework", "text": "We now further discuss the utilization-based response-time analysis framework. Lemma 6. For a given k-point response time analysis, defined in Definition 3, of a scheduling algorithm, in which 0\n< \u03b1 i \u2264 \u03b1, 0 < \u03b2 i \u2264 \u03b2 for any i = 1, 2, . . . , k -1, 0 < t k and k-1 i=1 \u03b1 i U i < 1, the response time to execute C k for task \u03c4 k is at most C k + k-1 i=1 \u03b2 i C i - k-1 i=1 \u03b1 i U i ( k-1 =i \u03b2 C ) 1 - k-1 i=1 \u03b1 i U i . (20\n)\nProof: The proof is similar to the proof of Lemma 1. The detailed proof is in Appendix A. Not all the last release time orderings are safe for the worstcase response time analysis. Fortunately, similar to Lemma 2, we can safely consider only one specific last release time ordering of the k -1 higher-priority tasks as shown in the following lemma.\nLemma 7. The worst-case ordering \u03c0 of the k -1 higherpriority tasks under the response bound in Eq. (20) in Lemma 6 is to order the tasks in a non-increasing order of \u03b2iCi \u03b1iUi , in which 0 < \u03b1 i and 0 < \u03b2 i for any i = 1, 2, . . . , k -1, 0 < t k .\nProof: The ordering of the k -1 higher-priority tasks in the indexing rule only matters for the term\nk-1 i=1 \u03b1 i U i ( k-1 =i \u03b2 C\n), which was already proved in the proof of Lemma 2 to be minimized by ordering the tasks in a non-increasing order of \u03b2iCi \u03b1iUi . Clearly, the minimization of\nk-1 i=1 \u03b1 i U i ( k-1 =i \u03b2 C\n) also leads to the maximization of Eq. (20), which concludes the proof.\nAs a result, thanks to the help of Lemma 7, we can conclude that \u03c0 1 in the example in this subsection is a safe last release time ordering to use Lemma 6 for the worst-case response time analysis.", "publication_ref": ["b19"], "figure_ref": [], "table_ref": []}, {"heading": "Applications by Using Sporadic Task Models", "text": "This section demonstrates how to use the k 2 Q framework to derive utilization-based schedulability and responsetime analyses for sporadic task systems in uniprocessor and multiprocessor systems. As sporadic real-time task models are the simplest scenarios that can demonstrate how to use k 2 Q, the content here is merely for explaining how to use the framework, but not for demonstrating the generality or superiority of k 2 Q.", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Uniprocessor Constrained-Deadline Systems", "text": "Theorem 1. Task \u03c4 k in a sporadic task system with constrained deadlines is schedulable by the fixed-priority scheduling algorithm if\nk-1 i=1 Ci D k \u2264 1 and C k D k \u2264 1 - k-1 i=1 U i - k-1 i=1 C i D k + k-1 i=1 U i ( k-1 =i C ) D k ,(21)\nin which the k -1 higher-priority tasks in hp 1 (\u03c4 k ) are indexed in a non-increasing order of T i .\nProof: This comes from Lemma 1 and 2 based on the setting \u03b1 i = 1 and \u03b2 i = 1 to satisfy Definition 2. 4Theorem 2. Task \u03c4 k in a sporadic constrained-deadline task system with is schedulable by the rate-monotonic (RM) scheduling algorithm if\nC k D k \u2264 1 -2 k-1 i=1 U i + 0.5 ( k-1 i=1 U i ) 2 + ( k-1 i=1 U 2 i )(22)\nor\nk-1 i=1 U i \u2264 k -1 k \uf8eb \uf8ed 2 -4 - 2k(1 -C k D k ) k -1 \uf8f6 \uf8f8 (23\n)\nor\nC k D k + k-1 i=1 U i \u2264 k-1 k 2 -4 -2k k-1 if k > 3 1 -k-1 2k if k \u2264 3(24)\nProof: Under RM scheduling, we know that\nC i = U i T i \u2264 U i T k .\nTherefore, \u03b1 can be set to 1 and \u03b2 can be set to 1 in Definition 4. Eq. ( 22) is due to Lemma 3, Eq. ( 23) is due to Lemma 4, and Eq. ( 24) is due to Lemma 5.\nThe above result in Theorem 2 leads to the utilization bound 2-\u221a 2 for implicit-deadline sporadic task systems under RM scheduling. This analysis is less precise than the Liu and Layland bound ln 2 \u2248 0.693, a simple implication by using k 2 U. However, if we are allowed to change the execution time and period of a task for different job releases (called acyclic task model in [1]), then the tight utilization bound 2 -\u221a 2 can be easily achieved by using k 2 Q, detailed in Appendix F.", "publication_ref": ["b0"], "figure_ref": [], "table_ref": []}, {"heading": "Uniprocessor Arbitrary-Deadline Systems", "text": "For a specified fixed-priority scheduling algorithm, let hp(\u03c4 k ) be the set of tasks with higher priority than \u03c4 k . We now classify the task set hp(\u03c4 k ) into two subsets: ", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "TABLE I:", "text": "The \u03b1i and \u03b2i parameters in our demonstrated task models.\n\u2022 hp 1 (\u03c4 k ) consists of the higher-priority tasks with periods smaller than D k . \u2022 hp 2 (\u03c4 k ) consists of the higher-priority tasks with periods larger than or equal to D k .\nThe exact schedulability analysis for arbitrary-deadline task sets under fixed-priority scheduling has been developed in [34]. The schedulability analysis is to use a busy-window concept to evaluate the worst-case response time. That is, we release all the higher-priority tasks together with task \u03c4 k at time 0 and all the subsequent jobs are released as early as possible by respecting to the minimum inter-arrival time. The busy window finishes when a job of task \u03c4 k finishes before the next release of a job of task \u03c4 k . It has been shown in [34] that the worstcase response time of task \u03c4 k can be found in one of the jobs of task \u03c4 k in the busy window.\nFor the h-th job of task \u03c4 k in the busy window, the finishing time R k,h is the minimum t such that\nhC k + k-1 i=1 t T i C i \u2264 t,\nand, hence, its response time is R k,h -(h -1)T k . The busy window of task \u03c4 k finishes on the h-th job if R k,h \u2264 hT k .\nWe can create a virtual sporadic task \u03c4 k with execution time\nC k = D k T k C k + \u03c4i\u2208hp2(\u03c4 k ) C i , relative deadline D k = D k ,\nand period T k = D k . For notational brevity, suppose that there are k * -1 tasks in hp 1 (\u03c4 k ). We have then the following theorem.\nTheorem 3. Task \u03c4 k in a sporadic task system is schedulable by the fixed-priority scheduling algorithm if\nk * -1 i=1 Ci D k \u2264 1 and C k D k \u2264 1- k * -1 i=1 U i - k * -1 i=1 C i D k + k * -1 i=1 U i ( k * -1 =i C ) D k ,(25)\nin which C k = D k T k C k + \u03c4i\u2208hp2(\u03c4 k ) C i ,\nand the k * -1 higher-priority tasks in hp 1 (\u03c4 k ) are indexed in a nondecreasing order of\nD k Ti -1 T i .\nProof: The analysis is based on the observation to test whether the busy window can finish within interval length D k , which was also adopted in [22] and [20]. By setting t i = D k Ti -1 T i , and indexing the tasks in a non-decreasing order of t i leads to the satisfaction of Definition 2 with \u03b1 i = 1 and \u03b2 i = 1.\nAnalyzing the schedulability by using Theorem 3 can be good if D k T k is small. However, as the busy window may be stretched when D k T k is large, we further present how to safely estimate the worst-case response time. Suppose that t j = R k,h Tj -1 T j for a higher-priority task \u03c4 j . We index the tasks such that the last release ordering \u03c0 of the k -1 higher-priority tasks is with t j \u2264 t j+1 for j = 1, 2, . . . , k -2. Therefore, we know that R k,h is upper bounded by finding the maximum\nt k = hC k + k-1 i=1 t i U i + k-1 i=1 C i ,(26)\nwith 0 \u2264 t 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 t k and hC k + k-1 i=1 t i U i + j-1 i=1 C i > t j ,\u2200j = 1, 2, . . . , k -1.(27)\nTherefore, the above derivation of R k,h satisfies Definition 3 with \u03b1 i = 1, and \u03b2 i = 1 for any higher-priority task \u03c4 i . However, it should be noted that the last release time ordering \u03c0 is actually unknown since R k,h is unknown. Therefore, we have to apply Lemma 7 for such cases to obtain the worst-case release time ordering, i.e., the k -1 higher-priority tasks are ordered in a non-increasing order of their periods.\nLemma 8. Suppose that\nk-1 i=1 U i \u2264 1.\nThen, for any h \u2265 1 and C k > 0, we have\nR k,h \u2264 hC k + k-1 i=1 C i - k-1 i=1 U i ( k-1 =i C ) 1 - k-1 i=1 U i , (28\n)\nwhere the k -1 higher-priority tasks are ordered in a nonincreasing order of their periods.\nProof: This comes from the above discussions with \u03b1 i = 1, \u03b2 i = 1 by applying Lemmas 6 and 7 when\nk-1 i=1 U i < 1. The case when k-1 i=1 U i = 1 has a safe upper bound R k,h = \u221e in Eq. (28). Theorem 4. Suppose that k i=1 U i \u2264 1. The worst-case response time of task \u03c4 k is at most R k \u2264 C k + k-1 i=1 C i - k-1 i=1 U i ( k-1 =i C ) 1 - k-1 i=1 U i , (29\n)\nwhere the k -1 higher-priority tasks are ordered in a nonincreasing order of their periods.\nProof: This can be proved by showing that R k,h -(h -1)T k is maximized when h is 1, where R k,h is derived by using Lemma 8. The first-order derivative of R k,h -(h -1)T k with respect to h is\nC k 1-k-1 i=1 Ui -T k = C k -(1-k-1 i=1 Ui)T k 1-k-1 i=1 Ui\n. There are two cases:\nCase 1: If k i=1 U i < 1, then C k -(1-k-1 i=1 Ui)T k 1-k-1 i=1 Ui < C k -U k T k 1-k-1 i=1 Ui = 0. Therefore, R k,h -(h -1)\nT k is a decreasing function of h. Therefore, the response time is maximized when h is 1.\nCase 2: If k i=1 U i = 1, then we know that C k -(1-k-1 i=1 Ui)T k 1-k-1 i=1 Ui = 0. Therefore, R k,h -(h -1)T k remains the same regardless of h.\nTherefore, for both cases, the worst-case response time of task \u03c4 k can be safely bounded by Eq. ( 29). Moreover, since the worst case happens when h = 1, we do not have to check the length of the busy window, and we reach our conclusion.\nCorollary 1. Task \u03c4 k in a sporadic task system is schedulable by the fixed-priority scheduling algorithm if\nk i=1 U i \u2264 1 and C k D k \u2264 1 - k-1 i=1 U i - k-1 i=1 C i D k + k-1 i=1 U i ( k-1 =i C ) D k ,(30)\nwhere the k -1 higher-priority tasks are ordered in a nonincreasing order of their periods.", "publication_ref": ["b33", "b33", "b21", "b19"], "figure_ref": [], "table_ref": []}, {"heading": "Remarks:", "text": "The utilization-based worst-case response-time analysis in Theorem 4 is analytically tighter than the best known result, R k \u2264\nC k + k-1 i=1 Ci-k-1 i=1 UiCi 1-k-1 i=1 Ui\n, by Bini et al. [14]. Lehoczky [34] also provides the total utilization bound of RM scheduling for arbitrary-deadline systems. The analysis in [34] is based on the Liu and Layland analysis [39]. The resulting utilization bound is a function of \u2206 = max \u03c4i { Di Ti }. When \u2206 is 1, it is an implicit-deadline system. The utilization bound in [34] has a closed-form when \u2206 is an integer. However, calculating the utilization bound for non-integer \u2206 is done asymptotically for k = \u221e with a complicated analysis.", "publication_ref": ["b13", "b33", "b33", "b38", "b33"], "figure_ref": [], "table_ref": []}, {"heading": "Multiprocessor Implicit-Deadline Systems", "text": "We now present how to use k 2 Q to analyze the schedulability for implicit-deadline sporadic task systems under global rate-monotonic (global RM) scheduling. Here, we start from the pseudo-polynomial-time schedulability test by Guan et al. [29] that we only have to consider M -1 tasks with carryin jobs, for constrained-deadline (hence, also for implicitdeadline) task sets. More precisely, we can define two different time-demand functions, depending on whether task \u03c4 i is with a carry-in job or not: 5\nW carry i (t) = C i 0 < t < C i C i + t-Ci Ti C i otherwise,(31)\nand\nW normal i (t) = t T i C i .(32)\nMoreover, we can further over-approximate W carry i (t), since W carry i (t) \u2264 W normal i (t)+C i . Therefore, a sufficient schedulability test for testing task \u03c4 k with k > M for global RM is to verify whether\n\u22030 < t \u2264 T k , C k + ( \u03c4i\u2208T C i ) + ( k-1 i=1 W normal i (t)) M \u2264 t. (33\n)\n5 This is an over-approximation of the linear function used by Guan et al. [29].\nfor all T \u2286 hp(\u03c4 k ) with |T | = M -1.\nThis leads to the following theorem by using Lemma 1.\nTheorem 5. Task \u03c4 k in a sporadic implicit-deadline task system is schedulable by global RM on M processors if\nk-1 i=1 C i \u2264 M T k and U k \u2264 1- \u03c4 i \u2208T Ci M T k - k-1 i=1 Ui M - k-1 i=1 Ci M T k + k-1 i=1 (Ui k-1 =i C ) M 2 T k . (34\n)\nby indexing the k -1 higher-priority tasks in a non-decreasing order of ( T k Ti -1)T i for every \u03c4 i \u2208 hp(\u03c4 k ) and by putting the M -1 higher-priority tasks with the largest execution times into T . Proof: It is not necessary to enumerate all T \u2286 T with |T | = M -1 if we can construct the task set T \u2286 hp(\u03c4 k ) with the maximum \u03c4i\u2208T C i . To use k 2 Q, we are certain about which tasks should be put into the carry-in task set T by assuming that C i and T i are both given. That is, we simply have to put the M -1 higher-priority tasks with the largest execution times into T . This can be imagined as if we increase the execution time of task\n\u03c4 k from C k to C k = C k + \u03c4 i \u2208T Ci M . Moreover, we have \u03b1 i = 1 M and \u03b2 i = 1 M for every task \u03c4 i \u2208 hp(\u03c4 k ) in this case.\nTherefore, based on the test in Eq. ( 33), we have the last release time ordering defined by indexing the k -1 higherpriority tasks in a non-decreasing order of ( T k Ti -1)T i for every \u03c4 i \u2208 hp(\u03c4 k ). By adopting Lemma 1 with \u03b1 i = 1 M and\n\u03b2 i = 1 M , we know that task \u03c4 k is schedulable by global RM if k-1 i=1 Ci M \u2264 T k and C k + \u03c4 i \u2208T C i M T k \u2264 1- k-1 i=1 Ui M - k-1 i=1 Ci M T k + k-1 i=1 (Ui k-1 =i C ) M 2 T k .(35)\nBy reorganizing the above inequality, we reach the conclusion.\nWe can always take the pessimistic last release time ordering in Lemma 2, for concluding the following theorem. Theorem 6. Task \u03c4 k in a sporadic implicit-deadline task system is schedulable by global RM on M processors if the condition in Eq. (34) holds by indexing the k-1 higher-priority tasks in a non-increasing order of T i , for every \u03c4 i \u2208 hp(\u03c4 k ).\nProof: This is proved based on the same argument in Theorem 5 by adopting Lemmas 1 and 2.\nWe can of course revise the statement in Theorems 5 and 6 by adopting Lemma 3 and Lemma 4 to construct schedulability tests by using only the utilization of the higher-priority tasks.", "publication_ref": ["b28", "b28"], "figure_ref": [], "table_ref": []}, {"heading": "Evaluation Results", "text": "We conduct experiments using synthesized task sets for evaluating the tests in Theorem 5 and Theorem 6. We first generated a set of sporadic tasks. The cardinality of the task set was 5 times the number of processors, i.e., 40 tasks on 8 multiprocessor systems. The UUniFast-Discard method [23] was adopted to generate a set of utilization values with the given goal. We used the approach suggested by Davis et al. [25] to generate the task periods according to a uniform distribution in the range of the logarithm of the task periods (i.e., log-uniform distribution). The order of magnitude p to control the period values between the largest and smallest periods is parameterized in evaluations, (e.g., 1 -10ms for p = 1, 1 -100ms for p = 2, etc.). We evaluate these tests in uniprocessor systems with p \u2208 [1,2,3]. The execution time was set accordingly, i.e., C i = T i U i . Tasks' relative deadlines were equal to their periods.\nThe evaluated tests for n tasks in T with n \u2265 M are:\n\u2022 BCL: the linear-time test in Theorem 4 in [11].\n\u2022 FF: the pseudo-polynomial-time forced-forward (FF) analysis in Eq. ( 5) in [7]. \u2022 BAK: the O(n 3 ) test in Theorem 11 in [5].\n\u2022 Guan: the pseudo-polynomial-time response time analysis [29]. 34) in Theorem 5. This requires to sort the higher-priority tasks to define the proper last release ordering and the M -1 carry-in jobs; therefore, the time complexity is O(n 2 log n) for a task set with n tasks. \u2022 QB-BC2 (from k 2 Q): Eq. ( 34) in Theorem 6 by always using the worst-case release time ordering, which is the reverse order of the given priority assignment. The schedulability test can be implemented in O(n log M ) time complexity by using proper data structures, provided that the RM priority order is given. 6   Figure 2 depicts the result of the performance comparison. In all the cases, we can see that QB-BC is superior to all the other polynomial-time tests. QB-BC2 is slightly worse than QB-BC but the time complexity is lower. Since QB-BC and QB-BC2 are designed from a more pessimistic test than the analysis by Guan et al. [29] in pseudo-polynomial time, they are worse. But, we note that there is a significant gap in time complexity between QB-BC, QB-BC2, and Guan. Overall, the tests derived by using the k 2 Q framework perform reasonably well with their low time complexity.\n\u2022 QB-BC (from k 2 Q): Eq. (", "publication_ref": ["b22", "b24", "b0", "b1", "b2", "b10", "b6", "b4", "b28", "b28"], "figure_ref": ["fig_3"], "table_ref": []}, {"heading": "Conclusion and Extensions", "text": "In this paper, we present a general response-time analysis and schedulability-test framework, called k 2 Q. Thanks to the independence upon the task and platform models in the framework, k 2 Q can be viewed as a \"block-box\" interface that can result in sufficient utilization-based analyses for a wide range of applications in real-time systems under fixedpriority scheduling. We believe that the k 2 Q framework has high potential to be adopted to solve several other problems for analyzing other task models in real-time systems with fixedpriority scheduling. The framework can be used, once the 6 The time complexity is mainly due to the calculation of T to get the M -1 tasks with the maximum carry-in execution time since the other operations can be done in O(1) time complexity by using proper data structures to calculate the values when we intend to test task \u03c4 k+1 after task \u03c4 k . Specifically, due to the predefined last release time ordering, when we intend to test task \u03c4 k+1 after task \u03c4 k , we only have to insert task \u03c4 k to be indexed as 1 and updating\nfrom k-1 i=1 (U i k-1 =i C ) M 2 T k to k i=1 (U i k =i C ) M 2 T k\n(under the new ordering) takes only constant time complexity. Finding task set T can be implemented by using a min heap to store the M -1 tasks in T . When we move from testing task \u03c4 k (when k \u2265 M ) to task \u03c4 k+1 , we need to compare whether C k is larger than the minimum execution time of the tasks in the heap. If no, we keep the same task set T ; if yes, we pop out the task with the minimum execution time in the heap, and insert task \u03c4 k into the heap. By using the heap, this operation requires time complexity O(log M ). Calculating C k+1 from C k with the help of the heap can be done in O(1) time complexity.\ncorresponding k-point last-release scheduling test or response time analysis can be constructed. Moreover, our proposed frameworks, k 2 U and k 2 Q, provide a solid mathematical foundation for deriving polynomialtime utilization-based schedulability tests and response time analyses almost automatically. That is, utilization-based analyses are almost automatically derived if the schedulability tests can be formulated in the scope of the frameworks. We have demonstrated several applications in this paper. Some models have introduced pretty high dynamics, but we can still handle the response time analysis and schedulability test with proper constructions so that the k 2 Q framework is applicable. Therefore, with the presented approach, some difficult schedulability test and response time analysis problems may be solved by building a good (or exact) exponential-time test and using the approximation in the k 2 Q framework. With the quadratic and hyperbolic expressions, k 2 Q and k 2 U frameworks can be used to provide many quantitive features to be measured, like the total utilization bounds, speed-up factors, etc., not only for uniprocessor scheduling but also for multiprocessor scheduling.\nWhen adopting k 2 Q for schedulability tests, we assume that t k is specified in Lemma 1. In this paper, we do not explore how to configure the best value of t k and its last release time ordering \u03c0 such that the resulting quadratic form is the best. Therefore, the combination of k 2 Q/k 2 U and the tunable approach by Bini and Buttazzo [12] can be an interesting future research direction, as this can potentially balance the schedulability test and the time complexity for concrete applications. Appendix A: Proofs Proof of Lemma 5. Similar to the proof of Lemma 4, we only have to consider the cases when U i is set to x k-1 to make the schedulability condition the most difficult, where x = k-1 i=1 U i . Suppose that C k t k is y. Then, we are looking for the infimum x + y such that y > 1 -(\u03b1 + \u03b2)x + 0.5\u03b1\u03b2(x 2 + x 2 k-1 ). To solve this, we start with y = 1-(\u03b1+\u03b2)x+0.5\u03b1\u03b2(x 2 + x 2 k-1 ). Our objective becomes to minimize\nH(x) = x + 1 - (\u03b1 + \u03b2)x + 0.5\u03b1\u03b2(x 2 + x 2 k-1 ). By finding dH(x) dx = 1 -(\u03b1 + \u03b2) + k\u03b1\u03b2x k-1 = 0, we know that x = (k-1)(\u03b1+\u03b2-1)", "publication_ref": ["b11"], "figure_ref": [], "table_ref": []}, {"heading": "k\u03b1\u03b2", "text": ". Therefore,\ny =1 -x \u03b1 + \u03b2 - 0.5k\u03b1\u03b2 (k-1)(\u03b1+\u03b2-1) k\u03b1\u03b2 k -1 =1 - (k -1)(\u03b1 + \u03b2 -1) k\u03b1\u03b2 (0.5(\u03b1 + \u03b2 + 1)) =1 - 0.5(k -1) (\u03b1 + \u03b2) 2 -1 k\u03b1\u03b2 . (36\n)\nSince \u03b1+\u03b2 \u2265 1, we know that x \u2265 0. Whether we should take the above solution only depends on whether y \u2265 0 or not. If y \u2265 0, then we can conclude the solution directly; otherwise, if y < 0, we should set y to 0. That is, by reorganizing Eq. ( 36) (under the assumption \u03b1 > 0 and \u03b2 > 0), examining whether 2 -1 due to the assumption \u03b1+\u03b2 \u2265 1. Therefore, there are two cases:\ny < 0 is equivalent to testing (1 -1 k ) (\u03b1 + \u03b2) 2 -1 > 2\u03b1\u03b2, which implies to test whether \u03b1 2 +\u03b2 2 -1 > 1 k (\u03b1 + \u03b2) 2 -1 . If \u03b1 2 + \u03b2 2 \u2264 1, then y \u2265 0 since \u03b1 2 + \u03b2 2 -1 \u2264 0 \u2264 1 k (\u03b1 + \u03b2)\nCase 1: If \u03b1 2 + \u03b2 2 > 1 and k > (\u03b1+\u03b2) 2 -1 \u03b1 2 +\u03b2 2 -1\n, then, for such a case y derived from Eq. ( 36) is negative. We should set y to 0. The remaining procedure here is the same as in solving the quadratic equation in the proof of Lemma 4 by setting C k t k to 0. This leads to the first condition in Eq. (19).\nCase 2: If \u03b1 2 + \u03b2 2 \u2264 1 or k \u2264 (\u03b1+\u03b2) 2 -1 \u03b1 2 +\u03b2 2 -1\n, then, we have the conclusion that y \u2265 0 and x \u2265 0. We just have to sum up the above derived x and y. This leads to the second condition in Eq. ( 19) directly.\nProof of Lemma 6. Definition 3 leads to the following optimization problem:\nsup C k + k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i (37a) such that C k + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i > t * j , \u2200j = 1, . . . , k -1, (37b) t * j \u2265 0, \u2200j = 1, . . . , k -1,(37c)\nwhere t * 1 , t * 2 , . . . , t * k-1 and are variables, \u03b1 i , \u03b2 i , U i , C i for higher-priority task \u03c4 i and C k are constants. For the rest of the proof, we replace > with \u2265 in Eq. ( 37), as the supermum and the maximum are the same when presenting the inequality with \u2265. We can also further drop the condition t * j \u2265 0, which just makes the resulting solution more pessimistic. This results in the following linear programming, which has a safe upper bound of Eq. ( 37),\nmaximize C k + k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i (38a) such that C k + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i \u2265 t * j , \u2200j = 1, . . . , k -1. (38b)\nThe linear programming in Eq. ( 38) (by replacing > with \u2265 and supremum with maximum) has k -1 variables and k -1 constraints. Like the proof of Lemma 1, we again adopt the extreme point theorem for linear programming [40] to solve the linear programming. Suppose that t\n\u2020 1 , t \u2020 2 , . . . , t \u2020 k-1\nis a feasible solution for the linear programming in (38) and\nt = max{t \u2020 1 , t \u2020 2 , . . . , t \u2020 k-1 }.\nBy the satisfaction of Eq. (38b), we know that\nC k + t k-1 i=1 \u03b1 i U i + k-1 i=1 \u03b2 i C i \u2265 C k + k-1 i=1 \u03b1 i t \u2020 i U i + k-1 i=1 \u03b2 i C i \u2265 t.\nAs a result, we have t \u2264\nC k + k-1 i=1 \u03b2iCi 1-k-1 i=1 \u03b1iUi . That is, any feasible solution of Eq. (38) has t * j \u2264 C k + k-1 i=1 \u03b2iCi 1-k-1 i=1 \u03b1iUi for any j = 1, 2, . . . , k -1. Under the assumption that k-1 i=1 \u03b1 i U i < 1 and 0 \u2264 k-1 i=1 \u03b2 i C i ,\nthe above linear programming has a bounded objective function.\nThe only extreme point solution is to put\nC k + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i = t * j for every j = 1, 2, . . . , k -1.\nSince the objective function is bounded, by the extreme point theorem [40], we know that this extreme point solution is the optimal solution for the linear programming in Eq. (38). For such a solution, we know that\n\u2200j = 2, 3, . . . , k -1, t * j -t * j-1 = \u03b2 j-1 C j-1 .(39)\nand\nt * 1 = C k + k-1 i=1 \u03b1 i U i (t * 1 + i-1 =0 \u03b2 C ),(40)\nwhere \u03b2 0 and C 0 are defined as 0 for notational brevity. Therefore, we know that\nt * 1 = C k + k-1 i=1 \u03b1 i U i ( i-1 =0 \u03b2 C ) 1 - k-1 i=1 \u03b1 i U i .(41)\nClearly, the above extreme point solution is always feasible when\nk-1 i=1 \u03b1 i U i < 1.\nTherefore, in this extreme point solution, the objective function of the linear programming is\nt * 1 + k-1 i=1 \u03b2 i C i = C k + k-1 i=1 \u03b1 i U i ( i-1 =0 \u03b2 C ) 1 -k-1 i=1 \u03b1 i U i + k-1 i=1 \u03b2 i C i(42)\n= C k + k-1 i=1 \u03b2 i C i -k-1 i=1 \u03b1 i U i ( k-1 =i \u03b2 C ) 1 -k-1 i=1 \u03b1 i U i(43)\nwhich concludes the proof.\nuniprocessor systems, the time-demand analysis (TDA) developed in [35] can be adopted. That is, if\n\u2203t with 0 < t \u2264 D k and C k + \u03c4i\u2208hp(\u03c4 k ) t T i C i \u2264 t,(44)\nthen task \u03c4 k is schedulable under the fixed-priority scheduling algorithm, where hp(\u03c4 k ) is the set of tasks with higher priority than \u03c4 k , D k , C k , and T i represent \u03c4 k 's relative deadline, worst-case execution time, and period, respectively. For a constrained-deadline task \u03c4 k , the schedulability test in Eq. ( 44) is equivalent to the verification of the existence of 0 < t \u2264 D k such that\nC k + \u03c4i\u2208hp2(\u03c4 k ) C i + \u03c4i\u2208hp1(\u03c4 k ) t T i C i \u2264 t.(45)\nWe can then create a virtual sporadic task \u03c4 k with execution time\nC k = C k + \u03c4i\u2208hp2(\u03c4 k ) C i , relative deadline D k = D k , and period T k = D k .\nIt is clear that the schedulability test to verify the schedulability of task \u03c4 k under the interference of the higher-priority tasks hp 1 (\u03c4 k ) is the same as that of task \u03c4 k under the interference of the higher-priority tasks hp(\u03c4 k ).\nFor notational brevity, suppose that there are k * -1 tasks in hp 1 (\u03c4 k ).\nTheorem 7. Task \u03c4 k in a sporadic task system with constrained deadlines is schedulable by the fixed-priority scheduling algorithm if\nk * -1 i=1 Ci D k \u2264 1 and C k D k \u2264 1- k * -1 i=1 U i - k * -1 i=1 C i D k + k * -1 i=1 U i ( k * -1 =i C ) D k ,(46)\nin which the k * -1 higher-priority tasks in hp 1 (\u03c4 k ) are indexed in a non-decreasing order of\nD k Ti -1 T i .\nProof:\nSetting t i = D k Ti\n-1 T i , and indexing the tasks in a non-decreasing order of t i leads to the satisfaction of Definition 2 with \u03b1 i = 1 and \u03b2 i = 1.\nCorollary 2. Task \u03c4 k in a sporadic task system with implicit deadlines is schedulable by the RM scheduling algorithm if Lemmas 1, 3, 4, or 5 holds by setting C k t k as U k , \u03b1 = 1, and \u03b2 = 1.\nThe above result in Corollary 2 leads to the utilization bound 2 -\u221a 2 (by using Lemma 5 with \u03b1 = 1 and \u03b2 = 1) for RM scheduling, which is worse than the existing Liu and Layland bound ln 2 [39].", "publication_ref": ["b18", "b39", "b37", "b39", "b37", "b34", "b38"], "figure_ref": [], "table_ref": []}, {"heading": "Appendix C: Multiprocessor DM/RM Scheduling", "text": "This part demonstrates how to use the k 2 Q framework for multiprocessor global fixed-priority scheduling. We consider that the system has M identical processors. For global fixedpriority scheduling, there is a global queue and a global scheduler to dispatch jobs. We demonstrate the applicability for constrained-deadline and implicit-deadline sporadic systems under global fixed-priority scheduling. Specifically, we will present how to apply the framework to obtain speed-up and capacity augmentation factors for global DM and global RM.\nThe success of the scheme depends on a corresponding exponential-time test. Here we will use the property to be presented in Lemma 9, based on the forced-forward algorithm proposed by Baruah et al. [7] to characterize the workload of higher-priority tasks. The method in [7] to analyze fixedpriority scheduling is completely different from ours, as they rely on the demand bound functions of the tasks.\nThe following lemma provides a sufficient test based on the observations by Baruah et al. [7]. The construction of the following lemma is based on a minor change of the forcedforward algorithm.\nLemma 9. Let \u2206 max k be max k-1 j=1 {U j , C k D k }.\nTask \u03c4 k in a sporadic task system with constrained deadlines is schedulable by a global fixed-priority (workload conserving) scheduling algorithm on M processors if\n\u2200y \u2265 0, (\u22000 \u2264 \u03c9 i \u2264 T i , \u2200\u03c4 i \u2208 hp(\u03c4 k )) , \u2203t with 0 < t \u2264 D k + y such that \u2206 max k \u2022 (D k + y) + k-1 i=1 \u03c9 i \u2022 U i + t-\u03c9i Ti C i M \u2264 t.\nProof: This is proved by contrapositive. If task \u03c4 k is not schedulable by the global fixed-priority scheduling, we will show that there exist y \u2265 0 and 0\n\u2264 \u03c9 i \u2264 T i such that for all 0 < t \u2264 D k + y, the condition \u2206 max k \u2022 (D k + y) + k-1 i=1 \u03c9i\u2022Ui+ t-\u03c9 i T i Ci M > t holds.\nThe proof is mainly based on the forced-forward algorithm for the analysis of global DM by Baruah et al. in [7], by making some further annotations.\nIf \u03c4 k is not schedulable by global DM, let z 0 be the first time at which task \u03c4 k misses its absolute deadline, i.e., z 0 . Let z 1 be the arrival time of this job of task \u03c4 k . For notational brevity, let this job be J 1 , which arrives at time z 1 and has not yet been finished at time z 0 . By definition, we know that z 0 -z 1 is D k . Due to the fixed-priority and workload-conserving scheduling policy and the constraineddeadline setting, removing (1) all the other jobs of task \u03c4 k (except the one arriving at time z 1 ), (2) all the jobs arriving no earlier than z 0 , and (3) lower-priority jobs does not change the unschedulability of job J 1 . Therefore, the rest of the proof only considers the jobs from \u03c4 1 , \u03c4 2 , . . . , \u03c4 k . Now, we expand the window of interest by using a slightly different algorithm from that proposed in [7], also illustrated with the notation in Figure 3, as in Algorithm 1. The difference is only in the setting \"strictly less than (z -1 -z ) \u2022 \u00db units\", whereas the setting in [7] uses \"strictly less than (z -1 -z ) \u2022 s units\" for a certain s. For notationaly brevity, \u00db is the utilization of the task that generates job J .\nAlgorithm 1 (Revised) Forced-Forward Algorithm 1: for \u2190 2, 3, ... do 2:\nlet J denote a job that arrives at some time-instant z < z -1 ; -has an absolute deadline after z -1 ; -has not completed execution by z -1 ; and has executed for strictly less than (z -1 -z ) \u2022 \u00db units over the interval [z , z -1 ), where \u00db is the utilization of the task that generates job J .", "publication_ref": ["b6", "b6", "b6", "b6", "b6", "b6"], "figure_ref": ["fig_5"], "table_ref": []}, {"heading": "3:", "text": "if there is no such a job then 4:\n\u2190 ( -1); break;\nSuppose that the forced-forward algorithm terminates with equals to * . We now examine the schedule in the interval (z * , z 0 ]. Since J 1 , J 2 , . . . , J * belong to \u03c4 1 , \u03c4 2 , . . . , \u03c4 k , we know that \u00db \u2264 \u2206 max k for = 1, 2, . . . , * . Let \u03c3 be the total length of the time interval over (z , z -1 ] during which J is executed. By the choice of J , it follows that\n\u03c3 < (z -1 -z ) \u2022 \u00db \u2264 (z -1 -z ) \u2022 \u2206 max k .\nMoreover, all the M processors execute other higher-priority jobs (than J ) at any other time points in the interval (z , z -1 ] at which J is not executed. Therefore, we know that the maximum amount of time from z * to z 0 , in which not all the M processors execute certain jobs, is at most\n* =1 \u03c3 < * =1 (z -1 -z ) \u2022 \u2206 max k = (z 0 -z * ) \u2022 \u2206 max k .\nUp to here, the treatment is almost identical to that in \"Observation 1\" in [7]. The following analysis becomes different as we do not intend to use the demand bound function. Now, we replace job J 1 with another job J 1 with inflated execution time in the above schedule, where J 1 is released at time z * with absolute deadline z 0 and execution time (z 0 -z * ) \u2022 \u2206 max k . According to the above analysis, J 1 cannot be finished before z 0 in the above schedule. For each task \u03c4 i for i = 1, 2, . . . , k -1, in the above schedule, there may be one carry-in job, denoted as J i , of \u03c4 i (under the assumption of the schedulability of a higher-priority task \u03c4 i ) that arrives at time r i with r i < z * and r i + T i > z * . Let d i be the next released time of task \u03c4 i after z * , i.e., d i = r i + T i .\nAccording to the termination condition in the construction of z * , if J i exists, we know that at least (z * -r i ) \u2022 U i amount of execution time has been executed before z * , and the remaining execution time of job J i to be executed after z * is at most (d i -z * ) \u2022 U i . If J i does not exist, then d i is set to z * for notational brevity. Therefore, the amount of workload W i (t) of all the released jobs of task \u03c4 i for i = 1, 2, . . . , k -1 to be executed in time interval (z * , z * + t) is at most\nW i (t) = (d i -z * ) \u2022 U i + t -(d i -z * ) T i C i .(47)\nThe assumption of the unschedulability of job J 1 (due to the unschedulability of job J 1 ) under the global fixed-priority scheduling implies that J 1 cannot finish its computation at any time between z * and z 0 . This leads to the following\n(necessary) condition \u2206 max k (z 0 -z * ) + \u03c4 i \u2208hp(\u03c4 k ) W i (t) M > t for all 0 < t \u2264 z * -z 0 for the unschedulability of job J 1 .\nTherefore, by the existence of y = z 1 -z * (with y \u2265 0) and \u03c9 i = d i -z * (with 0 \u2264 \u03c9 i \u2264 T i ) for i = 1, 2, . . . , k -1 to enforce the above necessary condition, we reach the conclusion of the proof by contrapositive. That is, task \u03c4 k is schedulable if, for all y \u2265 0 and any combination of 0 \u2264 \u03c9 i \u2264 T i for i = 1, 2, . . . , k -1, there exists 0\n< t \u2264 D k + y with \u2206 max k (D k + y) + \u03c4 i \u2208hp(\u03c4 k ) \u03c9i\u2022Ui+ t-\u03c9 i T i Ci M \u2264 t.\nThe schedulability condition in Lemma 9 may look at the first glance strange. We briefly explain the logical meaning (but informally) here. Suppose we would like to know whether a job of task \u03c4 k arrived at time r k can be finished before/at time r k + D k . To better quantify the interference from the higher-priority tasks, we would like to account for the higherpriority jobs arrived prior to r k . The variable y defines the extension of the window of interest from [r k , r k + D k ) to [r k -y, r k +D k ). The variable \u03c9 i defines the maximum residual execution time \u03c9 i T i of a carry-in job of task \u03c4 i that arrives before r k -y and should be executed in the window of interest, i.e., [r k -y, r k + D k ). If the residual workload is at most \u03c9 i T i , the next job can be released at time r k -y + \u03c9 i , as shown in the proof. Task \u03c4 k is schedulable by the global fixedpriority scheduling, if, for any combinations of y \u2265 0 and 0 \u2264 \u03c9 i \u2264 T i , \u2200\u03c4 i \u2208 hp(\u03c4 k ), we can always finish the inflated workload \u2206 max k \u2022 (D k + y) of task \u03c4 k and the higher-priority workload in the window of interest. For formal explanations, please refer to the formal proof of Lemma 9.\nNote that the schedulability condition in Lemma 9 requires to test all possible y \u2265 0 and all possible settings of 0 \u2264 \u03c9 i \u2264 T i for the higher-priority tasks \u03c4 i with i = 1, 2, . . . , k -1. Therefore, it needs exponential time (for all the possible combinations of \u03c9 i ). 7 However, we are not going to directly use the test in Lemma 9 in the paper. We will only use this test to construct the corresponding k-point schedulability test under Definition 2.\nWe present the corresponding polynomial-time schedulability tests for global fixed-priority scheduling. More specifically, we will also analyze the capacity augmentation factors of these tests for global RM and global DM in Corollaries 3 and 4, respectively.\nTheorem 8. Let U max k be max k j=1 U j . Task \u03c4 k in a sporadic task system with implicit deadlines is schedulable by global RM on M processors if\nU max k \u2264 1 - 2 M k-1 i=1 U i + 0.5 M 2 ( k-1 i=1 U i ) 2 + ( k-1 i=1 U 2 i ) (48) or k-1 j=1 U j M \u2264 k -1 k 2 -2 + 2U max k k k -1 .(49)\nProof: We will show that the schedulability condition in the theorem holds for all possible settings of y and \u03c9 i s. Suppose that y and \u03c9 i for i = 1, 2, . . . , k -1 are given, in which y \u2265 0 and 0 \u2264 \u03c9 i \u2264 T i . Let t k be T k + y. Now, we set t i to \u03c9 i + T k +y-\u03c9i Ti T i for i = 1, 2, . . . , k -1 and reindex the tasks such that t 1 \u2264 t 2 \u2264 . . . \u2264 t k . Therefore, if i < j, we know that\n\u03c9 i \u2022 U i + tj -\u03c9i Ti C i \u2264 \u03c9 i \u2022 U i + ( ti-\u03c9i Ti + 1)C i = t i U i + C i . If i \u2265 j, then \u03c9 i \u2022 U i + tj -\u03c9i Ti C i \u2264 \u03c9 i \u2022 U i + ( ti-\u03c9i Ti )C i = t i U i .\nThe sufficient schedulability condition in Lemma 9 under the given y and \u03c9 i s is to verify the existence of t j \u2208 {t 1 , t 2 , . . . t k } such that\nU max k (T k + y) + k-1 i=1 \u03c9 i \u2022 U i + tj -\u03c9i Ti C i M (50) \u2264U max k t k + k-1 i=1 U i t i + j-1 i=1 C i M \u2264 t j .(51)\nBy the definition of global RM scheduling (i.e., T k \u2265 T i ), we can conclude that \nC i = U i T i \u2264 U i T k \u2264 U i (T k +y) = U i t k for i = 1, 2, . . . ,\nU max k t k + k-1 i=1 \u03b1 i U i t i + j-1 i=1 \u03b2U i t k \u2264 t j ,(52)\nwhere \u03b1 i = 1 M and \u03b2 \u2264 1 M for i = 1, 2, . . . , k -1. Therefore, we reach the conclusion of the schedulability conditions in Eqs. ( 48) and (49) by Lemma 3 and Lemma 4 under given y and \u03c9 i s, respectively.\nThe schedulability test in Eq. ( 52) is independent from the settings of y and \u03c9 i s. However, the setting of y and \u03c9 i s affects how the k -1 higher-priority tasks are indexed. Fortunately, it can be observed that the schedulability tests in Eqs. ( 48) and (49) are completely independent upon the indexing of the higher-priority tasks. Therefore, no matter how y and \u03c9 i s are set, the schedulability conditions in Eqs. ( 48) and ( 49) are the corresponding results from the k 2 Q framework. As a result, we can reach the conclusion.\nCorollary 3. The capacity augmentation factor of global RM for a sporadic system with implicit deadlines is 3+ \n\u2206 max k \u2264 1 - 1 M k-1 i=1 U i + C i D k + 1 M 2 k-1 i=1 U i ( k-1 =i C D k ) ,(53\n) where the k -1 higher-priority tasks are ordered in a nonincreasing order of their periods.\nProof: This is due to a similar proof to that of Theorem 8 and Lemma 9, by applying Lemma 1 with\nt k = D k + y, \u03b1 i = 1\nM , and \u03b2 i = 1 M , under the worst-case last release time ordering, \u03b2iCi \u03b1iUi = T i non-increasingly, in Lemma 2. Therefore, for a given y \u2265 0, if\n\u2206 max k \u2264 1 -1 M k-1 i=1 U i + Ci D k +y + 1 M 2 k-1 i=1 U i ( k-1 =i C D k +y )\n, task \u03c4 k is schedulable by the global fixed-scheduling. By the assumption 8 This comes from the simple algebra property that for any two vectors a and b of size is minimized when y is 0. As a result, the above schedulability condition is the worst when y is 0.\nk-1 i=1 U i \u2264 M , we know that C i i =1 U M \u2264 C i . Therefore 8 , - 1 M k-1 i=1 C i D k + y + 1 M 2 k-1 i=1 U i ( k-1 =i C D k + y ) = 1 D k + y 1 M - k-1 i=1 C i + k-1 i=1 C i i =1 U M\n(k -1) there is k-1 i=1 a i k-1 =i b = k-1 i=1 b i i =1 a . x z J z -1 J -1 J3 z2 J2 z1 J1 z0 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022\nCorollary 4. The capacity augmentation factor and the speedup factor of global DM by using Theorem 9 for a sporadic system with constrained deadlines is 3.\nProof: If k i=1 U i \u2264 M or k-1 i=1 Ci D k \u2264 M is violated,\nthe capacity augmentation factor is already 1. Therefore, we focus on the case that task \u03c4 k does not pass the schedulability condition in Eq. (53). That is,\n\u2206 max k >1 - 1 M k-1 i=1 U i + C i D k + 1 M 2 k-1 i=1 U i ( k-1 =i C D k ) \u22651 - 1 M k-1 i=1 U i + C i D k .\nThis means that the unschedulability of task \u03c4 k under global DM implies that either\n\u2206 max k > 1 3 , 1 M k-1 i=1 U i > 1 3 , or 1 M k-1 i=1 Ci D k > 1 3\n, by the pigeonhole principle. Therefore, we conclude the factor 3.", "publication_ref": ["b6"], "figure_ref": [], "table_ref": []}, {"heading": "Remarks:", "text": "The utilization bound in Eq. ( 49) is analytically better than the best known utilization-based schedulability test\nk j=1 U j \u2264 M 2 (1-U max k )+U max k for global RM by Bertogna et al. [10], since (1-x) 2 \u2264 2 - \u221a 2 + 2x when 0 \u2264 x \u2264 1.\nThe capacity augmentation factor 2.823 in Corollary 3 is weaker than the result 2.668 by Lundberg [41]. However, we would like to point out the incompleteness in the proof in [41]. In the proof of the extreme task set, the argument in Page 150 in [41] concludes that task \u03c4 n is more difficult to be schedulable due to the increased interference of task \u03c4 n-1 to task \u03c4 n after the transformation. The argument was not correctly proved and can be optimistic since the increased interference has to be analyzed in all time points in the analysis window, whereas the analysis in [41] only considers the interference in a specific interval length. Without analyzing the resulting interference in all time points in the analysis window, task \u03c4 n after transformation may still have chance to finish earlier due to the potential reduction of the interference at earlier time points.\nThe speed-up factor 3 provided in Corollary 4 is asymptotically the same as the result by Baruah et al. [7]. The speed-up factor 3 in [7] requires a pseudo polynomial-time test, whereas we show that a simple test in Eq. (53) can already yield the speed-up factor 3 in O(k log k) time complexity. We limit our attention here for the global RM/DM scheduling. Andersson et al. [2] propose the RM-US[\u03c2] algorithm, which gives the highest priority to tasks \u03c4 i s with U i > \u03c2, and otherwise assigns priorities by using RM. Our analysis here can also be applied for the RM-US[\u03c2] algorithm with some modifications in the proofs by setting \u03c2 = 2 3+ \u221a 7 \u2248 0.3542.", "publication_ref": ["b40", "b40", "b40", "b40", "b6", "b6", "b1"], "figure_ref": [], "table_ref": []}, {"heading": "Appendix D: Response-Time for Periodic Tasks with Jitters", "text": "A periodic task (with jitters) \u03c4 i is defined by its period T i , its execution time C i , its relative deadline D i and, its jitter L i . The jitter problem arises when we consider some flexibility to delay the job arrival for a certain bounded length L i . Such a problem has also been studied in the literature, such as [3], [9].\nWe focus on uniprocessor fixed-priority scheduling here. The busy window concept has also been used for the schedulability analysis of fixed-priority scheduling [3]. For the h-th job of task \u03c4 k in the busy window, the finishing time R k,h is the minimum t such that\nhC k + k-1 i=1 t + L i T i C i \u2264 t.\nThe h-th job of task \u03c4 k arrives at time max{(h-1)T k -L k , 0}, and, hence, its response time is\nR k,h -max{(h-1)T k -L k , 0}.\nThe busy window of task \u03c4 k finishes on the h-th\njob if R k,h \u2264 max{hT k -L k , 0}.\nLemma 10. R k,h is upper bounded by finding the maximum\nt k = hC k + k-1 i=1 L i U i + k-1 i=1 t i U i + k-1 i=1 C i ,(54)\namong all possible least release time orderings of the k -1 higher-priority tasks with 0\n\u2264 t 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 t k and hC k + k-1 i=1 LiUi + k-1 i=1 tiUi + j-1 i=1\nCi > tj,\u2200j = 1, 2, . . . , k -1.\n(55)\nProof: Suppose that R k,h is known. Then, the last release of task \u03c4 i in the busy window before R k,h is at time\nt i = ( R k,h +Li Ti -1)T i -L i .\nWe can index the k-1 higher-priority tasks by t i non-decreasingly. By the definition of t i , we know that (\nR k,h +Li Ti -1)C i = ti+Li Ti T i U i = t i U i + L i U i .\nThat is, the accumulative workload of task \u03c4 i from 0 to t i is exactly L i U i + t i U i . Due to the indexing rule, and the known R k,h we can now conclude the conditions in Eqs. ( 54) and (55).\nHowever, it should be noted that the last release time ordering is actually unknown since R k,h is unknown. Therefore, we have to consider all possible last release time orderings.\nLemma 11. Suppose that k-1 i=1 U i \u2264 1. Then, for any h \u2265 1 and C k > 0, we have R k,h \u2264 hC k + k-1 i=1 (C i + L i U i ) - k-1 i=1 U i ( k-1 =i C ) 1 - k-1 i=1 U i , (56\n) where the k -1 higher-priority tasks are ordered in a nonincreasing order of their periods.\nProof: This comes from the above discussions with \u03b1 i = 1, \u03b2 i = 1 in Lemma 10 by applying Lemmas 6 and 7 when\nk-1 i=1 U i < 1. The case when k-1 i=1 U i = 1 has a safe upper bound R k,h = \u221e in Eq. (56). Theorem 10. Suppose that k i=1 U i \u2264 1. The worst-case response time of task \u03c4 k is at most R k \u2264 k-1 i=1 (Ci + LiUi) -k-1 i=1 Ui( k-1 =i C ) 1 -k-1 i=1 Ui ,(57)\n+ max h * C k 1 -k-1 i=1 Ui , (h * + 1)C k 1 -k-1 i=1 Ui -h * T k + L k\nwhere the k -1 higher-priority tasks are ordered in a nonincreasing order of their periods and h * = L k T k + 1.\nProof: By the definition of h * , we know that\n(h * -1)T k - L k \u2264 0, whereas h * T k -L k > 0. When h \u2264 h * , we know that max {(h * -1)T k -L k , 0} is 0. Therefore, R k,h -0 is maximized when h is set to h * for any h \u2264 h * . The first-order derivative of R k,h -((h -1)T k -L k ) with respect to h when h \u2265 h * + 1 is C k 1-k-1 i=1 Ui -T k = C k -(1-k-1 i=1 Ui)T k 1-k-1 i=1 Ui\n. Similar to the proof of Theorem 4, we know that setting R k,h -(h -1)T k is maximized when h is set to h * + 1 for any h \u2265 h * + 1.\nAs a result, we only have to evaluate the two cases by setting h as h * or h * + 1. One of them is the worst-case response time. The formulation in Eq. (57) simply compares these two response times.", "publication_ref": ["b2", "b8", "b2"], "figure_ref": [], "table_ref": []}, {"heading": "Appendix E: Schedulability for Generalized Multi-Frame", "text": "A generalized multi-frame real-time task \u03c4 i with m i frames is defined as a task with an array (C i,0 , D i,0 , T i,0 , C i,1 , D i,1 , T i,1 , . . . , C i,mi-1 , D i,mi-1 , T i,mi-1 ) of different execution times, different relative deadlines, and the minimal inter-arrival time of the next frame [8], [46]. The execution time of the j-th job of task \u03c4 i is defined as C i,(j mod mi) . If a job of the j-th frame of task \u03c4 i is released at time t, the earliest time that task \u03c4 i can release the next (j + 1) mod m i frame is at time t + T j . Here, we consider only constrained-deadline cases, in which D i,j \u2264 T i,j .\nTakada and Sakamura [46] provide an exact test with exponential-time complexity for such a problem under tasklevel fixed-priority scheduling, in which each task is assigned with one static priority level. For this section, we will focus on such a setting. Specifically, we are interested in analyzing the schedulability of the h-th frame of task \u03c4 k under the given task priority ordering. It was shown that the critical instant theorem of periodic task systems by Liu and Layland [39] does not work anymore for generalized multi-frame systems. Fortunately, as shown in Theorem 2 in [46], the critical instant of the h-th frame of task \u03c4 k is to release a certain frame of a higher priority task \u03c4 i at the same time, and the subsequent frames of task \u03c4 i as early as possible. In fact, this problem has been recently proved to be co-NP hard in the strong sense in [45].\nFor completeness, the test with exponential time complexity by Takada and Sakamura [46] will be presented in Lemma 12 by using our notation. We define rbf (i, q, t) as the maximum workload of task \u03c4 i released within an interval length t starting from the q-th frame. That is,\nrbf (i, q, t) = \u03b8(i,q,t) j=q C i,(j mod mi) ,(58)\nwhere \u03b8(i, q, t) is the smallest such that j=q T i,(j mod mi) \u2265 t. That is, \u03b8(i, q, t) is the last frame released by task \u03c4 i before t under the critical instant starting with the q-th frame of task \u03c4 i .\nLemma 12. The h-th frame of task \u03c4 k in a generalized multiframe task system with constrained deadlines is schedulable by a fixed-priority scheduling on a uniprocessor system if\n\u2200q i \u2208 {0, 1, . . . , m i -1} , \u2200i = 1, 2, . . . , k -1 \u22030 < t \u2264 D k,h , C k,h + k-1 i=1 rbf (i, q i , t) \u2264 t.\nProof: This is a reformulation of the test by Takada and Sakamura [46].\nSince the test in Lemma 12 requires exponential-time complexity, an approximation by using Maximum Interference Function (MIF) was proposed in [46] to provide a sufficient test efficiently. 9 Instead of testing all possible combinations of q i , a simple strategy is to use rbf (i, t) = max mi-1 q=0 rbf (i, q, t) to approximate the test in Lemma 12. This results in a pseudopolynomial-time test. Guan et al. [28] have recently provided proofs to show that such an approximation is with a speed-up factor of 2.\nWe will use a different way to build our analysis by constructing the k-point last-release schedulability test in Definition 2. The idea is very simple. If task \u03c4 i starts with its q-th frame, we can find and define t i,q = \u03b8(i,q,D k,h )-1 j=q T i,(j mod mi) as the last release time of task \u03c4 i before D k,h . Therefore, for the given D k,h , we are only interested in these m i last release times of task \u03c4 i . We need a safe function for estimating their workload. More precisely, we want to find two constants U i,k,h and C i,k,h such that U i,k,h \u2022 t i,q \u2265 rbf (i, q, t i,q ) and U i,k,h \u2022 t i,q + C i,k,h \u2265 rbf (i, q, t i,q + ) = rbf (i, q, D k,h ). This means that no matter which frame of task \u03c4 i is the first frame in the critical instant, we can always bound the workload from task \u03c4 i by using U i,k,h \u2022 t + C i,k,h for the points that we are interested to test. According to the above discussions, we can set U i,k,h = max q=0,1,...,mi-1 max rbf (i, q, t i,q ) t i,q\nC i,k,h = max q=0,1,...,mi-1 rbf (i, q, D k,h ) -U i,k,h \u2022 t i,q (60)\nNow, we can reorganize the schedulability test to link to Definition 2.\nLemma 13. The h-th frame of task \u03c4 k in a generalized multiframe task system with constrained deadlines is schedulable by a fixed-priority scheduling on a uniprocessor system if the following condition holds: For any last release ordering \u03c0 of 9 The reason why this is not an exact test was recently provided by Stigge and Wang in [45].\nthe k -1 higher-priority tasks with t 1,q1 \u2264 t 2,q2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1,q k-1 \u2264 t k = D k,h , there exists t j,qj such that\nC k,h + k-1 i=1 U i,k,h \u2022 t i,qi + j-1 i=1 C i,k,h \u2264 t j,qj ,(61)\nwhere U i,k,h and C i,k,h are defined in Eqs. (59) and (60), respectively.\nProof: This comes from the above discussions and Lemma 12.\nThe choice of q i only affects the last release ordering of the k -1 higher-priority tasks, but it does not change the constants U i,k,h and C i,k,h . Therefore, Lemma 13 satisfies Definition 2 by removing the indexes q, but the worst-case last release time ordering has to be considered.\nTheorem 11. Suppose that k-1 i=1 C i,k,h < D k,h . The h-th frame of task \u03c4 k in a generalized multiframe task system with constrained deadlines is schedulable by a scheduling algorithm on a uniprocessor system if the following condition holds\nC k,h D k,h \u2264 1- k-1 i=1 U i,k,h - k-1 i=1 (C i,k,h -U i,k,h ( k-1 =i C ,k,h )) D k,h ,(62\n) in which the k -1 higher-priority tasks are indexed in a nonincreasing order of C i,k,h U i,k,h of task \u03c4 i .\nProof: The schedulability test (under a specified last release time ordering \u03c0) in Lemma 13 satisfies Definition 2 with \u03b1 i = \u03b2 i = 1. Therefore, we can apply Lemmas 1 and 2 to reach the conclusion of the proof.\nA na\u00efve implementation to calculate t i,q and rbf (i, q, t) requires O(m i ) time complexity. Therefore, calculating U i,k,h and C i,k,h requires O(m 2 i ) time complexity with such an implementation. It can be calculated with better data structures and implementations to achieve O(m i ) time complexity. That is, we first calculate t i,0 and rbf (i, 0, t i,0 ) in O(m i ) time complexity. The overall time complexity to calculate the following t i,q and rbf (i, q, t i,q ) can be done in O(m i ) by using simple algebra. Therefore, the time complexity of the schedulability test in Theorem 11 is O( k-1 i=1 m i + k log k). Remarks: Although we focus ourselves on generalized multiframe task systems in this section, it can be easily seen that our approach can also be adopted to find polynomial-time tests based on the request bound function presented in [28]. Since such functions have been shown useful for schedulability tests in more generalized task models, including the digraph task model [44], the recurring real-time task model [6], etc., the above approach can also be applied for such models by quantifying the utilization (e.g., U i,k,h ) and the execution time (e.g., C i,k,h ) of task \u03c4 i based on the limited options of the last release times before the deadline (e.g., D k,h in generalized multi-frame) to be tested.\nframework to obtain the polynomial-time schedulability test in the following theorems.\nTheorem 12. For a given task \u03c4 i and a task mode \u03c4 k,h under testing, let C max i = max \u03c4i,j \u2208hp(\u03c4 k,h ) C i,j and U max i = max \u03c4i,j \u2208hp(\u03c4 k,h ) Ci,j Ti,j . Suppose that there are k -1 tasks with higher-priority modes than task mode \u03c4 k,h . Let \u2206 max k be max{max \u03c4 k,j \u2208hp(\u03c4 k,h ) { C k,j T k,j }, C k,h D k,h }. Suppose that k-1 i=1 C max i < D k,h . Task \u03c4 k,h in a multi-mode task system with constrained deadlines is schedulable by a mode-level fixed-priority scheduling algorithm on a uniprocessor system if k-1 i=1 U max i \u2264 1 and\n\u2206 max k \u2264 1- k-1 i=1 U max i - k-1 i=1 (C max i -U max i ( k-1 =i C max )) D k,h ,(65\n) in which the k -1 higher-priority tasks are indexed in a nonincreasing order of\nC max i U max i of task \u03c4 i .\nProof: Suppose that t i is given for each task \u03c4 i . For the given t i , we can define the last release time ordering, in which t 1 \u2264 t 2 \u2264 . . . \u2264 t k-1 \u2264 D k,h + y = t k . By Lemma 15, we can pessimistically rephrase the schedulability test in Lemma 14 to verify whether there exists t j \u2208 {t 1 , t 2 , . . . , t k } such that\n\u2206 max k (D k,h +y)+ k-1 i=1 U max i t i + j-1 i=1 C max i \u2264 t j .\nTherefore, we reach Definition 2 with \u03b1 i = 1 and \u03b2 i = 1, and, hence, can apply Lemmas 1 and 2. . Moreover, with the same argument in the proof of Theorem 9, we know that the resulting schedulability condition is the worst if y is 0 under the assumption\nk-1 i=1 U max i \u2264 1.\nTheorem 13. For a given task \u03c4 i and a task mode \u03c4 k,h under testing, let U max i = max \u03c4i,j \u2208hp(\u03c4 k,h ) Ci,j Ti,j . Suppose that there are k -1 tasks with higher-priority modes than task mode \u03c4 k,h . Let U max k be max{max \u03c4 k,j \u2208hp(\u03c4 k,h ) { C k,j T k,j },\nC k,h\nT k,h }. Suppose that k i=1 U max i \u2264 1. Task \u03c4 k,h in a multi-mode task system with implicit deadlines is schedulable by the modelevel RM scheduling algorithm on a uniprocessor system if the following condition holds\nU max k \u2264 1-2 k-1 i=1 U max i +0.5 ( k-1 i=1 U max i ) 2 + ( k-1 i=1 (U max i ) 2 ) , (66) or k-1 i=1 U max i \u2264 k -1 k 2 -2 + 2U max k k k -1 ,(67)\nor\nU max k + k-1 i=1 U max i \u2264 k-1 k 2 -4 -2k k-1 , if k > 3 1 -(k-1) 2k otherwise.\n(68)\nProof: Due to the RM property, we know that T i,j \u2264 T k,h if \u03c4 i,j is in hp(\u03c4 k,h ). Therefore, C max i \u2264 T k,h U max i . We now reach the conditions in Lemmas 3, 4, and 5 with \u03b1 = 1 and \u03b2 = 1. The three conditions are directly from these lemmas. Note that the above tests assume implicitly that the tasks in hp(\u03c4 k,h ) are already tested to be schedulable under the scheduling policy. Therefore, we have to apply the results in Theorems 12 and 13 by testing all the task modes from the highest priority to the lowest priority. The following theorem provides the utilization bound for testing the whole task set in linear time for mode-level RM scheduling.\nCorollary 5. Suppose that k i=1 U i \u2264 1. A system with k acyclic tasks with utilization U 1 , U 2 , . . . , U k is schedulable by the mode-level RM scheduling algorithm on a uniprocessor system if\nk i=1 U i \u2264 k-1 k 2 -4 -2k k-1 , if k > 3 1 -(k-1) 2k otherwise. (69) or 0 \u2264 1 -U k -2 k-1 i=1 U i + 0.5 ( k-1 i=1 U i ) 2 + ( k-1 i=1 U 2 i ) , (70\n)\nwhere task \u03c4 k is the task with the minimum utilization among the k tasks.\nProof: This comes with similar arguments in Theorem 13. Adopting the utilization bound in Eq. (69) does not need to consider the ordering of the tasks. However, the quadratic bound in Eq. (70) changes for different settings of U k . Let k i=1 U i be a given constant H 1 and k i=1 U 2 i be H 2 . Then, the quadratic bound in Eq. ( 70) becomes 1 -2H 1 + U k + 0.5H 2 1 + 0.5H 2 -0.5U 2 k . The first order derivative of the quadratic bound with respect to U k is 1 -U k , which implies that the minimum U k leads to the worst condition in the quadratic bound in Eq. (70) under the condition U k \u2264 1.\nThe result in Eq. (69) in Corollary 5 is the same as the utilization bound 2 -\u221a 2 (when k \u2192 \u221e) in [1], [31] for such a task model. Our results here are more generic than [1] and can also be easily applied for any (mode-level or task-level) fixed-priority scheduling.", "publication_ref": ["b7", "b45", "b45", "b38", "b45", "b44", "b45", "b45", "b45", "b27", "b44", "b27", "b43", "b5", "b0", "b30", "b0"], "figure_ref": [], "table_ref": []}, {"heading": "Appendix B: Quadratic Bound for Uniprocessor Constrained-Deadline Tasks", "text": "To verify the schedulability of a (constrained-deadline) sporadic real-time task \u03c4 k under fixed-priority scheduling in", "publication_ref": [], "figure_ref": [], "table_ref": []}, {"heading": "Appendix F: Acyclic and Multi-Mode Tasks", "text": "This section considers the acyclic model, proposed in [1]. That is, each task \u03c4 i is specified only by its utilization U i . An instance of task \u03c4 i can have different worst-case execution times and different relative deadlines. If an instance of task \u03c4 i arrives at time t with execution time C i,t , its relative deadline is Ci,t Ui , and the next instance of task \u03c4 i can only be released after t + Ci,t Ui .\nFor systems with known modes, we can also define a multi-mode task system. A multi-mode task \u03c4 i with m i modes is denoted by a set of triplet:\nto specify the worst-case execution time C i,j , the minimum inter-arrival time T i,j , and the relative deadline D i,j of the corresponding task mode \u03c4 i,j . For a multi-mode task \u03c4 i , when a job of mode \u03c4 i,j is released at time t, this job has to be finished no later than its absolute deadline at time t + D i,j , and the next release time of task \u03c4 i is no earlier than t + T i,j . We only consider systems with constrained deadlines, in which D i,j \u2264 T i,j . This model is studied in our paper [31]. The difference between this model and the generalized multi-frame model is that the system can switch arbitrarily among any two modes if the temporal seperation constraints in the multi-mode model are respected.\nWe will focus on mode-level fixed-priority scheduling on uniprocessor scheduling in this section. Suppose that we are testing whether task \u03c4 k,h can be feasibly scheduled. Let hp(\u03c4 k,h ) be the set of task mode \u03c4 k,h and the other task modes with higher priority than task mode \u03c4 k,h . It is important to note that \u03c4 k,h is also in hp(\u03c4 k,h ) for the simplicity of presentation. For notational brevity, we assume that there are k -1 tasks with higher-priority task modes than \u03c4 k,h . Moreover, for the rest of this section, we implicitly assume that the tasks in hp(\u03c4 k,h ) \\ {\u03c4 k,h } are schedulable by the mode-level fixedpriority scheduling algorithm under testing.\nLet load(i, t) be the maximum workload of task \u03c4 i (by considering all the task modes \u03c4 i,j \u2208 hp(\u03c4 k,h )) released from 0 to t such that the next mode can be released at time t. That is, let n i,q be a non-negative integer to denote the number of times that task mode \u03c4 i,q is released, in which\nq n i,q T i,q \u2264 t}.\nWe denote C max i (\u03c4 k,h ) the maximum mode execution time among the higher-priority modes of task \u03c4 i than task mode \u03c4 k,h , i.e., max \u03c4i,j \u2208hp(\u03c4 k,h ) C i,j for a given index i. Similarly, we denote U max i (\u03c4 k,h ) the maximum mode utilization among the higher-priority modes of task \u03c4 i than task mode \u03c4 k,h , i.e., max \u03c4i,j \u2208hp(\u03c4 k,h ) Ci,j Ti,j for a given index i. For notational brevity, since we define C max i (\u03c4 k,h ) and U max i (\u03c4 k,h ) by referring to \u03c4 k,h , we will simplify the notation by using C max i and U max i , respectively, for the rest of this section.\nSuppose that the last release of task \u03c4 i in the window of interest is at t i . We define the request bound function for such a case as follows:\nLemma 14. Task \u03c4 k,h in a multi-mode task system with constrained deadlines is schedulable by a mode-level fixed-priority scheduling algorithm on uniprocessor systems if\nProof: This is proved by contrapositive. Suppose that \u03c4 k,h misses its deadline firstly at time d k,h . We know that this job of \u03c4 k,h arrives to the system at time a 1 = d k,h -D k,h . Due to the scheduling policy, we know that the processor is busy executing jobs in hp(\u03c4 k,h ) (recall that \u03c4 k,h is also in hp(\u03c4 k,h )) from a 1 to d k,h . Let a 0 be the last time point in the above schedule before a 1 such that the processor is idle or executing any job with lower priority than \u03c4 k,h . It is clear that a 0 is well-defined. Therefore, the processor executes only jobs in hp(\u03c4 k,h ) from a 0 to d k,h . We denote a 1 -a 0 as y. Let the last release of the task modes of task \u03c4 i before d k,h be a 0 + t i . If task \u03c4 i does not have any release, we set t i to 0. Therefore, we have 0\nWithout loss of generality, we set a 0 to 0. Therefore, the workload requested by the modes of task \u03c4 i at any time t before (and at) t i is no more than load(i, t). Moreover, the workload released by the modes of task \u03c4 i at any time t after t i is no more than load(i, t i ) + C max i . As a result, the function rbf (i, t i , t) defined in Eq. ( 63) is a safe upper bound of the workload requested by task \u03c4 i upt to time t.\nBy the definition of the task model, task mode \u03c4 k,h and the other higher-priority task modes of task \u03c4 k may also release some workload before a 1 , in which the workload is upper bounded by load(k, y). The assumption of non-schedulability of task \u03c4 k,h in the above schedule and the busy execution in the interval (a 0 , d k,h ] implies that the above workload at any point t in the interval (a 0 , d k,h ] is larger than t. Therefore, we know that\nwhich concludes the proof by contrapositive.\nEvaluating load(i, t) is in fact equivalent to the unbounded knapsack problem (UKP). The UKP problem is to select some items in a collection of items with specified weights and profits so that the total weight of the selected items is less than or equal to a given limit (called knapsack) and total profit of the selected items is maximized, in which an item can be selected unbounded multiple times. The definition of load(i, t) is essentially an unbounded knapsack problem, by considering t as the knapsack constraint, the minimum inter-arrival time (period) of a task mode as the weight of an item, and the execution time of a task mode as the profit of the item. \nProof: It has been shown in [42] that an upper bound of the above unbounded knapsack problem is max \u03c4i,j \u2208hp(\u03c4 k,h ) { Ci,j Ti,j } \u2022 t = U max i \u2022 t, which completes the proof.\nBy Lemma 14 and Lemma 15, we can now apply the k 2 Q", "publication_ref": ["b0", "b30", "b41"], "figure_ref": [], "table_ref": []}], "references": [{"ref_id": "b0", "title": "A utilization bound for aperiodic tasks and priority driven scheduling", "journal": "IEEE Trans. Computers", "year": "2004", "authors": "T F Abdelzaher; V Sharma; C Lu"}, {"ref_id": "b1", "title": "Static-priority scheduling on multiprocessors", "journal": "", "year": "2001", "authors": "B Andersson; S K Baruah; J Jonsson"}, {"ref_id": "b2", "title": "Applying new scheduling theory to static priority pre-emptive scheduling", "journal": "Software Engineering Journal", "year": "1993-09", "authors": "N Audsley; A Burns; M Richardson; K Tindell; A Wellings"}, {"ref_id": "b3", "title": "Multiprocessor EDF and deadline monotonic schedulability analysis", "journal": "", "year": "2003", "authors": "T P Baker"}, {"ref_id": "b4", "title": "An analysis of fixed-priority schedulability on a multiprocessor", "journal": "Real-Time Systems", "year": "2006", "authors": "T P Baker"}, {"ref_id": "b5", "title": "The non-cyclic recurring real-time task model", "journal": "", "year": "2010-12-03", "authors": "S K Baruah"}, {"ref_id": "b6", "title": "Improved multiprocessor global schedulability analysis", "journal": "Real-Time Systems", "year": "2010", "authors": "S K Baruah; V Bonifaci; A Marchetti-Spaccamela; S Stiller"}, {"ref_id": "b7", "title": "Generalized multiframe tasks", "journal": "Real-Time Systems", "year": "1999", "authors": "S K Baruah; D Chen; S Gorinsky; A K Mok"}, {"ref_id": "b8", "title": "Jitter concerns in periodic task systems", "journal": "", "year": "1997", "authors": "S K Baruah; D Chen; A K Mok"}, {"ref_id": "b9", "title": "New schedulability tests for real-time task sets scheduled by deadline monotonic on multiprocessors", "journal": "", "year": "2005", "authors": "M Bertogna; M Cirinei; G Lipari"}, {"ref_id": "b10", "title": "New schedulability tests for real-time task sets scheduled by deadline monotonic on multiprocessors", "journal": "Springer", "year": "2006", "authors": "M Bertogna; M Cirinei; G Lipari"}, {"ref_id": "b11", "title": "Schedulability analysis of periodic fixed priority systems", "journal": "IEEE Trans. Computers", "year": "2004", "authors": "E Bini; G C Buttazzo"}, {"ref_id": "b12", "title": "Rate monotonic analysis: the hyperbolic bound", "journal": "Computers, IEEE Transactions on", "year": "2003", "authors": "E Bini; G C Buttazzo; G M Buttazzo"}, {"ref_id": "b13", "title": "A responsetime bound in fixed-priority scheduling with arbitrary deadlines", "journal": "IEEE Transactions on Computers", "year": "2009", "authors": "E Bini; T H C Nguyen; P Richard; S K Baruah"}, {"ref_id": "b14", "title": "A quadratic-time response time upper bound with a tightness property", "journal": "", "year": "2015", "authors": "E Bini; A Parri; G Dossena"}, {"ref_id": "b15", "title": "New strategies for assigning real-time tasks to multiprocessor systems", "journal": "", "year": "1995", "authors": "A Burchard; J Liebeherr; Y Oh; S H Son"}, {"ref_id": "b16", "title": "Approximate schedulability analysis", "journal": "", "year": "2002", "authors": "S Chakraborty; S K\u00fcnzli; L Thiele"}, {"ref_id": "b17", "title": "Evaluate and compare two utilization-based schedulability-test frameworks for realtime systems", "journal": "CoRR", "year": "2015", "authors": "J.-J Chen; W.-H Huang; C Liu"}, {"ref_id": "b18", "title": "k 2 U : A general framework from k-point effective schedulability analysis to utilization-based tests", "journal": "RTSS", "year": "2015", "authors": "J.-J Chen; W.-H Huang; C Liu"}, {"ref_id": "b19", "title": "k2U: A general framework from k-point effective schedulability analysis to utilization-based tests", "journal": "", "year": "2015", "authors": "J.-J Chen; W.-H Huang; C Liu"}, {"ref_id": "b20", "title": "Automatic parameter derivations in k 2 U framework", "journal": "CoRR", "year": "2016", "authors": "J.-J Chen; W.-H Huang; C Liu"}, {"ref_id": "b21", "title": "Quantifying the suboptimality of uniprocessor fixed priority pre-emptive scheduling for sporadic tasksets with arbitrary deadlines", "journal": "", "year": "2009", "authors": "R Davis; T Rothvo\u00df; S Baruah; A Burns"}, {"ref_id": "b22", "title": "Improved priority assignment for global fixed priority pre-emptive scheduling in multiprocessor real-time systems", "journal": "Real-Time Systems", "year": "2011", "authors": "R I Davis; A Burns"}, {"ref_id": "b23", "title": "Schedulability tests for tasks with variable rate-dependent behaviour under fixed priority scheduling", "journal": "", "year": "2014", "authors": "R I Davis; T Feld; V Pollex; F Slomka"}, {"ref_id": "b24", "title": "Efficient exact schedulability tests for fixed priority real-time systems", "journal": "Computers, IEEE Transactions on", "year": "2008", "authors": "R I Davis; A Zabos; A Burns"}, {"ref_id": "b25", "title": "On a real-time scheduling problem", "journal": "Operations Research", "year": "1978", "authors": "S K Dhall; C L Liu"}, {"ref_id": "b26", "title": "A fully polynomial-time approximation scheme for feasibility analysis in static-priority systems with arbitrary relative deadlines", "journal": "", "year": "2005", "authors": "N Fisher; S K Baruah"}, {"ref_id": "b27", "title": "Approximate response time analysis of real-time task graphs", "journal": "", "year": "2014", "authors": "N Guan; C Gu; M Stigge; Q Deng; W Yi"}, {"ref_id": "b28", "title": "New response time bounds for fixed priority multiprocessor scheduling", "journal": "", "year": "2009", "authors": "N Guan; M Stigge; W Yi; G Yu"}, {"ref_id": "b29", "title": "A better polynomial-time schedulability test for real-time fixed-priority scheduling algorithms", "journal": "", "year": "1997", "authors": "C.-C Han; H Ying Tyan"}, {"ref_id": "b30", "title": "Techniques for schedulability analysis in mode change systems under fixed-priority scheduling", "journal": "RTCSA", "year": "2015", "authors": "W.-H Huang; J.-J Chen"}, {"ref_id": "b31", "title": "Efficient online schedulability tests for real-time systems", "journal": "Software Engineering, IEEE Transactions on", "year": "2003", "authors": "T.-W Kuo; L.-P Chang; Y.-H Liu; K.-J Lin"}, {"ref_id": "b32", "title": "Enhanced utilization bounds for qos management", "journal": "IEEE Trans. Computers", "year": "2004", "authors": "C.-G Lee; L Sha; A Peddi"}, {"ref_id": "b33", "title": "Fixed priority scheduling of periodic task sets with arbitrary deadlines", "journal": "", "year": "1990", "authors": "J P Lehoczky"}, {"ref_id": "b34", "title": "The rate monotonic scheduling algorithm: Exact characterization and average case behavior", "journal": "", "year": "1989", "authors": "J P Lehoczky; L Sha; Y Ding"}, {"ref_id": "b35", "title": "Analysis of federated and global scheduling for parallel real-time tasks", "journal": "", "year": "2014", "authors": "J Li; J Chen; K Agrawal; C Lu; C Gill; A Saifullah"}, {"ref_id": "b36", "title": "Task scheduling with self-suspensions in soft real-time multiprocessor systems", "journal": "", "year": "2009", "authors": "C Liu; J Anderson"}, {"ref_id": "b37", "title": "Bursty-interference analysis techniques for analyzing complex real-time task models", "journal": "", "year": "2014", "authors": "C Liu; J.-J Chen"}, {"ref_id": "b38", "title": "Scheduling algorithms for multiprogramming in a hard-real-time environment", "journal": "Journal of the ACM (JACM)", "year": "1973", "authors": "C L Liu; J W Layland"}, {"ref_id": "b39", "title": "Linear and nonlinear programming", "journal": "Springer", "year": "2008", "authors": "D G Luenberger; Y Ye"}, {"ref_id": "b40", "title": "Analyzing fixed-priority global multiprocessor scheduling", "journal": "", "year": "2002", "authors": "L Lundberg"}, {"ref_id": "b41", "title": "Knapsack problems: algorithms and computer implementations", "journal": "John Wiley & Sons, Inc", "year": "1990", "authors": "S Martello; P Toth"}, {"ref_id": "b42", "title": "Optimal time-critical scheduling via resource augmentation", "journal": "", "year": "1997", "authors": "C Phillips; C Stein; E Torng; J Wein"}, {"ref_id": "b43", "title": "The digraph real-time task model", "journal": "", "year": "2011-04-14", "authors": "M Stigge; P Ekberg; N Guan; W Yi"}, {"ref_id": "b44", "title": "Hardness results for static priority real-time scheduling", "journal": "", "year": "2012", "authors": "M Stigge; W Yi"}, {"ref_id": "b45", "title": "Schedulability of generalized multiframe task sets under static priority assignment", "journal": "", "year": "1997", "authors": "H Takada; K Sakamura"}, {"ref_id": "b46", "title": "On schedulability bounds of static priority schedulers", "journal": "", "year": "2005", "authors": "J Wu; J Liu; W Zhao"}], "figures": [{"figure_label": "1", "figure_type": "figure", "figure_id": "fig_0", "figure_caption": "Fig. 1 :1Fig. 1: The k 2 Q framework.", "figure_data": ""}, {"figure_label": "", "figure_type": "figure", "figure_id": "fig_1", "figure_caption": "\u2022We use the same example in Example 4 by setting C 3 = 8 to demonstrate how to use Lemma 6. By the transformation in Example 3, we know that \u03b1 i = 1 and \u03b2 i = 1 for i = 1, 2. Now, we can use Lemma 6 based on \u03c0 1 and \u03c0 2 (defined in Example 4) to calculate the worst-case response time:\u2022 For \u03c0 1 , the response-time analysis in Lemma 6 shows that the response time of task \u03c4 3 in Example 4 is upper bounded by C3+C1+C2-U1(C1+C2)For \u03c0 2 , the response-time analysis in Lemma 6 shows that the response time of task \u03c4 3 in Example 4 is upper bounded by C3+C1+C2-U2(C2+C1)", "figure_data": ""}, {"figure_label": "111", "figure_type": "figure", "figure_id": "fig_2", "figure_caption": "\u03b1 i = 1 \u03b2 i = 1 = 1 M \u03b2 i = 1 M111Theorems 3 and 4 Multiprocessor Global RM/DM for Sporadic Tasks \u03b1 i Theorems 5, 6, 8,and 9 Uniprocessor Periodic Tasks with Jitters \u03b1 i = 1 \u03b2 i = 1 Theorem 10 Uniprocessor Generalized Multi-Frame, Acyclic, and Mode-Change Tasks \u03b1 i = 1 \u03b2 i = 1 Theorems 11, 12, and 13.", "figure_data": ""}, {"figure_label": "2", "figure_type": "figure", "figure_id": "fig_3", "figure_caption": "Fig. 2 :2Fig. 2: Acceptance ratio comparison on implicit-deadline 8 multiprocessor systems.", "figure_data": ""}, {"figure_label": "17229", "figure_type": "figure", "figure_id": "fig_4", "figure_caption": "1 b 7 . 2 \u2248 2 Theorem 9 .17229and U max k \u2264 max \u03c4i U i \u2264 1 b . The right-hand side of Eq. (49) converges to 2 -2 + U max k when k \u2192 \u221e Therefore, by Eq. (49), we can guarantee the schedulability of task\u03c4 k if 1 b \u2264 2 -2 + 2 b . This is equivalent to solving x = 2 -\u221a 2 + 2x, which holds when x = 3 -\u221a Therefore, we reach the conclusion of the capacity augmentation factor 3+\u221a 7 Let \u2206 max k be max k-1 j=1 {U j , C k D k }.Task \u03c4 k in a sporadic task system with constrained deadlines is schedulable by a global fixed-priority scheduling on M processors ifk i=1 U i \u2264 M ,", "figure_data": ""}, {"figure_label": "3", "figure_type": "figure", "figure_id": "fig_5", "figure_caption": "Fig. 3 :3Fig.3: Notation of the forced-forward algorithm for the analysis of global fixed-priority scheduling.", "figure_data": ""}, {"figure_label": "", "figure_type": "table", "figure_id": "tab_1", "figure_caption": "k -1. Hence, we can safely reformulate the sufficient test by verifying whether there exists t j \u2208 {t 1 , t 2 , . . . t k } such that", "figure_data": ""}], "formulas": [{"formula_id": "formula_0", "formula_text": "U i = C i /T i .", "formula_coordinates": [3.0, 154.09, 450.24, 50.45, 9.65]}, {"formula_id": "formula_1", "formula_text": "C k + \u03c4 i \u2208hp(\u03c4 k ) Ci M D k \u2264 1", "formula_coordinates": [3.0, 369.74, 195.48, 90.15, 17.3]}, {"formula_id": "formula_2", "formula_text": "C k + \u03c4 i \u2208hp(\u03c4 k ) Ci M D k \u2264 1", "formula_coordinates": [3.0, 362.89, 268.25, 92.97, 17.3]}, {"formula_id": "formula_3", "formula_text": "\u2203t with 0 < t \u2264 T k and C k + \u03c4i\u2208hp(\u03c4 k ) t T i C i \u2264 t,(1)", "formula_coordinates": [4.0, 57.62, 140.5, 243.45, 27.94]}, {"formula_id": "formula_4", "formula_text": "( T k Ti -1)T i for \u03c4 i \u2208 hp(\u03c4 k ) and t = T k . If C k + \u03c4i\u2208hp(\u03c4 k )", "formula_coordinates": [4.0, 48.96, 209.97, 252.11, 31.85]}, {"formula_id": "formula_5", "formula_text": "0 \u2264 t 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 t k and C k + k-1 i=1 \u03b1 i t i U i + j-1 i=1 \u03b2 i C i \u2264 t j ,(2)", "formula_coordinates": [4.0, 105.69, 663.2, 195.38, 47.5]}, {"formula_id": "formula_6", "formula_text": "( T k Ti -1)T i non-decreasingly, i.e., t 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 t k = T k .", "formula_coordinates": [4.0, 319.0, 113.83, 252.1, 25.05]}, {"formula_id": "formula_7", "formula_text": "ti Ti C i + C i = t i U i + C i ; 2) if i \u2265 j, due to the definition of t i as ( T k Ti -1)T i and t j \u2264 t i \u2264 T k , we know that tj Ti C i is upper bounded by ti Ti C i = t i U i . 2", "formula_coordinates": [4.0, 319.0, 205.26, 252.1, 49.5]}, {"formula_id": "formula_8", "formula_text": "C k + k-1 i=1 tj Ti C i \u2264 C k + k-1 i=1 t i U i + j-1 i=1 C i .", "formula_coordinates": [4.0, 361.1, 272.51, 210.0, 14.6]}, {"formula_id": "formula_9", "formula_text": "C k + k-1 i=1 t i U i + j-1 i=1 C i \u2264 t j .", "formula_coordinates": [4.0, 385.05, 316.64, 120.01, 30.8]}, {"formula_id": "formula_10", "formula_text": "{\u03c4 1 , \u03c4 2 } \u2192 {1, 2}. Moreover, \u03b1 1 = \u03b1 2 = \u03b2 1 = \u03b2 2 = 1.", "formula_coordinates": [4.0, 319.0, 480.47, 252.1, 20.61]}, {"formula_id": "formula_11", "formula_text": "t k = C k + k-1 i=1 \u03b1 i t i U i + k-1 i=1 \u03b2 i C i ,(3)", "formula_coordinates": [4.0, 375.27, 590.24, 195.83, 30.32]}, {"formula_id": "formula_12", "formula_text": "with 0 \u2264 t 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 t k and C k + k-1 i=1 \u03b1 i t i U i + j-1 i=1 \u03b2 i C i > t j ,\u2200j = 1, 2, . . . , k -1,(4)", "formula_coordinates": [4.0, 319.0, 626.95, 252.1, 47.5]}, {"formula_id": "formula_13", "formula_text": "t i T i C i = t i U i holds.", "formula_coordinates": [4.0, 499.21, 738.33, 71.89, 13.23]}, {"formula_id": "formula_14", "formula_text": "C k + \u03c4i\u2208hp(\u03c4 k ) t Ti C i > t for any 0 < t < R k and C k + \u03c4i\u2208hp(\u03c4 k ) R k Ti C i = R k .", "formula_coordinates": [5.0, 48.96, 69.79, 252.11, 31.63]}, {"formula_id": "formula_15", "formula_text": "t 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 R k . With the same analysis in Example 1, we know that C k + k-1 i=1 t i U i + j-1 i=1 C i > t j for j = 1, 2, . . . , k -1 and R k \u2264 C k + k-1 i=1 t i U i + k-1 i=1 C i .", "formula_coordinates": [5.0, 48.96, 130.79, 252.1, 36.16]}, {"formula_id": "formula_16", "formula_text": "U i , \u2200i < k C i , \u2200i < k \u03b1 i , \u2200i < k \u03b2 i , \u2200i < k C k t k (for Lemmas 1-", "formula_coordinates": [5.0, 357.84, 132.79, 43.84, 46.4]}, {"formula_id": "formula_17", "formula_text": "0 < \u03b2 i for any i = 1, 2, . . . , k -1, 0 < t k , k-1 i=1 \u03b1 i U i \u2264 1, and k-1 i=1 \u03b2 i C i \u2264 t k , task \u03c4 k is", "formula_coordinates": [5.0, 319.0, 728.69, 252.1, 23.05]}, {"formula_id": "formula_18", "formula_text": "C k t k \u2264 1- k-1 i=1 \u03b1 i U i - k-1 i=1 (\u03b2 i C i -\u03b1 i U i ( k-1 =i \u03b2 C )) t k .(5)", "formula_coordinates": [6.0, 55.14, 85.78, 245.93, 30.32]}, {"formula_id": "formula_19", "formula_text": "C k + k-1 i=1 \u03b1 i t i U i + j-1 i=1 \u03b2 i C i > t j .(6)", "formula_coordinates": [6.0, 105.69, 211.19, 195.38, 30.79]}, {"formula_id": "formula_20", "formula_text": "C k > C * k , where C * k is defined in the optimization problem: min C * k (7a) s.t. C * k + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i \u2265 t * j , \u2200j = 1, 2, . . . , k -1, (7b) t * 1 \u2265 0 (7c) t * j \u2265 t * j-1 , \u2200j = 2, 3, . . . , k -1,(7d)", "formula_coordinates": [6.0, 48.96, 340.86, 252.11, 105.85]}, {"formula_id": "formula_21", "formula_text": "C * k + k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i \u2265 t k ,(7e)", "formula_coordinates": [6.0, 73.23, 450.52, 227.83, 25.0]}, {"formula_id": "formula_22", "formula_text": "min C * k (8a) s.t. C * k + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i \u2265 t * j , \u2200j = 1, 2, . . . , k -1, (8b) t * j \u2265 0, \u2200j = 1, 2, . . . , k -1,(8c)", "formula_coordinates": [6.0, 56.4, 578.44, 244.66, 51.12]}, {"formula_id": "formula_23", "formula_text": "C * k + k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i \u2265 t k .(8d)", "formula_coordinates": [6.0, 73.23, 633.37, 227.83, 25.0]}, {"formula_id": "formula_24", "formula_text": "C * k = t k + s - ( k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i ).", "formula_coordinates": [6.0, 48.96, 680.8, 252.1, 25.39]}, {"formula_id": "formula_25", "formula_text": "t k + s -( k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i ) such that Eq. (8b) holds, which is equivalent to t k + s -( k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i ) + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i = t k + s - k-1 i=j \u03b2 i C i \u2265 t * j , \u2200j = 1, 2, . . . , k -1.(9)", "formula_coordinates": [6.0, 48.96, 72.56, 522.14, 676.99]}, {"formula_id": "formula_26", "formula_text": "min t * k -( k-1 i=1 \u03b1 i U i t * i + k-1 i=1 \u03b2 i C i ) (10a) s.t. t * k - k-1 i=j \u03b2 i C i \u2265 t * j , \u22001 \u2264 j \u2264 k -1, (10b) t * j \u2265 0 \u22001 \u2264 j \u2264 k -1. (10c) t * k \u2265 t k (10d)", "formula_coordinates": [6.0, 326.86, 178.01, 244.25, 93.56]}, {"formula_id": "formula_27", "formula_text": "C * k if k-1 i=1 \u03b1 i U i \u2264 1.", "formula_coordinates": [6.0, 420.94, 447.88, 93.31, 14.11]}, {"formula_id": "formula_28", "formula_text": "* i \u2264 t * k for i = 1, 2, . . . , k -1,.", "formula_coordinates": [6.0, 447.88, 608.56, 123.23, 12.55]}, {"formula_id": "formula_29", "formula_text": "t * j > 0 is to put t * k - k-1 i=j \u03b2 i C i = t * j for every j = 1, 2, . . . , k -1, i.e., \u22001 \u2264 i \u2264 k -1, t * i+1 -t * i = \u03b2 i C i ,(11)", "formula_coordinates": [6.0, 319.0, 708.68, 252.1, 42.54]}, {"formula_id": "formula_30", "formula_text": "t * k -t * i = k-1 =i (t * +1 -t * ) = k-1 =i \u03b2 C(12)", "formula_coordinates": [7.0, 98.85, 74.92, 202.21, 30.55]}, {"formula_id": "formula_31", "formula_text": "k-1 j=1 \u03b2 j C j \u2264 t k \u2264 t * k .", "formula_coordinates": [7.0, 48.96, 120.87, 252.1, 25.15]}, {"formula_id": "formula_32", "formula_text": "t * k - k-1 i=1 (\u03b1iUit * i + \u03b2iCi) (13) =t * k - k-1 i=1 \u03b1iUi t * k - k-1 =i \u03b2 C + \u03b2iCi (14) =t * k - k-1 i=1 \u03b1iUit * k + k-1 i=1 \u03b2iCi - k-1 i=1 \u03b1iUi k-1 =i \u03b2 C(15)", "formula_coordinates": [7.0, 56.74, 171.72, 244.33, 88.27]}, {"formula_id": "formula_33", "formula_text": "C * k \u2265 t * k (1 - k-1 i=1 \u03b1 i U i ) - k-1 i=1 (\u03b2 i C i - \u03b1 i U i ( k-1 =i \u03b2 C )).", "formula_coordinates": [7.0, 48.96, 266.63, 252.1, 26.95]}, {"formula_id": "formula_34", "formula_text": "k-1 i=1 \u03b2 i C i \u2264 t k \u2264 t * k , if t * j is set to 0, there are two cases: (1) t * k - k-1 i=j \u03b2 i C i > 0 or (2) t * k - k-1 i=j \u03b2 i C i = 0. In the former case, we can simply set t * j to t * k - k-1", "formula_coordinates": [7.0, 48.96, 331.08, 252.1, 56.14]}, {"formula_id": "formula_35", "formula_text": "k-1 i=1 \u03b1 i U i \u2265 0 and t * k \u2265 t k , we know that t * k (1 - k-1 i=1 \u03b1 i U i ) \u2265 t k (1 - k-1 i=1 \u03b1 i U i ). Therefore, C * k = t k (1 - k-1 i=1 \u03b1 i U i ) - k-1 i=1 (\u03b2 i C i -\u03b1 i U i ( k-1 =i \u03b2 C )) when 1 - k-1 i=1 \u03b1 i U i \u2265 0 and k-1 i=1 \u03b2 i C i \u2264 t k , which concludes the proof.", "formula_coordinates": [7.0, 48.96, 468.88, 252.11, 61.41]}, {"formula_id": "formula_36", "formula_text": "Consider that k = 3 and |hp(\u03c4 k )| is 2. For the two tasks in hp(\u03c4 k ), let C 1 = 2, U 1 = 0.2, T 1 = 10 and C 2 = 4, U 2 = 0.5, T 2 = 8. Suppose that t 3 = D 3 = T 3 = 36.", "formula_coordinates": [7.0, 48.96, 587.63, 252.1, 31.57]}, {"formula_id": "formula_37", "formula_text": "\u03b2 i = 1 for i = 1, 2.", "formula_coordinates": [7.0, 48.96, 631.47, 79.41, 9.65]}, {"formula_id": "formula_38", "formula_text": "C 3 \u2264 t 3 \u2022 (1 -U 1 -U 2 ) -(C 1 -U 1 (C 1 + C 2 ) + C 2 -U 2 C 2 ) = 0.3t 3 -2.8 = 8. \u2022 For \u03c0 2 , the schedulability condition in Lemma 1 shows that task \u03c4 3 in Example 4 can meet the deadline if C 3 \u2264 t 3 \u2022 (1 -U 2 -U 1 ) -(C 2 -U 2 (C 2 + C 1 ) + C 1 -U 1 C 1 ) = 0.3t 3 -2.6 = 8.2.", "formula_coordinates": [7.0, 328.96, 69.11, 242.14, 75.4]}, {"formula_id": "formula_39", "formula_text": "k-1 i=1 \u03b1 i U i - k-1 i=1 \u03b2iCi t k + \u03b1iUi( k-1 =i \u03b2 C ) t k", "formula_coordinates": [7.0, 328.56, 371.57, 242.54, 30.41]}, {"formula_id": "formula_40", "formula_text": "\u03b2 h C h \u03b1 h U h < \u03b2 h+1 C h+1 \u03b1 h+1 U h+1 . Let us now examine the difference of k-1 i=1 \u03b1iUi( k-1 =i \u03b2 C ) t k", "formula_coordinates": [7.0, 328.56, 423.77, 242.54, 32.71]}, {"formula_id": "formula_41", "formula_text": "\u03b1 h U h ( k-1 =h \u03b2 C )+\u03b1 h+1 U h+1 ( k-1 =h \u03b2 C", "formula_coordinates": [7.0, 319.0, 515.96, 178.84, 14.11]}, {"formula_id": "formula_42", "formula_text": "((\u03b1 h U h \u03b2 h+1 C h+1 -\u03b1 h+1 U h+1 \u03b2 h C h ) =\u03b1 h \u03b1 h+1 U h U h+1 \u03b2 h+1 C h+1 \u03b1 h+1 U h+1 - \u03b2 h C h \u03b1 h U h > 0.", "formula_coordinates": [7.0, 346.84, 547.57, 196.42, 36.96]}, {"formula_id": "formula_43", "formula_text": "< \u03b2 i C i \u2264 \u03b2U i t k for any i = 1, 2, . . . , k -1, 0 < t k , \u03b1 k-1 i=1 U i \u2264 1, and \u03b2 k-1 i=1 U i \u2264 1. Lemma 3.", "formula_coordinates": [8.0, 48.96, 299.0, 252.1, 49.08]}, {"formula_id": "formula_44", "formula_text": "C k t k \u22641 -(\u03b1 + \u03b2) k-1 i=1 Ui + \u03b1\u03b2 k-1 i=1 Ui( k-1 =i U )(16)", "formula_coordinates": [8.0, 55.5, 385.74, 245.56, 27.06]}, {"formula_id": "formula_45", "formula_text": "=1 -(\u03b1 + \u03b2) k-1 i=1 Ui + 0.5\u03b1\u03b2 ( k-1 i=1 Ui) 2 + ( k-1 i=1 U 2 i )(17)", "formula_coordinates": [8.0, 70.41, 416.44, 230.66, 26.87]}, {"formula_id": "formula_46", "formula_text": "k-1 i=1 U i ( k-1 =i U ) = 0.5 ( k-1 i=1 U i ) 2 + ( k-1 i=1 U 2 i ) . This condition clearly holds when k = 2 since U 2 1 = 0.5(U 2 1 + U 2 1", "formula_coordinates": [8.0, 48.96, 518.36, 252.1, 39.14]}, {"formula_id": "formula_47", "formula_text": "k-1 i=1 U i ( k-1 =i U ) = k-1 i=1 U 2 i + k-2 i=1 U i ( k-1 =i+1 U ) = 1 k-1 i=1 U 2 i + 0.5 \uf8eb \uf8ed k-1 i=1 U i 2 - k-1 i=1 U 2 i \uf8f6 \uf8f8 = 0.5 ( k-1 i=1 U i ) 2 + ( k-1 i=1 U 2 i ) ,", "formula_coordinates": [8.0, 73.36, 563.97, 203.3, 103.77]}, {"formula_id": "formula_48", "formula_text": "k-2 i=1 U i ( k-1 =i+1 U ) = k-1 i=2 U i ( i-1 =1 U ) = 0.5 k-1 i=1 U i 2 - k-1 i=1 U 2 i .", "formula_coordinates": [8.0, 59.48, 674.19, 241.59, 32.38]}, {"formula_id": "formula_49", "formula_text": "k-1 i=1 Ui \u2264 k -1 k \uf8eb \uf8ed \u03b1 + \u03b2 -(\u03b1 + \u03b2) 2 -2\u03b1\u03b2(1 -C k t k ) k k-1 \u03b1\u03b2 \uf8f6 \uf8f8 .(18)", "formula_coordinates": [8.0, 320.53, 124.76, 253.63, 40.33]}, {"formula_id": "formula_50", "formula_text": "(\u03b1 + \u03b2)x + 0.5\u03b1\u03b2(x 2 + k-1 i=1 U 2 i ). That is, only the last term 0.5\u03b1\u03b2( k-1 i=1 U 2 i ) depends on how U i values are actually assigned. Moreover, k-1 i=1 U 2 i is a well-known convex function with respect to U 1 , U 2 , . . . , U k-1 . That is, \u03c1U 2 i + (1 -\u03c1)U 2 j \u2265 (\u03c1U i + (1 -\u03c1)U j ) 2 for any 0 \u2264 \u03c1 \u2264 1.", "formula_coordinates": [8.0, 319.0, 221.92, 252.11, 62.19]}, {"formula_id": "formula_51", "formula_text": "k-1 i=1 U 2 i is minimized when U 1 = U 2 = \u2022 \u2022 \u2022 = U k-1 = x k-1 .", "formula_coordinates": [8.0, 319.0, 284.19, 252.1, 25.52]}, {"formula_id": "formula_52", "formula_text": "infimum x s. t. C k t k > 1 -(\u03b1 + \u03b2)x + 0.5\u03b1\u03b2 x 2 + x 2 k -1 .", "formula_coordinates": [8.0, 332.09, 343.98, 225.93, 37.36]}, {"formula_id": "formula_53", "formula_text": "k-1", "formula_coordinates": [8.0, 449.09, 387.93, 14.6, 6.12]}, {"formula_id": "formula_54", "formula_text": "0 = 1 -C k t k -(\u03b1 + \u03b2)x + 0.5\u03b1\u03b2 k k-1 x 2 .", "formula_coordinates": [8.0, 319.0, 433.17, 158.93, 14.37]}, {"formula_id": "formula_55", "formula_text": "C k t k + k-1 i=1 Ui \u2264 \uf8f1 \uf8f4 \uf8f4 \uf8f4 \uf8f2 \uf8f4 \uf8f4 \uf8f4 \uf8f3 k-1 k \uf8eb \uf8ed \u03b1 + \u03b2 -(\u03b1 + \u03b2) 2 -2\u03b1\u03b2 k k-1 \u03b1\u03b2 \uf8f6 \uf8f8 , if k > (\u03b1+\u03b2) 2 -1 \u03b1 2 +\u03b2 2 -1 and \u03b1 2 + \u03b2 2 > 1 1 + (k-1)((\u03b1+\u03b2-1)-1 2 (\u03b1+\u03b2) 2 +0.5) k\u03b1\u03b2 otherwise(19)", "formula_coordinates": [8.0, 320.19, 519.5, 259.5, 87.64]}, {"formula_id": "formula_56", "formula_text": "(\u03b1 + \u03b2) 2 -2\u03b1\u03b2 k k-1 = (\u03b1 + \u03b2) 2 -2\u03b1\u03b2 -2\u03b1\u03b2 1 k-1", "formula_coordinates": [8.0, 328.96, 650.55, 242.14, 31.63]}, {"formula_id": "formula_57", "formula_text": "\u03b1+\u03b2-\u03b1 2 +\u03b2 2 +2\u03b1\u03b2 C k t k \u03b1\u03b2 when k \u2192 \u221e. The right-hand side of Eq. (19) (when \u03b1 2 + \u03b2 2 > 1) converges to \u03b1+\u03b2- \u221a \u03b1 2 +\u03b2 2 \u03b1\u03b2 when k \u2192 \u221e.", "formula_coordinates": [9.0, 48.96, 68.34, 252.1, 46.86]}, {"formula_id": "formula_58", "formula_text": "< \u03b1 i \u2264 \u03b1, 0 < \u03b2 i \u2264 \u03b2 for any i = 1, 2, . . . , k -1, 0 < t k and k-1 i=1 \u03b1 i U i < 1, the response time to execute C k for task \u03c4 k is at most C k + k-1 i=1 \u03b2 i C i - k-1 i=1 \u03b1 i U i ( k-1 =i \u03b2 C ) 1 - k-1 i=1 \u03b1 i U i . (20", "formula_coordinates": [9.0, 48.96, 206.3, 252.1, 77.32]}, {"formula_id": "formula_59", "formula_text": ")", "formula_coordinates": [9.0, 296.91, 264.04, 4.15, 8.64]}, {"formula_id": "formula_60", "formula_text": "k-1 i=1 \u03b1 i U i ( k-1 =i \u03b2 C", "formula_coordinates": [9.0, 59.48, 636.8, 84.31, 14.11]}, {"formula_id": "formula_61", "formula_text": "k-1 i=1 \u03b1 i U i ( k-1 =i \u03b2 C", "formula_coordinates": [9.0, 70.88, 673.49, 84.31, 14.11]}, {"formula_id": "formula_62", "formula_text": "k-1 i=1 Ci D k \u2264 1 and C k D k \u2264 1 - k-1 i=1 U i - k-1 i=1 C i D k + k-1 i=1 U i ( k-1 =i C ) D k ,(21)", "formula_coordinates": [9.0, 329.42, 227.08, 241.68, 52.39]}, {"formula_id": "formula_63", "formula_text": "C k D k \u2264 1 -2 k-1 i=1 U i + 0.5 ( k-1 i=1 U i ) 2 + ( k-1 i=1 U 2 i )(22)", "formula_coordinates": [9.0, 333.7, 385.45, 237.4, 30.32]}, {"formula_id": "formula_64", "formula_text": "k-1 i=1 U i \u2264 k -1 k \uf8eb \uf8ed 2 -4 - 2k(1 -C k D k ) k -1 \uf8f6 \uf8f8 (23", "formula_coordinates": [9.0, 340.68, 433.94, 226.27, 33.53]}, {"formula_id": "formula_65", "formula_text": ")", "formula_coordinates": [9.0, 566.95, 447.88, 4.15, 8.64]}, {"formula_id": "formula_66", "formula_text": "C k D k + k-1 i=1 U i \u2264 k-1 k 2 -4 -2k k-1 if k > 3 1 -k-1 2k if k \u2264 3(24)", "formula_coordinates": [9.0, 326.05, 488.79, 245.06, 31.41]}, {"formula_id": "formula_67", "formula_text": "C i = U i T i \u2264 U i T k .", "formula_coordinates": [9.0, 319.0, 531.67, 252.1, 20.61]}, {"formula_id": "formula_68", "formula_text": "hC k + k-1 i=1 t T i C i \u2264 t,", "formula_coordinates": [10.0, 124.46, 375.87, 101.1, 30.32]}, {"formula_id": "formula_69", "formula_text": "C k = D k T k C k + \u03c4i\u2208hp2(\u03c4 k ) C i , relative deadline D k = D k ,", "formula_coordinates": [10.0, 48.96, 452.72, 252.1, 25.72]}, {"formula_id": "formula_70", "formula_text": "k * -1 i=1 Ci D k \u2264 1 and C k D k \u2264 1- k * -1 i=1 U i - k * -1 i=1 C i D k + k * -1 i=1 U i ( k * -1 =i C ) D k ,(25)", "formula_coordinates": [10.0, 48.96, 514.92, 252.11, 61.48]}, {"formula_id": "formula_71", "formula_text": "in which C k = D k T k C k + \u03c4i\u2208hp2(\u03c4 k ) C i ,", "formula_coordinates": [10.0, 48.96, 585.32, 188.85, 14.37]}, {"formula_id": "formula_72", "formula_text": "D k Ti -1 T i .", "formula_coordinates": [10.0, 144.69, 613.22, 53.72, 13.7]}, {"formula_id": "formula_73", "formula_text": "t k = hC k + k-1 i=1 t i U i + k-1 i=1 C i ,(26)", "formula_coordinates": [10.0, 381.72, 238.73, 189.38, 30.32]}, {"formula_id": "formula_74", "formula_text": "with 0 \u2264 t 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 t k and hC k + k-1 i=1 t i U i + j-1 i=1 C i > t j ,\u2200j = 1, 2, . . . , k -1.(27)", "formula_coordinates": [10.0, 319.0, 275.41, 252.1, 47.5]}, {"formula_id": "formula_75", "formula_text": "k-1 i=1 U i \u2264 1.", "formula_coordinates": [10.0, 434.8, 409.55, 48.38, 14.11]}, {"formula_id": "formula_76", "formula_text": "R k,h \u2264 hC k + k-1 i=1 C i - k-1 i=1 U i ( k-1 =i C ) 1 - k-1 i=1 U i , (28", "formula_coordinates": [10.0, 336.18, 438.58, 230.77, 29.75]}, {"formula_id": "formula_77", "formula_text": ")", "formula_coordinates": [10.0, 566.95, 448.75, 4.15, 8.64]}, {"formula_id": "formula_78", "formula_text": "k-1 i=1 U i < 1. The case when k-1 i=1 U i = 1 has a safe upper bound R k,h = \u221e in Eq. (28). Theorem 4. Suppose that k i=1 U i \u2264 1. The worst-case response time of task \u03c4 k is at most R k \u2264 C k + k-1 i=1 C i - k-1 i=1 U i ( k-1 =i C ) 1 - k-1 i=1 U i , (29", "formula_coordinates": [10.0, 319.0, 515.15, 252.1, 100.63]}, {"formula_id": "formula_79", "formula_text": ")", "formula_coordinates": [10.0, 566.95, 596.19, 4.15, 8.64]}, {"formula_id": "formula_80", "formula_text": "C k 1-k-1 i=1 Ui -T k = C k -(1-k-1 i=1 Ui)T k 1-k-1 i=1 Ui", "formula_coordinates": [10.0, 408.73, 685.28, 158.11, 20.03]}, {"formula_id": "formula_81", "formula_text": "Case 1: If k i=1 U i < 1, then C k -(1-k-1 i=1 Ui)T k 1-k-1 i=1 Ui < C k -U k T k 1-k-1 i=1 Ui = 0. Therefore, R k,h -(h -1)", "formula_coordinates": [10.0, 319.0, 716.34, 252.1, 36.02]}, {"formula_id": "formula_82", "formula_text": "Case 2: If k i=1 U i = 1, then we know that C k -(1-k-1 i=1 Ui)T k 1-k-1 i=1 Ui = 0. Therefore, R k,h -(h -1)T k remains the same regardless of h.", "formula_coordinates": [11.0, 48.96, 83.83, 252.11, 40.95]}, {"formula_id": "formula_83", "formula_text": "k i=1 U i \u2264 1 and C k D k \u2264 1 - k-1 i=1 U i - k-1 i=1 C i D k + k-1 i=1 U i ( k-1 =i C ) D k ,(30)", "formula_coordinates": [11.0, 55.23, 202.73, 245.83, 50.88]}, {"formula_id": "formula_84", "formula_text": "C k + k-1 i=1 Ci-k-1 i=1 UiCi 1-k-1 i=1 Ui", "formula_coordinates": [11.0, 140.59, 314.2, 93.99, 20.03]}, {"formula_id": "formula_85", "formula_text": "W carry i (t) = C i 0 < t < C i C i + t-Ci Ti C i otherwise,(31)", "formula_coordinates": [11.0, 73.06, 563.66, 228.01, 26.99]}, {"formula_id": "formula_86", "formula_text": "W normal i (t) = t T i C i .(32)", "formula_coordinates": [11.0, 124.68, 606.88, 176.38, 23.23]}, {"formula_id": "formula_87", "formula_text": "\u22030 < t \u2264 T k , C k + ( \u03c4i\u2208T C i ) + ( k-1 i=1 W normal i (t)) M \u2264 t. (33", "formula_coordinates": [11.0, 49.69, 686.51, 250.64, 33.42]}, {"formula_id": "formula_88", "formula_text": ")", "formula_coordinates": [11.0, 296.91, 711.3, 4.15, 8.64]}, {"formula_id": "formula_89", "formula_text": "for all T \u2286 hp(\u03c4 k ) with |T | = M -1.", "formula_coordinates": [11.0, 319.0, 58.12, 165.03, 9.68]}, {"formula_id": "formula_90", "formula_text": "k-1 i=1 C i \u2264 M T k and U k \u2264 1- \u03c4 i \u2208T Ci M T k - k-1 i=1 Ui M - k-1 i=1 Ci M T k + k-1 i=1 (Ui k-1 =i C ) M 2 T k . (34", "formula_coordinates": [11.0, 319.0, 112.36, 252.1, 55.31]}, {"formula_id": "formula_91", "formula_text": ")", "formula_coordinates": [11.0, 567.37, 159.89, 3.73, 7.77]}, {"formula_id": "formula_92", "formula_text": "\u03c4 k from C k to C k = C k + \u03c4 i \u2208T Ci M . Moreover, we have \u03b1 i = 1 M and \u03b2 i = 1 M for every task \u03c4 i \u2208 hp(\u03c4 k ) in this case.", "formula_coordinates": [11.0, 319.0, 306.69, 252.1, 37.36]}, {"formula_id": "formula_93", "formula_text": "\u03b2 i = 1 M , we know that task \u03c4 k is schedulable by global RM if k-1 i=1 Ci M \u2264 T k and C k + \u03c4 i \u2208T C i M T k \u2264 1- k-1 i=1 Ui M - k-1 i=1 Ci M T k + k-1 i=1 (Ui k-1 =i C ) M 2 T k .(35)", "formula_coordinates": [11.0, 319.0, 401.7, 252.7, 67.96]}, {"formula_id": "formula_94", "formula_text": "\u2022 QB-BC (from k 2 Q): Eq. (", "formula_coordinates": [12.0, 58.92, 222.34, 115.9, 10.55]}, {"formula_id": "formula_95", "formula_text": "from k-1 i=1 (U i k-1 =i C ) M 2 T k to k i=1 (U i k =i C ) M 2 T k", "formula_coordinates": [12.0, 48.96, 661.63, 163.92, 17.22]}, {"formula_id": "formula_96", "formula_text": "H(x) = x + 1 - (\u03b1 + \u03b2)x + 0.5\u03b1\u03b2(x 2 + x 2 k-1 ). By finding dH(x) dx = 1 -(\u03b1 + \u03b2) + k\u03b1\u03b2x k-1 = 0, we know that x = (k-1)(\u03b1+\u03b2-1)", "formula_coordinates": [14.0, 48.96, 157.74, 252.1, 46.97]}, {"formula_id": "formula_97", "formula_text": "y =1 -x \u03b1 + \u03b2 - 0.5k\u03b1\u03b2 (k-1)(\u03b1+\u03b2-1) k\u03b1\u03b2 k -1 =1 - (k -1)(\u03b1 + \u03b2 -1) k\u03b1\u03b2 (0.5(\u03b1 + \u03b2 + 1)) =1 - 0.5(k -1) (\u03b1 + \u03b2) 2 -1 k\u03b1\u03b2 . (36", "formula_coordinates": [14.0, 82.26, 211.9, 214.65, 83.8]}, {"formula_id": "formula_98", "formula_text": ")", "formula_coordinates": [14.0, 296.91, 280.44, 4.15, 8.64]}, {"formula_id": "formula_99", "formula_text": "y < 0 is equivalent to testing (1 -1 k ) (\u03b1 + \u03b2) 2 -1 > 2\u03b1\u03b2, which implies to test whether \u03b1 2 +\u03b2 2 -1 > 1 k (\u03b1 + \u03b2) 2 -1 . If \u03b1 2 + \u03b2 2 \u2264 1, then y \u2265 0 since \u03b1 2 + \u03b2 2 -1 \u2264 0 \u2264 1 k (\u03b1 + \u03b2)", "formula_coordinates": [14.0, 48.96, 355.45, 252.1, 47.99]}, {"formula_id": "formula_100", "formula_text": "Case 1: If \u03b1 2 + \u03b2 2 > 1 and k > (\u03b1+\u03b2) 2 -1 \u03b1 2 +\u03b2 2 -1", "formula_coordinates": [14.0, 48.96, 409.57, 179.5, 16.01]}, {"formula_id": "formula_101", "formula_text": "Case 2: If \u03b1 2 + \u03b2 2 \u2264 1 or k \u2264 (\u03b1+\u03b2) 2 -1 \u03b1 2 +\u03b2 2 -1", "formula_coordinates": [14.0, 48.96, 467.67, 171.96, 16.01]}, {"formula_id": "formula_102", "formula_text": "sup C k + k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i (37a) such that C k + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i > t * j , \u2200j = 1, . . . , k -1, (37b) t * j \u2265 0, \u2200j = 1, . . . , k -1,(37c)", "formula_coordinates": [14.0, 59.1, 573.23, 241.97, 82.84]}, {"formula_id": "formula_103", "formula_text": "maximize C k + k-1 i=1 \u03b1 i t * i U i + k-1 i=1 \u03b2 i C i (38a) such that C k + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i \u2265 t * j , \u2200j = 1, . . . , k -1. (38b)", "formula_coordinates": [14.0, 323.82, 72.75, 247.28, 53.78]}, {"formula_id": "formula_104", "formula_text": "\u2020 1 , t \u2020 2 , . . . , t \u2020 k-1", "formula_coordinates": [14.0, 513.3, 187.17, 57.3, 13.91]}, {"formula_id": "formula_105", "formula_text": "t = max{t \u2020 1 , t \u2020 2 , . . . , t \u2020 k-1 }.", "formula_coordinates": [14.0, 319.14, 209.92, 111.77, 13.91]}, {"formula_id": "formula_106", "formula_text": "C k + t k-1 i=1 \u03b1 i U i + k-1 i=1 \u03b2 i C i \u2265 C k + k-1 i=1 \u03b1 i t \u2020 i U i + k-1 i=1 \u03b2 i C i \u2265 t.", "formula_coordinates": [14.0, 319.0, 238.37, 262.13, 30.32]}, {"formula_id": "formula_107", "formula_text": "C k + k-1 i=1 \u03b2iCi 1-k-1 i=1 \u03b1iUi . That is, any feasible solution of Eq. (38) has t * j \u2264 C k + k-1 i=1 \u03b2iCi 1-k-1 i=1 \u03b1iUi for any j = 1, 2, . . . , k -1. Under the assumption that k-1 i=1 \u03b1 i U i < 1 and 0 \u2264 k-1 i=1 \u03b2 i C i ,", "formula_coordinates": [14.0, 319.0, 275.12, 252.1, 65.23]}, {"formula_id": "formula_108", "formula_text": "C k + k-1 i=1 \u03b1 i t * i U i + j-1 i=1 \u03b2 i C i = t * j for every j = 1, 2, . . . , k -1.", "formula_coordinates": [14.0, 329.51, 358.83, 241.59, 23.15]}, {"formula_id": "formula_109", "formula_text": "\u2200j = 2, 3, . . . , k -1, t * j -t * j-1 = \u03b2 j-1 C j-1 .(39)", "formula_coordinates": [14.0, 335.26, 430.29, 235.84, 12.69]}, {"formula_id": "formula_110", "formula_text": "t * 1 = C k + k-1 i=1 \u03b1 i U i (t * 1 + i-1 =0 \u03b2 C ),(40)", "formula_coordinates": [14.0, 370.51, 458.04, 200.59, 30.55]}, {"formula_id": "formula_111", "formula_text": "t * 1 = C k + k-1 i=1 \u03b1 i U i ( i-1 =0 \u03b2 C ) 1 - k-1 i=1 \u03b1 i U i .(41)", "formula_coordinates": [14.0, 368.96, 521.05, 202.14, 29.74]}, {"formula_id": "formula_112", "formula_text": "k-1 i=1 \u03b1 i U i < 1.", "formula_coordinates": [14.0, 357.2, 565.19, 67.03, 14.11]}, {"formula_id": "formula_113", "formula_text": "t * 1 + k-1 i=1 \u03b2 i C i = C k + k-1 i=1 \u03b1 i U i ( i-1 =0 \u03b2 C ) 1 -k-1 i=1 \u03b1 i U i + k-1 i=1 \u03b2 i C i(42)", "formula_coordinates": [14.0, 326.14, 610.4, 244.96, 25.0]}, {"formula_id": "formula_114", "formula_text": "= C k + k-1 i=1 \u03b2 i C i -k-1 i=1 \u03b1 i U i ( k-1 =i \u03b2 C ) 1 -k-1 i=1 \u03b1 i U i(43)", "formula_coordinates": [14.0, 378.22, 638.04, 192.88, 24.55]}, {"formula_id": "formula_115", "formula_text": "\u2203t with 0 < t \u2264 D k and C k + \u03c4i\u2208hp(\u03c4 k ) t T i C i \u2264 t,(44)", "formula_coordinates": [15.0, 53.94, 85.7, 247.12, 27.94]}, {"formula_id": "formula_116", "formula_text": "C k + \u03c4i\u2208hp2(\u03c4 k ) C i + \u03c4i\u2208hp1(\u03c4 k ) t T i C i \u2264 t.(45)", "formula_coordinates": [15.0, 83.38, 201.37, 217.68, 27.94]}, {"formula_id": "formula_117", "formula_text": "C k = C k + \u03c4i\u2208hp2(\u03c4 k ) C i , relative deadline D k = D k , and period T k = D k .", "formula_coordinates": [15.0, 48.96, 248.39, 252.1, 23.2]}, {"formula_id": "formula_118", "formula_text": "k * -1 i=1 Ci D k \u2264 1 and C k D k \u2264 1- k * -1 i=1 U i - k * -1 i=1 C i D k + k * -1 i=1 U i ( k * -1 =i C ) D k ,(46)", "formula_coordinates": [15.0, 55.14, 350.58, 245.93, 54.52]}, {"formula_id": "formula_119", "formula_text": "D k Ti -1 T i .", "formula_coordinates": [15.0, 182.66, 423.98, 53.72, 13.7]}, {"formula_id": "formula_120", "formula_text": "Setting t i = D k Ti", "formula_coordinates": [15.0, 99.47, 452.88, 81.82, 13.7]}, {"formula_id": "formula_121", "formula_text": "Lemma 9. Let \u2206 max k be max k-1 j=1 {U j , C k D k }.", "formula_coordinates": [15.0, 319.0, 167.08, 189.87, 14.48]}, {"formula_id": "formula_122", "formula_text": "\u2200y \u2265 0, (\u22000 \u2264 \u03c9 i \u2264 T i , \u2200\u03c4 i \u2208 hp(\u03c4 k )) , \u2203t with 0 < t \u2264 D k + y such that \u2206 max k \u2022 (D k + y) + k-1 i=1 \u03c9 i \u2022 U i + t-\u03c9i Ti C i M \u2264 t.", "formula_coordinates": [15.0, 320.94, 220.21, 259.6, 43.42]}, {"formula_id": "formula_123", "formula_text": "\u2264 \u03c9 i \u2264 T i such that for all 0 < t \u2264 D k + y, the condition \u2206 max k \u2022 (D k + y) + k-1 i=1 \u03c9i\u2022Ui+ t-\u03c9 i T i Ci M > t holds.", "formula_coordinates": [15.0, 319.0, 297.08, 252.1, 41.01]}, {"formula_id": "formula_124", "formula_text": "\u03c3 < (z -1 -z ) \u2022 \u00db \u2264 (z -1 -z ) \u2022 \u2206 max k .", "formula_coordinates": [16.0, 84.26, 95.87, 181.5, 13.14]}, {"formula_id": "formula_125", "formula_text": "* =1 \u03c3 < * =1 (z -1 -z ) \u2022 \u2206 max k = (z 0 -z * ) \u2022 \u2206 max k .", "formula_coordinates": [16.0, 69.13, 175.51, 215.59, 32.2]}, {"formula_id": "formula_126", "formula_text": "W i (t) = (d i -z * ) \u2022 U i + t -(d i -z * ) T i C i .(47)", "formula_coordinates": [16.0, 69.07, 463.4, 232.0, 23.22]}, {"formula_id": "formula_127", "formula_text": "(necessary) condition \u2206 max k (z 0 -z * ) + \u03c4 i \u2208hp(\u03c4 k ) W i (t) M > t for all 0 < t \u2264 z * -z 0 for the unschedulability of job J 1 .", "formula_coordinates": [16.0, 48.96, 542.0, 252.1, 26.62]}, {"formula_id": "formula_128", "formula_text": "< t \u2264 D k + y with \u2206 max k (D k + y) + \u03c4 i \u2208hp(\u03c4 k ) \u03c9i\u2022Ui+ t-\u03c9 i T i Ci M \u2264 t.", "formula_coordinates": [16.0, 48.96, 627.55, 252.1, 31.63]}, {"formula_id": "formula_129", "formula_text": "U max k \u2264 1 - 2 M k-1 i=1 U i + 0.5 M 2 ( k-1 i=1 U i ) 2 + ( k-1 i=1 U 2 i ) (48) or k-1 j=1 U j M \u2264 k -1 k 2 -2 + 2U max k k k -1 .(49)", "formula_coordinates": [16.0, 319.0, 379.52, 252.1, 74.68]}, {"formula_id": "formula_130", "formula_text": "\u03c9 i \u2022 U i + tj -\u03c9i Ti C i \u2264 \u03c9 i \u2022 U i + ( ti-\u03c9i Ti + 1)C i = t i U i + C i . If i \u2265 j, then \u03c9 i \u2022 U i + tj -\u03c9i Ti C i \u2264 \u03c9 i \u2022 U i + ( ti-\u03c9i Ti )C i = t i U i .", "formula_coordinates": [16.0, 319.0, 548.4, 252.1, 50.47]}, {"formula_id": "formula_131", "formula_text": "U max k (T k + y) + k-1 i=1 \u03c9 i \u2022 U i + tj -\u03c9i Ti C i M (50) \u2264U max k t k + k-1 i=1 U i t i + j-1 i=1 C i M \u2264 t j .(51)", "formula_coordinates": [16.0, 339.89, 629.53, 231.21, 55.24]}, {"formula_id": "formula_132", "formula_text": "C i = U i T i \u2264 U i T k \u2264 U i (T k +y) = U i t k for i = 1, 2, . . . ,", "formula_coordinates": [16.0, 319.0, 707.67, 251.44, 19.92]}, {"formula_id": "formula_133", "formula_text": "U max k t k + k-1 i=1 \u03b1 i U i t i + j-1 i=1 \u03b2U i t k \u2264 t j ,(52)", "formula_coordinates": [17.0, 93.21, 85.98, 207.85, 30.79]}, {"formula_id": "formula_134", "formula_text": "\u2206 max k \u2264 1 - 1 M k-1 i=1 U i + C i D k + 1 M 2 k-1 i=1 U i ( k-1 =i C D k ) ,(53", "formula_coordinates": [17.0, 48.96, 464.72, 252.11, 39.14]}, {"formula_id": "formula_135", "formula_text": "t k = D k + y, \u03b1 i = 1", "formula_coordinates": [17.0, 48.96, 550.18, 252.1, 20.61]}, {"formula_id": "formula_136", "formula_text": "\u2206 max k \u2264 1 -1 M k-1 i=1 U i + Ci D k +y + 1 M 2 k-1 i=1 U i ( k-1 =i C D k +y )", "formula_coordinates": [17.0, 50.16, 586.78, 250.91, 33.16]}, {"formula_id": "formula_137", "formula_text": "k-1 i=1 U i \u2264 M , we know that C i i =1 U M \u2264 C i . Therefore 8 , - 1 M k-1 i=1 C i D k + y + 1 M 2 k-1 i=1 U i ( k-1 =i C D k + y ) = 1 D k + y 1 M - k-1 i=1 C i + k-1 i=1 C i i =1 U M", "formula_coordinates": [17.0, 48.96, 621.04, 252.1, 99.99]}, {"formula_id": "formula_138", "formula_text": "(k -1) there is k-1 i=1 a i k-1 =i b = k-1 i=1 b i i =1 a . x z J z -1 J -1 J3 z2 J2 z1 J1 z0 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022 \u2022", "formula_coordinates": [17.0, 94.28, 55.5, 474.45, 695.9]}, {"formula_id": "formula_139", "formula_text": "Proof: If k i=1 U i \u2264 M or k-1 i=1 Ci D k \u2264 M is violated,", "formula_coordinates": [17.0, 338.92, 218.58, 232.18, 15.23]}, {"formula_id": "formula_140", "formula_text": "\u2206 max k >1 - 1 M k-1 i=1 U i + C i D k + 1 M 2 k-1 i=1 U i ( k-1 =i C D k ) \u22651 - 1 M k-1 i=1 U i + C i D k .", "formula_coordinates": [17.0, 321.1, 271.52, 240.01, 64.34]}, {"formula_id": "formula_141", "formula_text": "\u2206 max k > 1 3 , 1 M k-1 i=1 U i > 1 3 , or 1 M k-1 i=1 Ci D k > 1 3", "formula_coordinates": [17.0, 320.19, 351.25, 250.91, 28.52]}, {"formula_id": "formula_142", "formula_text": "k j=1 U j \u2264 M 2 (1-U max k )+U max k for global RM by Bertogna et al. [10], since (1-x) 2 \u2264 2 - \u221a 2 + 2x when 0 \u2264 x \u2264 1.", "formula_coordinates": [17.0, 319.0, 416.53, 252.1, 28.97]}, {"formula_id": "formula_143", "formula_text": "hC k + k-1 i=1 t + L i T i C i \u2264 t.", "formula_coordinates": [18.0, 116.1, 223.07, 117.83, 30.32]}, {"formula_id": "formula_144", "formula_text": "R k,h -max{(h-1)T k -L k , 0}.", "formula_coordinates": [18.0, 175.03, 271.39, 126.04, 9.65]}, {"formula_id": "formula_145", "formula_text": "job if R k,h \u2264 max{hT k -L k , 0}.", "formula_coordinates": [18.0, 48.96, 282.35, 252.1, 20.61]}, {"formula_id": "formula_146", "formula_text": "t k = hC k + k-1 i=1 L i U i + k-1 i=1 t i U i + k-1 i=1 C i ,(54)", "formula_coordinates": [18.0, 87.35, 327.2, 213.71, 30.32]}, {"formula_id": "formula_147", "formula_text": "\u2264 t 1 \u2264 t 2 \u2264 \u2022 \u2022 \u2022 \u2264 t k-1 \u2264 t k and hC k + k-1 i=1 LiUi + k-1 i=1 tiUi + j-1 i=1", "formula_coordinates": [18.0, 54.66, 373.97, 246.21, 43.93]}, {"formula_id": "formula_148", "formula_text": "t i = ( R k,h +Li Ti -1)T i -L i .", "formula_coordinates": [18.0, 48.96, 453.24, 252.1, 25.9]}, {"formula_id": "formula_149", "formula_text": "R k,h +Li Ti -1)C i = ti+Li Ti T i U i = t i U i + L i U i .", "formula_coordinates": [18.0, 77.58, 491.36, 189.4, 14.67]}, {"formula_id": "formula_150", "formula_text": "Lemma 11. Suppose that k-1 i=1 U i \u2264 1. Then, for any h \u2265 1 and C k > 0, we have R k,h \u2264 hC k + k-1 i=1 (C i + L i U i ) - k-1 i=1 U i ( k-1 =i C ) 1 - k-1 i=1 U i , (56", "formula_coordinates": [18.0, 48.96, 584.87, 252.11, 66.37]}, {"formula_id": "formula_151", "formula_text": "k-1 i=1 U i < 1. The case when k-1 i=1 U i = 1 has a safe upper bound R k,h = \u221e in Eq. (56). Theorem 10. Suppose that k i=1 U i \u2264 1. The worst-case response time of task \u03c4 k is at most R k \u2264 k-1 i=1 (Ci + LiUi) -k-1 i=1 Ui( k-1 =i C ) 1 -k-1 i=1 Ui ,(57)", "formula_coordinates": [18.0, 48.96, 58.15, 522.14, 693.59]}, {"formula_id": "formula_152", "formula_text": "+ max h * C k 1 -k-1 i=1 Ui , (h * + 1)C k 1 -k-1 i=1 Ui -h * T k + L k", "formula_coordinates": [18.0, 353.88, 103.43, 197.62, 25.1]}, {"formula_id": "formula_153", "formula_text": "(h * -1)T k - L k \u2264 0, whereas h * T k -L k > 0. When h \u2264 h * , we know that max {(h * -1)T k -L k , 0} is 0. Therefore, R k,h -0 is maximized when h is set to h * for any h \u2264 h * . The first-order derivative of R k,h -((h -1)T k -L k ) with respect to h when h \u2265 h * + 1 is C k 1-k-1 i=1 Ui -T k = C k -(1-k-1 i=1 Ui)T k 1-k-1 i=1 Ui", "formula_coordinates": [18.0, 319.0, 175.81, 252.1, 100.41]}, {"formula_id": "formula_154", "formula_text": "rbf (i, q, t) = \u03b8(i,q,t) j=q C i,(j mod mi) ,(58)", "formula_coordinates": [19.0, 102.6, 75.3, 198.46, 31.18]}, {"formula_id": "formula_155", "formula_text": "\u2200q i \u2208 {0, 1, . . . , m i -1} , \u2200i = 1, 2, . . . , k -1 \u22030 < t \u2264 D k,h , C k,h + k-1 i=1 rbf (i, q i , t) \u2264 t.", "formula_coordinates": [19.0, 80.07, 205.36, 189.89, 44.23]}, {"formula_id": "formula_157", "formula_text": "C k,h + k-1 i=1 U i,k,h \u2022 t i,qi + j-1 i=1 C i,k,h \u2264 t j,qj ,(61)", "formula_coordinates": [19.0, 354.89, 86.95, 216.21, 30.79]}, {"formula_id": "formula_158", "formula_text": "C k,h D k,h \u2264 1- k-1 i=1 U i,k,h - k-1 i=1 (C i,k,h -U i,k,h ( k-1 =i C ,k,h )) D k,h ,(62", "formula_coordinates": [19.0, 320.19, 297.09, 253.95, 38.91]}, {"formula_id": "formula_159", "formula_text": "\u2206 max k \u2264 1- k-1 i=1 U max i - k-1 i=1 (C max i -U max i ( k-1 =i C max )) D k,h ,(65", "formula_coordinates": [21.0, 48.96, 201.84, 252.11, 38.91]}, {"formula_id": "formula_160", "formula_text": "C max i U max i of task \u03c4 i .", "formula_coordinates": [21.0, 131.83, 250.37, 64.74, 18.15]}, {"formula_id": "formula_161", "formula_text": "\u2206 max k (D k,h +y)+ k-1 i=1 U max i t i + j-1 i=1 C max i \u2264 t j .", "formula_coordinates": [21.0, 87.35, 332.88, 213.71, 14.11]}, {"formula_id": "formula_162", "formula_text": "k-1 i=1 U max i \u2264 1.", "formula_coordinates": [21.0, 124.01, 388.73, 60.6, 14.11]}, {"formula_id": "formula_163", "formula_text": "C k,h", "formula_coordinates": [21.0, 275.92, 441.98, 15.98, 6.79]}, {"formula_id": "formula_164", "formula_text": "U max k \u2264 1-2 k-1 i=1 U max i +0.5 ( k-1 i=1 U max i ) 2 + ( k-1 i=1 (U max i ) 2 ) , (66) or k-1 i=1 U max i \u2264 k -1 k 2 -2 + 2U max k k k -1 ,(67)", "formula_coordinates": [21.0, 48.96, 509.91, 258.84, 85.93]}, {"formula_id": "formula_165", "formula_text": "U max k + k-1 i=1 U max i \u2264 k-1 k 2 -4 -2k k-1 , if k > 3 1 -(k-1) 2k otherwise.", "formula_coordinates": [21.0, 48.96, 614.89, 250.91, 31.84]}, {"formula_id": "formula_166", "formula_text": "k i=1 U i \u2264 k-1 k 2 -4 -2k k-1 , if k > 3 1 -(k-1) 2k otherwise. (69) or 0 \u2264 1 -U k -2 k-1 i=1 U i + 0.5 ( k-1 i=1 U i ) 2 + ( k-1 i=1 U 2 i ) , (70", "formula_coordinates": [21.0, 319.0, 169.49, 252.1, 80.26]}, {"formula_id": "formula_167", "formula_text": ")", "formula_coordinates": [21.0, 566.95, 230.16, 4.15, 8.64]}], "doi": ""}
