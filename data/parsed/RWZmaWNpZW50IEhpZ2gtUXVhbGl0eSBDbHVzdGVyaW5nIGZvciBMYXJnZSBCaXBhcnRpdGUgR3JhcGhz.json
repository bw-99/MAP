{"Efficient High-Quality Clustering for Large Bipartite Graphs": "", "Renchi Yang": "", "Jieming Shi \u2217": "Hong Kong Baptist University Hong Kong SAR, China renchi@hkbu.edu.hk", "ABSTRACT": "A bipartite graph contains inter-set edges between two disjoint vertex sets, and is widely used to model real-world data, such as user-item purchase records, author-article publications, and biological interactions between drugs and proteins. \ud835\udc58 -Bipartite Graph Clustering ( \ud835\udc58 -BGC) is to partition the target vertex set in a bipartite graph into \ud835\udc58 disjoint clusters. The clustering quality is important to the utility of \ud835\udc58 -BGC in various applications like social network analysis, recommendation systems, text mining, and bioinformatics, to name a few. Existing approaches to \ud835\udc58 -BGC either output clustering results with compromised quality due to inadequate exploitation of high-order information between vertices, or fail to handle sizable bipartite graphs with billions of edges. Motivated by this, this paper presents two efficient \ud835\udc58 -BGC solutions, HOPE and HOPE+, which achieve state-of-the-art performance on large-scale bipartite graphs. HOPE obtains high scalability and effectiveness through a new \ud835\udc58 -BGC problem formulation based on the novel notion of high-order perspective (HOP) vectors and an efficient technique for low-rank approximation of HOP vectors. HOPE+ further elevates the \ud835\udc58 -BGC performance to another level with a judicious problem transformation and a highly efficient two-stage optimization framework. Two variants, HOPE+ (FNEM) and HOPE+ (SNEM) are designed when either the Frobenius norm or spectral norm is applied in the transformation. Extensive experiments, comparing HOPE and HOPE+ against 13 competitors on 10 real-world datasets, exhibit that our solutions, especially HOPE+, are superior to existing methods in terms of result quality, while being up to orders of magnitude faster. On the largest dataset MAG with 1.1 billion edges, HOPE+ is able to produce clusters with the highest clustering accuracy within 31 minutes, which is unmatched by any existing solution for \ud835\udc58 -BGC.", "CCS CONCEPTS": "\u00b7 Information systems \u2192 Clustering ; \u00b7 Computing methodologies \u2192 Cluster analysis ; \u00b7 Mathematics of computing \u2192 Computations on matrices .", "KEYWORDS": "Bipartite Graph, Clustering, Random Walk, Eigenvector", "1 INTRODUCTION": "Abipartite graph G contains two disjoint vertex sets, U and V , with only inter-set edges. Bipartite graphs are omnipresent in the real world to model the purchase/view records between customers and products, the publication relationships between authors and articles, the biological interactions between drugs and protein complexes, and the ecological relationships between plants and pollinators. \u2217 Corresponding author. Hong Kong Polytechnic University Hong Kong SAR, China jieming.shi@polyu.edu.hk Afundamental task in data mining is \ud835\udc58 -Bipartite Graph Clustering (hereafter \ud835\udc58 -BGC) which aims to group the vertices in the target vertex set, e.g. , U , into \ud835\udc58 disjoint clusters, each of which is tightlyknit, based on the interplay between the two types of vertices U and V in the bipartite graph G (the clustering on the other set V naturally follows). \ud835\udc58 -BGC finds prevalent use in various fields, including social network analysis, recommendation systems, text mining, bioinformatics, and so forth. Practical applications include clustering customers based on customers' purchasing patterns [25, 59], categorizing documents based on document-word associations [11, 12], detecting groups of genes suitable for drug repurposing in gene-drug networks [34], and many others [10, 14, 16, 28, 38, 46, 66]. One simple treatment for \ud835\udc58 -BGC is to regard a bipartite graph as a unipartite graph, and then apply canonical graph clustering methods, e.g. , [20, 39, 55], to get clustering results. However, this brute-force approach overlooks the unique topological properties of bipartite graphs with two disjoint vertex sets, and thus, yields sub-par clustering quality. As reviewed in Section 6, there exists a plethora of studies with dedicated techniques developed particularly for bipartite graph clustering under various settings [8] (see references therein). In particular, one popular methodology, projection-based methods [23, 36, 52], first projects the input bipartite graph G into a unipartite graph containing the same-typed vertices via the one-mode projection [70, 71], and then applies conventional graph clustering methods over the projected graph for vertex clustering. These methods often generate extremely dense projected graphs with \ud835\udc42 (|U| 2 ) or \ud835\udc42 (|V| 2 ) edges in the worst case [62], as shown in Figure 1(a) with a extremely dense projected graph created due to the connections from all users to the phone, rendering them inefficient. Another category of techniques extends spectral clustering [12, 31] or statistical models (e.g., stochastic block models) [32, 67] to simultaneously group vertices of both types in bipartite graphs. To our knowledge, none of these methods effectively exploit the high-order affinities between vertices (vertices can reach each other through multiple hops along the edges), which intuitively is critical for deriving high-quality clustering results and has been shown effective in unipartite graph clustering [43, 65]. Consequently, most of them compromise cluster quality. To illustrate, we consider the customer-product purchase network in Figure 1(b). Suppose that there are two clusters to discover, i.e. , \ud835\udc58 = 2. These methods may assign user D to the r.h.s cluster {E, F, G}, since doing so leads to a good graph partition with solely one cross-cluster edge (in purple), and they cannot discern the strong high-order affinity between users D and A, B, C. But, intuitively, user D is more likely to belong to the l.h.s cluster {A, B, C}, given that user D has as many as nine 3-hop paths to the basketball, football, and game console as users A, B, and C do, reflecting their similar tastes to the products. By contrast, user D possesses only one 3-hop path to either book 1 Renchi Yang and Jieming Shi Figure 1: Limitations of Existing Approaches (b) Overlook High-Order Affinities (a) Extremely Dense Projected Graphs A       B      C        D       E         F       G or skirt and zero 3-hop path to stilettos purchased by users E, F and G, which indicates that they have utterly divergent shopping preferences and should be grouped into disparate clusters. Ontop of that, existing solutions incur prohibitive computational overheads, and are hard to scale to large-scale bipartite graphs with millions of nodes and billions of edges. For instance, on an MAG bipartite graph with 1.1 billion edges, almost all competitors fail to finish clustering within 2 days in experiments. An existing strong approach, biSBM-MCMC [67] takes over one week to process MAG . Summing up, existing \ud835\udc58 -BGC methods suffer from sub-optimal clustering quality, entail tremendous computational overheads and largely fail over massive bipartite graphs, or both. To tackle the above challenges, we propose HOPE and HOPE+ that achieve superior performance for \ud835\udc58 -BGC, via a series of novel algorithmic designs and theoretical analysis over newly designed notion High-Order Perspective VEctors. Given a bipartite graph G with the target vertex set U to be clustered, it is crucial but challenging to capture the rich topological features for effective clustering. To this end, we first construct a weighted projected graph (WPG) GV over the other vertex set V of G with a new weighting scheme. Intuitively, if two vertices \ud835\udc62 \ud835\udc56 and \ud835\udc62 \ud835\udc57 in U have different (resp. similar) perspectives to WPG GV , they tend to be in different clusters (resp. the same cluster). To realize this, we define a high-order perspective (HOP) per vertex \ud835\udc62 \ud835\udc56 \u2208 U via a random walk model from \ud835\udc62 \ud835\udc56 towards the WPG GV , so as to quantify the personalized high-order semantics from \ud835\udc62 \ud835\udc56 to all vertices V in GV . Based thereon, we formulate a new \ud835\udc58 -BGC clustering objective defined using the HOP vectors of vertices in U . The direct materialization of all HOP vectors for U is rather costly, as they constitute a dense HOP matrix H \u2208 R | U|\u00d7|V| whose calculation involves an infinite series of matrix multiplications with \ud835\udc42 (|U| \u00d7 |V| 2 ) time. To mitigate the issue, we first present a base method HOPE that builds up a low-rank approximation of H with theoretical accuracy guarantees, without explicitly materializing H , and subsequently conducts clustering using the low-rank approximation as per our proposed objective. HOPE can achieve improved result quality, while being fast, compared with existing methods. Furthermore, we propose HOPE+ that surpasses HOPE and existing methods in terms of both efficiency and effectiveness. Under the hood, through rigorous theoretical analysis, HOPE+ converts our HOP-based \ud835\udc58 -BGC objective into two optimization problems to be solved via our two-stage algorithmic framework. The first problem is optimized by a certain relaxed intermediate result obtained by an efficient partial eigen-decomposition; then in the second optimization, HOPE+ derives the final cluster result by minimizing its difference to the intermediate result via two rounding algorithms, namely FNEM and SNEM, when either Frobenius norm or spectral norm is applied to quantify the difference. The complexities of HOPE, HOPE+ (FNEM), and HOPE+ (SNEM) are all linear to the size of the input bipartite graph. We empirically evaluate HOPE and HOPE+ against 13 competitors on 10 real datasets with ground-truth cluster labels. Extensive experiments exhibit that HOPE and HOPE+ obtain superior clustering quality on most datasets while being up to orders of magnitude faster. Particularly, on the billion-edge dataset MAG , HOPE+ with SNEM achieves a 22.1% conspicuous improvement in clustering accuracy and at least 9 . 5 \u00d7 speedup over existing methods. To summarize, our contributions in this paper are as follows: \u00b7 We formulate an effective \ud835\udc58 -BGC objective based on the new High-Order Perspective (HOP) vectors that preserve vertex-specific high-order information over a weighted projected graph. \u00b7 We present HOPE that efficiently solves the objective via lowrank approximation, without materializing all HOP vectors, to output high-quality clustering results. \u00b7 We further develop HOPE+ that transforms the \ud835\udc58 -BGC objective into two optimization problems that are solved by efficient technical designs. We present two variants HOPE+ (FNEM) and HOPE+ (SNEM), when Frobenius norm or spectral norm is applied. \u00b7 Extensive experiments on 10 bipartite graphs validate the superiority of our methods to efficiently obtain high-quality clusters.", "2 PROBLEM FORMULATION": "", "2.1 Notations": "Let G = (U\u222aV , E) be a weighted bipartite graph, where U and V are two disjoint vertex sets, and the edge set is E = {( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) | \ud835\udc62 \ud835\udc56 \u2208 U , \ud835\udc63 \ud835\udc57 \u2208 V} . Every edge ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) \u2208 E is associated with a nonnegative weight \ud835\udc64 ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) . The set of neighbors ( i.e. , adjacent vertices) of a vertex \ud835\udc62 \ud835\udc56 \u2208 U (resp. \ud835\udc63 \ud835\udc57 \u2208 V ) is denoted by N( \ud835\udc62 \ud835\udc56 ) = { \ud835\udc63 \ud835\udc57 | ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) \u2208 E} (resp. N( \ud835\udc63 \ud835\udc57 ) = { \ud835\udc62 \ud835\udc56 | ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) \u2208 E} ). In this paper, matrices are denoted by bold uppercase letters, e.g. , M \u2208 R \ud835\udc5b \u00d7 \ud835\udc5a with \ud835\udc5b rows and \ud835\udc5a columns. The \ud835\udc56 -th row (resp. \ud835\udc57 -th column) of M is a length\ud835\udc5a (resp. length\ud835\udc5b ) vector, written as M \ud835\udc56 (resp. M \u2217 , \ud835\udc57 ), and the entry at the \ud835\udc56 -th row and \ud835\udc57 -th column of M is denoted by M \ud835\udc56,\ud835\udc57 . The Frobenius norm of matrix M is \u2225 M \u2225 \ud835\udc39 = \u221a\ufe03 \u02dd \ud835\udc5b \ud835\udc56 = 1 \u02dd \ud835\udc5a \ud835\udc57 = 1 | M \ud835\udc56,\ud835\udc57 | 2 , and the \ud835\udc3f 2 norm of vector M \ud835\udc56 is \u2225 M \ud835\udc56 \u2225 2 = \u221a\ufe03 \u02dd \ud835\udc5a \ud835\udc57 = 1 | M \ud835\udc56,\ud835\udc57 | 2 . The trace of a square matrix M \u2208 R \ud835\udc5a \u00d7 \ud835\udc5a \u22a4 is Tr ( M ) = \u02dd \ud835\udc5a \ud835\udc56 = 1 M \ud835\udc56,\ud835\udc56 . We use M to represent the transpose of M and I to represent the identity matrix with dimension implied by the context. A matrix M is said to have orthogonal columns (resp. rows) if it satisfies M \u22a4 M = I (resp. MM \u22a4 = I ). Table 1 lists the frequently used notations throughout this paper.", "2.2 \ud835\udc58 -BGC": "Given a weighted bipartite graph G = (U\u222aV , E) , the target vertex set to cluster (either U or V ), and the number \ud835\udc58 of clusters, the goal of \ud835\udc58 -Bipartite Graph Clustering ( \ud835\udc58 -BGC) is to partition the target vertex set into \ud835\udc58 disjoint vertex clusters, \ud835\udc36 1 , \ud835\udc36 2 , ..., \ud835\udc36 \ud835\udc58 , such that the vertices in the same cluster are closely connected in G via direct or indirect connections, whereas the vertices across clusters are distant from each other [23, 32, 67]. By default, we regard U as the target vertex set to cluster. It naturally follows when V is the target. Choosing \ud835\udc58 is not a focus of this paper, and can be done by an additional step [7]. A critical challenge for \ud835\udc58 -BGC is to leverage the rich semantics hidden in the bipartite graph topology to obtain high-quality 2 Efficient High-Quality Clustering for Large Bipartite Graphs Table 1: Frequently used symbols. features of vertices for effective clustering. In the following subsections, we propose a new way to formulate the \ud835\udc58 -BGC objective. In a nutshell, we first construct a weighted projected graph (WPG) GV built over the counterparty V in Section 2.3, and then, for every vertex \ud835\udc62 \ud835\udc56 in U , we define a high-order perspective (HOP) vector (Section 2.4), which captures the personalized multi-hop information from \ud835\udc62 \ud835\udc56 over the WPG GV , and then formulate our \ud835\udc58 -BGC objective based on the HOP vectors of U (Section 2.5). Figure 2: Construction of HOP Vectors \ud835\udc071 \ud835\udc072 \ud835\udc073 \ud835\udc074 \ud835\udc075 HOPVectors Bipartite Graph \ud835\udcd6 \ud835\udc97\ud835\udfcf \ud835\udc97\ud835\udfd0 \ud835\udc97\ud835\udfd1 \ud835\udc97\ud835\udfd2 \ud835\udc97\ud835\udfcf \ud835\udc97\ud835\udfd0 \ud835\udc97\ud835\udfd1 \ud835\udc97\ud835\udfd2 \ud835\udc96\ud835\udfcf \ud835\udc96\ud835\udfd0 \ud835\udc96\ud835\udfd1 \ud835\udc96\ud835\udfd2 \ud835\udc96\ud835\udfd3 \ud835\udc96\ud835\udfcf \ud835\udc96\ud835\udfd0 \ud835\udc96\ud835\udfd1 \ud835\udc96\ud835\udfd2 \ud835\udc96\ud835\udfd3 \ud835\udc96\ud835\udfcf 0.71   0.08   0.7    0.08 0.71   0.08   0.7    0.08 0.03   0.98  0.11   0.13 0.15   0.59  0.54   0.59 0.03   0.13  0.11   0.98 \ud835\udce4 \ud835\udce5 \ud835\udca2\ud835\udcb1 Perspectives to WPG \ud835\udca2\ud835\udcb1 \ud835\udc96\ud835\udfd1 \ud835\udc96\ud835\udfd0 \ud835\udc96\ud835\udfd2 \ud835\udc96\ud835\udfd3 \ud835\udc97\ud835\udfcf \ud835\udc97\ud835\udfd0 \ud835\udc97\ud835\udfd1 \ud835\udc97\ud835\udfd2 Figure 2 exemplifies the generation of HOP vectors. In the first place, we construct the WPG GV for all vertices in V on the basis of the topology surrounding each \ud835\udc63 \ud835\udc57 in V of the input bipartite graph G . Thereafter, each vertex \ud835\udc62 \ud835\udc56 in U is represented by an HOP vector computed as per a proposed random walk model over WPG GV from \ud835\udc62 \ud835\udc56 's perspective. Intuitively, two vertices ( e.g. , \ud835\udc62 1 and \ud835\udc62 2 in Figure 2) with similar perspectives towards all vertices in the WPG GV tend to have similar HOP vectors, while \ud835\udc62 1 and \ud835\udc62 3 are with relatively different HOP vectors since their perspectives ( i.e. , connections) towards WPG GV are different. Vertices with similar HOP vectors intuitively tend to be in the same cluster.", "2.3 Weighted Projected Graph": "Inspired by the foregoing intuition, we construct a weighted projected graph (WPG) that is a unipartite graph GV solely including all vertices in V via a projection over the input bipartite graph G . Specifically, we build the WPG GV with the edge weight matrix W V by a new edge-weighting scheme applied together with the one-mode projection [70]. To facilitate the design, we define the transition probabilities \ud835\udc5d ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) from vertex \ud835\udc62 \ud835\udc56 to vertex \ud835\udc63 \ud835\udc57 , and \ud835\udc5d ( \ud835\udc63 \ud835\udc57 , \ud835\udc62 \ud835\udc56 ) from \ud835\udc63 \ud835\udc57 to \ud835\udc62 \ud835\udc56 on G as follows. Probability \ud835\udc5d ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) (resp. \ud835\udc5d ( \ud835\udc63 \ud835\udc57 , \ud835\udc62 \ud835\udc56 ) ) connotes the one-hop jump probability of a random walk starting from \ud835\udc62 \ud835\udc56 to \ud835\udc63 \ud835\udc57 (resp. from \ud835\udc63 \ud835\udc57 to \ud835\udc62 \ud835\udc56 ).  For every two vertices \ud835\udc63 \ud835\udc57 , \ud835\udc63 \ud835\udc59 \u2208 V , we connect them in GV via an edge ( \ud835\udc63 \ud835\udc57 , \ud835\udc63 \ud835\udc59 ) if both of them are connected to the same vertices in U of G , i.e. , N( \ud835\udc63 \ud835\udc57 ) \u2229 N( \ud835\udc63 \ud835\udc59 ) \u2260 \u2205 . The edge weight \ud835\udc64 V( \ud835\udc63 \ud835\udc57 , \ud835\udc63 \ud835\udc59 ) is obtained as follows. On the input bipartite graph G , apparently it requires a two-hop jump via a certain vertex \ud835\udc62 \ud835\udc56 \u2208 N( \ud835\udc63 \ud835\udc57 ) \u2229 N ( \ud835\udc63 \ud835\udc59 ) to jump from \ud835\udc63 \ud835\udc57 to \ud835\udc63 \ud835\udc59 with probability \ud835\udc5d ( \ud835\udc63 \ud835\udc57 , \ud835\udc62 \ud835\udc56 ) \u00b7 \ud835\udc5d ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc59 ) . Analogously, it needs a two-hop jump with probability \ud835\udc5d ( \ud835\udc63 \ud835\udc59 , \ud835\udc62 \ud835\udc56 ) \u00b7 \ud835\udc5d ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) from \ud835\udc63 \ud835\udc59 to \ud835\udc63 \ud835\udc57 via \ud835\udc62 \ud835\udc56 . Accordingly, the probability \ud835\udc5e ( \ud835\udc63 \ud835\udc57 , \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc59 ) that the two two-hop jumps both transit via the same vertex \ud835\udc62 \ud835\udc56 can be calculated by multiplying the two probabilities above, i.e. , \ud835\udc5d ( \ud835\udc63 \ud835\udc57 , \ud835\udc62 \ud835\udc56 ) \u00b7 \ud835\udc5d ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc59 ) . Since \ud835\udc63 \ud835\udc57 and \ud835\udc63 \ud835\udc59 mayshare multiple common neighbors \ud835\udc62 \ud835\udc56 \u2208 N( \ud835\udc63 \ud835\udc57 )\u2229 N( \ud835\udc63 \ud835\udc59 ) of G , we aggregate all such probabilities \ud835\udc5e ( \ud835\udc63 \ud835\udc57 , \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc59 ) for \ud835\udc62 \ud835\udc56 \u2208 U together, resulting in the edge weight \ud835\udc64 V( \ud835\udc63 \ud835\udc57 , \ud835\udc63 \ud835\udc59 ) of edge ( \ud835\udc63 \ud835\udc57 , \ud835\udc63 \ud835\udc59 ) in the WPG GV , as shown in Eq. (2). Notice that a square root operator is applied for taking a geometric mean of \ud835\udc5e ( \ud835\udc63 \ud835\udc57 , \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc59 ) and \ud835\udc5e ( \ud835\udc63 \ud835\udc59 , \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) and meanwhile alleviating the issue of small values.  Notice that Eq. (2) can be reorganized as follows:  Let Q \u2208 R | V | \u00d7 | U | be a matrix where the ( \ud835\udc57, \ud835\udc56 ) -th element is Q \ud835\udc57,\ud835\udc56 = \u221a\ufe01 \ud835\udc5d ( \ud835\udc63 \ud835\udc57 , \ud835\udc62 \ud835\udc56 ) \u00b7 \ud835\udc5d ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) if ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) \u2208 E , and 0 otherwise. Then Eq. (3) can be re-written as  and accordingly the edge weight matrix W V of GV is W V = QQ \u22a4 . Figure 3: Example \ud835\udc5d ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) and Q (\ud835\udc96\ud835\udc8a , \ud835\udc97 \ud835\udc8b ) \ud835\udc91(\ud835\udc96\ud835\udc8a, \ud835\udc97 \ud835\udc8b ) \ud835\udc91(\ud835\udc97\ud835\udc8b, \ud835\udc96 \ud835\udc8a ) (\ud835\udc96\ud835\udfcf, \ud835\udc97 \ud835\udfcf ) 1 \u0d57 2 1 \u0d57 2 (\ud835\udc96\ud835\udfcf, \ud835\udc97 \ud835\udfd1 ) 1 \u0d57 2 1 \u0d57 3 (\ud835\udc96\ud835\udfd0, \ud835\udc97 \ud835\udfcf ) 1 \u0d57 2 1 \u0d57 2 (\ud835\udc96\ud835\udfd0, \ud835\udc97 \ud835\udfd1 ) 1 \u0d57 2 1 \u0d57 3 (\ud835\udc96\ud835\udfd1, \ud835\udc97 \ud835\udfd0 ) 1 1 \u0d57 2 (\ud835\udc96\ud835\udfd2, \ud835\udc97 \ud835\udfd0 ) 1 \u0d57 3 1 \u0d57 2 (\ud835\udc96\ud835\udfd2, \ud835\udc97 \ud835\udfd1 ) 1 \u0d57 3 1 \u0d57 3 (\ud835\udc96\ud835\udfd2, \ud835\udc97 \ud835\udfd2 ) 1 \u0d57 3 1 \u0d57 2 (\ud835\udc96\ud835\udfd3, \ud835\udc97 \ud835\udfd2 ) 1 1 \u0d57 2 \ud835\udc10 \ud835\udc97\ud835\udfcf \ud835\udc97\ud835\udfd0 \ud835\udc97\ud835\udfd1 \ud835\udc97\ud835\udfd2 \ud835\udc96\ud835\udfcf \ud835\udc96\ud835\udfd0 \ud835\udc96\ud835\udfd1 \ud835\udc96\ud835\udfd2 \ud835\udc96\ud835\udfd3 1 \u0d57 2 1 \u0d57 2 0 0 0 0 0 1 \u0d57 2 1 \u0d57 3 0 0 0 0 0 0 1 \u0d57 2 1 \u0d57 6 1 \u0d57 6 1 \u0d57 6 1 \u0d57 6 \ud835\udc10 T \ud835\udc97\ud835\udfcf \ud835\udc97\ud835\udfd0 \ud835\udc97\ud835\udfd1 \ud835\udc97\ud835\udfd2 \ud835\udc96\ud835\udfcf \ud835\udc96\ud835\udfd0 \u2219 \ud835\udc96\ud835\udfd1 \ud835\udc96\ud835\udfd2 \ud835\udc96\ud835\udfd3 1 \u0d57 2 1 \u0d57 2 0 0 0 0 0 1 \u0d57 2 1 \u0d57 6 0 1 \u0d57 6 1 \u0d57 6 1 \u0d57 3 1 \u0d57 6 1 \u0d57 2 0 0 0 0 0 Example 2.1. Suppose that the edge weights \ud835\udc64 ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) in the bipartite graph G of Figure 2 are all 1. Then, by Eq. (1), the one-hop jump probabilities \ud835\udc5d ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) and \ud835\udc5d ( \ud835\udc63 \ud835\udc57 , \ud835\udc62 \ud835\udc56 ) of every node pair in U\u00d7 V are presented on the left of Figure 3. Then as an example, Q 3 , 1 = \u221a\ufe01 \ud835\udc5d ( \ud835\udc63 3 , \ud835\udc62 1 )\u00b7 ( \ud835\udc62 1 , \ud835\udc63 3 ) = 1 / \u221a 6. After getting Q in Figure 3, the edge weights of GV is calculated by Eq. (4). For example, \ud835\udc64 V( \ud835\udc63 1 , \ud835\udc63 3 ) = \u02dd \ud835\udc62 \ud835\udc56 \u2208U Q 1 ,\ud835\udc56 \u00d7 Q 3 ,\ud835\udc56 = 1 2 \u00d7 1 \u221a 6 + 1 2 \u00d7 1 \u221a 6 = 1 \u221a 6 . 3 Renchi Yang and Jieming Shi", "2.4 High-Order Perspective Vectors": "In a bipartite graph G , vertices \ud835\udc62 \ud835\udc56 and \ud835\udc62 \u210e in U might have resembling or diverse neighbor sets N( \ud835\udc62 \ud835\udc56 ) and N( \ud835\udc62 \u210e ) , both of which are subsets of V . If N( \ud835\udc62 \ud835\udc56 ) and N( \ud835\udc62 \u210e ) are radically different, \ud835\udc62 \ud835\udc56 and \ud835\udc62 \u210e yield disparate perspectives towards the WPG GV . For instance, in Figure 2, vertex \ud835\udc62 1 is adjacent to \ud835\udc63 1 and \ud835\udc63 3, while vertex \ud835\udc62 3 connects to \ud835\udc63 2, and consequently the HOP vectors of \ud835\udc62 1 and \ud835\udc62 3 are radically different. On the other hand, \ud835\udc62 1 and \ud835\udc62 2 share similar HOP vectors since they have similar perspectives towards WPG GV . Next, we present the formula to compute the HOP vectors for vertices \ud835\udc62 \ud835\udc56 \u2208 U towards the WPG GV with the consideration of high-order topological connections. For every vertex \ud835\udc62 \ud835\udc56 , we first connect itself to all its neighbors \ud835\udc63 \ud835\udc57 \u2208 N( \ud835\udc62 \ud835\udc56 ) in the WPG GV , with weight \ud835\udc5d ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) . Afterwards, we simulate random walks with restart [54] from every \ud835\udc62 \ud835\udc56 to the WPG GV to produce the HOP vector of \ud835\udc62 \ud835\udc56 w.r.t. GV . We denote by P \u2208 R | U|\u00d7|V| the transition matrix comprising the one-hop transition probability for each edge ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) \u2208 E , i.e. , P \ud835\udc56,\ud835\udc57 = \ud835\udc5d ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc57 ) . Further, on the WPG GV , ( W V) \ud835\udf06 \ud835\udc57,\ud835\udc59 , i.e. , ( QQ \u22a4 ) \ud835\udf06 \ud835\udc57,\ud835\udc59 , quantifies the strength of \ud835\udf06 -step connections between vertices \ud835\udc63 \ud835\udc57 and \ud835\udc63 \ud835\udc59 . Thus, the total strength F \ud835\udc56,\ud835\udc57 of connecting \ud835\udc62 \ud835\udc56 and \ud835\udc63 \ud835\udc57 in GV via any vertex \ud835\udc63 \ud835\udc59 \u2208 GV through random walks is calculated by  where \ud835\udefc is a random walk decay factor in ( 0 , 1 ) . Lemma 2.2 indicates that each entry in F is bounded by 1. Further, F converges to an exact solution, which will be theoretically analysed in Section 3 (see Lemma 3.1) 1 .  F is a |U| \u00d7 |V| matrix, wherein each row vector F \ud835\udc56 accommodates the stopping probabilities of random walks starting from \ud835\udc62 \ud835\udc56 to all vertices \ud835\udc63 in GV . Distinct vertices \ud835\udc62 \ud835\udc56 and \ud835\udc62 \ud835\udc57 correspond to different row vectors F \ud835\udc56 and F \ud835\udc57 . Finally, in Eq. (6), we get the HOP vector H \ud835\udc56 of \ud835\udc62 \ud835\udc56 , w.r.t. the WPG GV , by applying \ud835\udc3f 2 normalization over F \ud835\udc56 to ensure that H \ud835\udc56 has a unit \ud835\udc3f 2 norm \u2225 H \ud835\udc56 \u2225 2 = 1.  The HOP vector H \ud835\udc56 summarizes high-order affinities between the given vertex \ud835\udc62 \ud835\udc56 and any vertex \ud835\udc63 \ud835\udc57 \u2208 V from the perspective of \ud835\udc62 \ud835\udc56 over the WPG GV , and hence H \ud835\udc56 can act as a structural representation of \ud835\udc62 \ud835\udc56 .", "2.5 Objective Function": "As aforementioned, two vertices \ud835\udc62 \ud835\udc56 and \ud835\udc62 \u210e with similar connections to the WPG GV are likely to have similar HOP vectors, and naturally, they tend to be in the same cluster, and vice versa . Building on this idea, we formulate our \ud835\udc58 -BGC objective using the HOP vectors of all vertices \ud835\udc62 \ud835\udc56 in U as follows. The objective in Eq. (7) is to identify \ud835\udc58 disjoint clusters { \ud835\udc36 1 , \ud835\udc36 2 , \u00b7 \u00b7 \u00b7 , \ud835\udc36 \ud835\udc58 } such that the overall distance between HOP vectors of vertices in the same cluster and their mean is minimized, similar in spirit to k-Means [24].  1 All proofs appear in Appendix A.  The objective poses two formidable challenges to address. First and foremost, the direct computation and materialization of the dense HOP matrix H \u2208 R | U|\u00d7|V| incur an exorbitant cost for large bipartite graphs with millions of nodes, given that H has a sophisticated definition that involves summing up an infinite series of matrices to capture high-order affinities as defined in Eq. (5) and (6). On top of that, the ultra-high dimensionality of H ( |V| is often up to millions on large graphs) leads to numerous iterations till convergence in the optimization of Eq. (7). To cope with these technical challenges, we first develop a base method HOPE in Section 3, which achieves superior effectiveness while being efficient. We further propose HOPE+ in Section 4 to circumvent certain limitations of HOPE and expedite the practical efficiency while gaining improved clustering quality.", "3 THE HOPE METHOD": "The workflow of HOPE for \ud835\udc58 -BGC is illustrated in Figure 4. More concretely, to mitigate the severe issue of materializing the HOP matrix H and direct clustering of H , HOPE first derives a low-rank approximation X \u2208 R | U|\u00d7 \ud835\udefd of H \u2208 R | U|\u00d7|V| ( \ud835\udefd \u226a |V| ), such that for any two nodes \ud835\udc62 \ud835\udc56 and \ud835\udc62 \ud835\udc57 in U , the difference between Euclidean distances \u2225 X \ud835\udc56 -X \ud835\udc57 \u2225 2 and \u2225 H \ud835\udc56 -H \ud835\udc57 \u2225 2 is bounded. Later, rather than H itself, X is used as a representation of H for clustering via optimizing the objective in Eq. (7). For instance, in Figure 4, our task to cluster five 4-dimensional HOP vectors of nodes \ud835\udc62 1\ud835\udc62 5 turns to group five length-3 vectors into 2 clusters \ud835\udc36 1 = { \ud835\udc62 1 , \ud835\udc62 2 } and \ud835\udc36 2 = { \ud835\udc62 3 , \ud835\udc62 4 , \ud835\udc62 5 } . Figure 4: A Running Example of HOPE \ud835\udc621 \ud835\udc622 \ud835\udc624 \ud835\udc623 \ud835\udc625 \ud835\udc631 \ud835\udc633 \ud835\udc632 \ud835\udc634 0.03   0.98   0.11   0.13 0.15   0.59   0.54   0.59 0.03   0.13   0.11   0.98 0.71   0.08    0.7    0.08 \ud835\udc623 \ud835\udc624 \ud835\udc625 0.71   0.08    0.7    0.08 \ud835\udc621 \ud835\udc622 \ud835\udc623 \ud835\udc624 \ud835\udc625 \ud835\udc621 \ud835\udc622 0.6 -0.52 -0.6 0.94 -0.33   0 0.81  0.58    0 0.6 -0.52  0.6 \ud835\udc07 ( w/o materialization ) \ud835\udcd6 \ud835\udc17 0.81  0.58    0 \ud835\udc072 - \ud835\udc074 2 = \ud835\udfce. \ud835\udfd7\ud835\udfd0\ud835\udfd5 \ud835\udc172 - \ud835\udc174 2 = \ud835\udfce. \ud835\udfd7\ud835\udfcf\ud835\udfd7 \ud835\udc624 \ud835\udc621 \ud835\udc622 0.6 -0.52 -0.6 0.94 -0.33   0 0.81  0.58    0 0.6 -0.52  0.6 0.81  0.58    0 \ud835\udc623 \ud835\udc625 \ud835\udc361 \ud835\udc362 \ud835\udc8c -Means Error Bounded However, computing such a low-rank representation X is highly challenging, especially on how to bound the difference between X and H , without actually materializing H for the sake of efficiency. In the following, we first conduct theoretical analysis to derive X , before elaborating on the algorithmic details and asymptotic performance of HOPE. Analysis to Compute X . At first, we derive the following crucial property in Lemma 3.1 for \u02dd \u221e \ud835\udf06 = 0 ( 1 -\ud835\udefc ) \ud835\udefc \ud835\udf06 ( QQ \u22a4 ) \ud835\udf06 in Eq. (5) by virtue of the symmetry of matrix QQ \u22a4 and the semi-orthogonal property of singular vectors. Lemma 3.1. Let U and \ud835\udeba be the left singular vectors and singular values of Q . Then, U \u2217 ,\ud835\udc56 and 1 -\ud835\udefc 1 -\ud835\udefc \u00b7 \ud835\udeba \ud835\udc8a,\ud835\udc8a 2 are the \ud835\udc56 -largest eigenvector and eigenvalue of \u02dd \u221e \ud835\udf06 = 0 ( 1 -\ud835\udefc ) \ud835\udefc \ud835\udf06 ( QQ \u22a4 ) \ud835\udf06 . Lemma 3.1 indicates that the eigenvectors and eigenvalues of the matrix \u02dd \u221e \ud835\udf06 = 0 ( 1 -\ud835\udefc ) \ud835\udefc \ud835\udf06 ( QQ \u22a4 ) \ud835\udf06 can be readily obtained if the singular vectors U and singular values \ud835\udeba of Q are given, meaning 4 Efficient High-Quality Clustering for Large Bipartite Graphs", "Algorithm 1: HOPE": "Data: Bipartite graph G = (U \u222a V , E) Parameters: The decay factor \ud835\udefc , the number \ud835\udc58 of clusters and dimensionality \ud835\udefd Result: \ud835\udc58 cluster sets: \ud835\udc36 1 , \ud835\udc36 2 , \u00b7 \u00b7 \u00b7 , \ud835\udc36 \ud835\udc58 1 Perform \ud835\udefd -truncated SVD over Q ; 2 Let \ud835\udeba be the top- \ud835\udefd singular values of Q and U be the corresponding left singular vectors; 3 Calculate b X according to Eq. (8); 4 Normalize b X as X such that each row has a unit \ud835\udc3f 2 norm; 5 Invoke \ud835\udc58 -Means to cluster the rows of X ; 6 Let \ud835\udc36 1 , \ud835\udc36 2 , \u00b7 \u00b7 \u00b7 , \ud835\udc36 \ud835\udc58 be the output of the \ud835\udc58 -Means; 7 return \ud835\udc36 1 , \ud835\udc36 2 , \u00b7 \u00b7 \u00b7 , \ud835\udc36 \ud835\udc58 ; that F in Eq. (5), the vital ingredient of H in Eq. (6), can be calculated by PU 1 -\ud835\udefc 1 -\ud835\udefc \ud835\udeba 2 U \u22a4 , indicating the convergence of F . Let  Then, using the fact of U \u22a4 U = I , we can get  as well as  The above equations imply that X with each row X \ud835\udc56 = b X \ud835\udc56 \u2225 b X \ud835\udc56 \u2225 2 can be employed as the low-rank approximation of H , when U and \ud835\udeba are the top\ud835\udefd ( \ud835\udefd \u226a |V| ) singular vectors and values of Q respectively. Theorem 3.2. Given the above matrix X \u2208 R | U|\u00d7 \ud835\udefd , \u2200 \ud835\udc62 \ud835\udc56 , \ud835\udc62 \ud835\udc57 \u2208 U ,    The accuracy guarantee between the low-rank approximation X and the HOP matrix H is established between \u2225 X \ud835\udc56 -X \ud835\udc57 \u2225 2 2 and \u2225 H \ud835\udc56 -H \ud835\udc57 \u2225 2 2 by Theorem 3.2. To demonstrate the empirical difference between \u2225 X \ud835\udc56 -X \ud835\udc57 \u2225 2 2 and \u2225 H \ud835\udc56 -H \ud835\udc57 \u2225 2 2 , in Figure 5, we report the average relative error \ud835\udf16 \ud835\udc5f = 1 | U| 2 \u02dd \ud835\udc62 \ud835\udc56 ,\ud835\udc62 \ud835\udc57 \u2208U | \u2225 X \ud835\udc56 -X \ud835\udc57 \u2225 2 2 -\u2225 H \ud835\udc56 -H \ud835\udc57 \u2225 2 2 | \u2225 H \ud835\udc56 -H \ud835\udc57 \u2225 2 2 and absolute error \ud835\udf16 \ud835\udc4e = 1 | U| 2 \u02dd \ud835\udc62 \ud835\udc56 ,\ud835\udc62 \ud835\udc57 \u2208U GLYPH<12> GLYPH<12> \u2225 X \ud835\udc56 -X \ud835\udc57 \u2225 2 2 - \u2225 H \ud835\udc56 -H \ud835\udc57 \u2225 2 2 GLYPH<12> GLYPH<12> when varying \ud835\udefd . Note that \ud835\udf16 \ud835\udc5f \u2208 [ 0 , 1 ] and \ud835\udf16 \ud835\udc4e \u2208 [ 0 , 2 ] . When increasing \ud835\udefd from 16 to 256, the errors \ud835\udf16 \ud835\udc5f and \ud835\udf16 \ud835\udc4e considerably diminish, and dwindle to small values around or below 0.1 when \ud835\udefd \u2265 64, which showcases that X can accurately approximate H . This observation matches the experimental results in Figure 10 where clustering quality improves and then becomes steady when increasing \ud835\udefd . The HOPE Algorithm. On the basis of the above analysis, we can obtain the low-rank approximation X of H through an efficient Figure 5: Approximation errors of X when varying \ud835\udefd . Relative Error Absolute Error 16 32 64 128 256 0 0 . 5 1 1 . 5 2 (a) Cora 16 32 64 128 256 0 0 . 5 1 1 . 5 2 (b) PubMed 16 32 64 128 256 0 0 . 5 1 1 . 5 2 (c) Flickr truncated singular value decomposition (SVD) over the sparse matrix Q using a number of fast matrix operations, without materializing H explicitly, thereby leading to a significant reduction in computation cost. Algorithm 1 displays the pseudo-code of HOPE, which begins with the input of a bipartite graph G , decay factor \ud835\udefc , the number \ud835\udc58 of clusters, and dimensionality \ud835\udefd that is usually a multiple of \ud835\udc58 . After that, HOPE performs a \ud835\udefd -truncated SVD over matrix Q to get its top\ud835\udefd left singular vectors U and a \ud835\udefd \u00d7 \ud835\udefd diagonal matrix \ud835\udeba containing the top\ud835\udefd singular values (Lines 1-2). At Line 3, we calculate the matrix X according to Eq. (8), and then normalize X as b b X such that each \ud835\udc56 -th row has a unit \ud835\udc3f 2 norm, i.e. , X \ud835\udc56 = b X \ud835\udc56 \u2225 b X \ud835\udc56 \u2225 2 (Line 4). Lastly, Algorithm 1 invokes k-Means algorithm [24] to cluster the rows of the low-rank approximation matrix X into clusters \ud835\udc36 1 , \ud835\udc36 2 \u00b7 \u00b7 \u00b7 , \ud835\udc36 \ud835\udc58 and return them as the final result (Lines 5-7). Complexity. Notice that both P and Q are sparse matrices with |E| non-zero entries. Hence, Line 1 in Algorithm 1 takes \ud835\udc42 (|E| \u00b7 \ud835\udefd ) time [49]. The computation of b X by Eq. (8) requires a sparse matrix multiplication, incurring \ud835\udc42 (|E| \u00b7 \ud835\udefd ) time, and the normalization of b X at Line 4 takes \ud835\udc42 (|U| \u00b7 \ud835\udefd ) time. As stated by [24], k-Means over X runs in \ud835\udc42 (|U| \u00b7 \ud835\udefd \u00b7 \ud835\udc58 \u00b7 \ud835\udc47 ) time, where \ud835\udc47 stands for the number of iterations in k-Means. In total, the time complexity of HOPE is bounded by \ud835\udc42 ((|E| + |U| \u00b7 \ud835\udc58 ) \u00b7 \ud835\udefd ) . The space overhead of HOPE is chiefly determined by the sizes of b X and X , containing \ud835\udc42 (|U| \u00b7 \ud835\udefd ) entries. Together with the matrices P and Q , the overall space cost entailed by HOPE is \ud835\udc42 (|E| + |U| \u00b7 \ud835\udefd ) .", "4 THE HOPE+ METHOD": "As revealed in experiments in Section 5, HOPE achieves superior clustering quality, while being efficient. Nevertheless, HOPE inherits the defects of k-Means, e.g. , the tendency to get stuck at local optima, and the numerous iterations required for convergence, especially on large bipartite graphs. To alleviate such issues, we further propose HOPE+ which is able to advance clustering performance in both efficiency and effectiveness. In Section 4.1, we first explain how HOPE+ transforms and disassembles the \ud835\udc58 -BGC objective in Section 2.5 into two optimization problems solved one after another via efficient algorithmic designs, as elucidated in Section 4.2 and Section 4.3 respectively. Briefly, the \ud835\udc58 -BGC objective in Eq. (7) is converted to its equivalent form of a matrix trace maximization. The first problem is efficiently optimized with a fractional solution L \u2208 R | U|\u00d7 \ud835\udc58 derived by eigendecomposition, when certain constraints are relaxed (Section 4.2). The second optimization problem is formulated to minimize the difference (quantified by the popular Frobenius norm and spectral norm) between a vertex-cluster membership indicator matrix (VCMI) C and L . Therefore, we devise two rounding algorithms , 5 Renchi Yang and Jieming Shi FNEM and SNEM, to get C when minimizing errors in the aforementioned norms (Section 4.3). Section 4.4 includes the analysis of the overall time and space complexities of HOPE+ with FNEM and SNEM.", "4.1 Two-Stage Optimizations": "Recall that h ( \ud835\udc57 ) = \u02dd \ud835\udc62 \ud835\udc56 \u2208 \ud835\udc36 \ud835\udc57 H \ud835\udc56 | \ud835\udc36 \ud835\udc57 | in Eq. (7) and \u2225 H \ud835\udc56 \u2225 2 = 1, \u2200 \ud835\udc62 \ud835\udc56 \u2208 U in Eq. (6), based on which, we establish the equivalence between the objective in Eq. (7) and the trace optimization in Eq. (9).  where C \u2208 R | U|\u00d7 \ud835\udc58 in Eq. (9) is the vertex-cluster membership indicator matrix (VCMI) with each ( \ud835\udc56, \ud835\udc57 ) -th entry to be  \uf8f3 where | \ud835\udc36 \ud835\udc57 | is the size of cluster \ud835\udc36 \ud835\udc57 . In Eq. (10), observe that C is required to fulfill two requirements: (i) each row in C contains only one non-zero and positive entry; and (ii) each column has a unit \ud835\udc3f 2 norm in which all entries are equal. Together these two constraints ensure that C has orthogonal columns, i.e. , C \u22a4 C = I . Using Ky Fan's trace maximization principle in Lemma 4.1, the optimal solution to Eq. (9) is the \ud835\udc58 -largest eigenvectors of HH \u22a4 when the two foregoing constraints on C are relaxed to satisfying C \u22a4 C = I . Lemma4.1(KyFan'stracemaximizationprinciple [15]). Given a symmetric real matrix M \u2208 R \ud835\udc5b \u00d7 \ud835\udc5b with distinct eigenvalues \ud835\udf13 1 ( M ) , \ud835\udf13 2 ( M ) , \u00b7 \u00b7 \u00b7 , \ud835\udf13 \ud835\udc5b ( M ) , sorted by algebraic value in descending order, eigenvectors L and integer \ud835\udc58 \u2264 \ud835\udc5b , we have  According to Lemma 4.1, we can utilize the \ud835\udc58 -largest eigenvectors L of HH \u22a4 as a solution in R | U|\u00d7 \ud835\udc58 to optimize the trace maximization problem in Eq. (9). Afterwards, a VCMI C can be obtained by minimizing the differences between C and L via the optimization problem formulated in Eq. (11).  Summing up, we transform the \ud835\udc58 -BGC objective in Eq. (7) into two optimization problems in Eq. (9) and (11), to be solved in order. The HOPE+ Algorithm. The pseudo-code of HOPE+ is outlined in Algorithm 2, which proceeds in two stages. The first stage is to optimize Eq. (9) via approximate \ud835\udc58 -largest eigenvectors L by Lemma Figure 6: A Running Example of HOPE+ \ud835\udc17 \ud835\udc621 \ud835\udc622 \ud835\udc623 \ud835\udc624 \ud835\udc625 0.81   0.58    0 0.81   0.58    0 0.6 -0.52 -0.6 0.94 -0.33 0 0.6 -0.52 0.6 \ud835\udc0b \ud835\udc621 \ud835\udc622 \ud835\udc623 \ud835\udc624 \ud835\udc625 0.48 0.5 0.48 0.5 0.35 -0.45 0.55  -0.29 0.35 -0.45 \u2219 \u2248 \u2219 Top- \ud835\udc8c Singular Vectors \ud835\udc02 \ud835\udc621 \ud835\udc622 \ud835\udc623 \ud835\udc624 \ud835\udc625 0 1/ 2 1/ 3 0 0 1/ 2 1/ 3 0 1/ 3 0 FNEM/SNEM Stage 1: Approximate \ud835\udc8c -Largest Eigenvectors \ud835\udc0b Stage 2: Rounding \ud835\udc0b to get \ud835\udc02 4.1 (Lines 1-5). Note that the construction of matrix HH \u22a4 entails a quadratic space overhead of \ud835\udc42 (|U| 2 ) and \ud835\udc42 (|U| 2 \u00b7 |V| + |E| \u00b7 |V|) computation time, which is intolerable for massive bipartite graphs. To mitigate this issue, in Section 4.2, we efficiently approximate \ud835\udc58 -largest Eigenvectors L without explicitly materializing HH \u22a4 , and we will explain Lines 1-5 shortly. With L at hand, HOPE+ then enters into the second stage, which attends to generating the final clustering result, namely VCMI C , based on the optimization problem in Eq. (11). Prior to that, C is initialized via a simple greedy seeding strategy (Lines 6-10). To be specific, for every vertex \ud835\udc62 \ud835\udc56 \u2208 U , we first get the column index \ud835\udc57 \u2217 corresponding to the maximum entry L \ud835\udc56,\ud835\udc57 \u2217 in L \ud835\udc56 (Line 8), and assign \ud835\udc62 \ud835\udc56 into cluster \ud835\udc36 \ud835\udc57 (Line 9). This greedy seeding strategy provides us a high-quality initialization of C to facilitate the convergence of C , when dealing with the optimization problem in Eq. (11). However, it is highly challenging to solve Eq. (11) as it may involve prohibitively expensive time of up to \ud835\udc42 (|U| 2 \ud835\udc58 ) . In lieu of directly working on Eq. (11), in Section 4.3, we conduct further analysis to transform Eq. (11) to its equivalent but simplified form, and present two rounding algorithms for the refinement and obtainment of C (Line 11), namely FNEM and SNEM under the settings of the popular Frobenius norm error and spectral norm error, respectively. At Line 12, C is returned as the final clustering result. Example 4.2. Figure 6 presents a running example of HOPE+ over the bipartite graph G with \ud835\udc58 = 2 in Figure 4 for the clustering of five nodes \ud835\udc62 1\ud835\udc62 5. Without materializing H and computing HH \u22a4 , HOPE+ first transforms the problem of calculating the 2-largest eigenvectors of HH \u22a4 as computing the top-2 singular vectors L of X , the 3-dimension approximation of H obtained as in Algorithm 1. After that, HOPE+ conducts a rounding procedure in Algorithm 3 over L \u2208 R 5 \u00d7 2 to get a VCMI matrix C , in which each row contains only one non-zero entry indicating the cluster membership of the node corresponded by the row. For example, in Figure 6, rows 1 and 2 in C have non-zero elements 1 \u221a 2 at the second column, while the entries at the first columns of rows 3-4 are nonzero, i.e., 1 \u221a 3 , resulting in two clusters { \ud835\udc62 1 , \ud835\udc62 2 } and { \ud835\udc62 3 , \ud835\udc62 4 , \ud835\udc62 5 } . In HOPE+, rounding the top-2 singular vectors L to get the VCMI C for producing clusters averts the high computationla costs entailed by using the \ud835\udc58 -Means in HOPE.", "4.2 Approximating \ud835\udc58 -Largest Eigenvectors L": "As alluded to earlier, in the first stage of HOPE+, the goal is to efficiently approximate the top\ud835\udc58 eigenvectors L to solve Eq. (9) based on Lemma 4.1, but without materializing HH \u22a4 . Recall that in Lemma 3.1, we have XX \u22a4 = HH \u22a4 when \ud835\udefd = |V| , whereby we can obtain a low-rank approximation X \u2208 R | U|\u00d7 \ud835\udefd ( \ud835\udc58 < \ud835\udefd \u226a |V| ) of H efficiently such that XX \u22a4 \u2248 HH \u22a4 . Further, 6 Efficient High-Quality Clustering for Large Bipartite Graphs Algorithm 2: HOPE+ Data: Bipartite graph G = (U \u222a V , E) Parameters: The decay factor \ud835\udefc , the number \ud835\udc58 of clusters, dimensionality \ud835\udefd , and the number \ud835\udc47 of iterations Result: The final VCMI C /* Stage 1: Approximate \ud835\udc58 -largest eigenvectors L */ Lines 1-4 are the same as Lines 1-4 in Algorithm 1; 5 Perform the \ud835\udc58 -truncated SVD over X to get the top\ud835\udc58 left singular vectors L to solve Eq. (9); /* Stage 2: Rounding L to get C */ 6 Initialize an empty VCMI C \u2190 0 | U|\u00d7 \ud835\udc58 ; 7 for \ud835\udc62 \ud835\udc56 \u2208 U do 8 \ud835\udc57 \u2217 = arg max 1 \u2264 \ud835\udc57 \u2264 \ud835\udc58 L \ud835\udc56,\ud835\udc57 ; 9 C \ud835\udc56,\ud835\udc57 \u2217 \u2190 1; 10 Normalize C such that each column has a unit \ud835\udc3f 2 norm; 11 Invoke Algorithm 3 for FNEM/SNEM rounding between L and C for at most \ud835\udc47 iterations; 12 return C ; by leveraging Lemma 4.3, calculating the \ud835\udc58 -largest eigenvectors of HH \u22a4 is reduced to obtaining the top\ud835\udc58 left singular vectors of the low-rank approximation X . Lemma 4.3 ([49]). Given an SVD of matrix M , the top\ud835\udc58 left singular vectors of M are the \ud835\udc58 largest eigenvectors of MM \u22a4 . This idea is realized at Lines 1-5 in Algorithm 2 with a detailed procedure of approximating the \ud835\udc58 -largest eigenvectors of HH \u22a4 . More precisely, Algorithm 2 initially generates the |U| \u00d7 \ud835\udefd -sized low-rank X of the HOP matrix H , identical to Lines 1-4 in Algorithm 1. Subsequently, at Line 5 in Algorithm 2, a \ud835\udc58 -truncated SVD is conducted over X to produce the top\ud835\udc58 left singular vectors of X , which are returned as the approximate \ud835\udc58 -largest eigenvectors L of HH \u22a4 , according to Lemma 4.2 and the fact XX \u22a4 \u2248 HH \u22a4 . Notice that Lines 1-4 in Algorithm 2 run in \ud835\udc42 ((|U| + |E|) \u00b7 \ud835\udefd ) time, and the \ud835\udc58 -truncated SVD at Line 5 in Algorithm 2 is performed over a |U| \u00d7 \ud835\udefd matrix, leading to \ud835\udc42 (|U| \u00b7 \ud835\udefd 2 ) time. X and other intermediate matrices in Algorithm 2 consume \ud835\udc42 (|U| \u00b7 \ud835\udefd ) space. In sum, Lines 1-5 in Algorithm 2 avoid materializing HH \u22a4 and enable a fast computation of L with \ud835\udc42 (|U| \u00b7 \ud835\udefd 2 + |E| \u00b7 \ud835\udefd ) time and \ud835\udc42 (|E| + |U| \u00b7 \ud835\udefd ) space, both of which are linear to graph size.", "4.3 Rounding Algorithms": "As explained, after obtaining the approximate L above, the second stage of HOPE+ is to derive C by solving Eq. (11). For efficiency purpose, instead of directly working on Eq. (11), we convert it to its equivalent form that is tractable to solve via the following analysis. In particular, we first capitalize on the cyclic property of matrix trace to get Tr ( C \u22a4 HH \u22a4 C ) = Tr ( HH \u22a4 CC \u22a4 ) and Tr ( L \u22a4 HH \u22a4 L ) = Tr ( HH \u22a4 LL \u22a4 ) , so as to transform Eq. (11) into  Algorithm 3: FNEM/SNEM Rounding Data: The initial VCMI C and \ud835\udc58 -largest eigenvectors L Parameters: The number \ud835\udc47 of iterations and URT Result: The final VCMI C 1 \ud835\udc61 \u2190 1; 2 does not converges and while C /* \ud835\udc61 Update T when fixing switch URT do case FNEM do Perform a full SVD over L right singular vectors \ud835\udebd T ; \u2190 \u22a4 \ud835\udebd\ud835\udebf case SNEM T L \u2190 do \u22a4 C Update /* C C when fixing \u2190 for 0 ; \ud835\udc62 \ud835\udc56 \ud835\udc57 do \u2208 U = arg max 1 \u2217 \ud835\udc56,\ud835\udc57 \u2264 \u2264 LT \ud835\udc57 ) ( \ud835\udc58 \ud835\udc56,\ud835\udc57 \u2217 \u2190 1; C Normalize C \ud835\udc61 3 4 5 6 7 8 9 10 11 12 13 \u2190 \ud835\udc61 + 1; 14 return C ; If there exists a matrix T \u2208 R \ud835\udc58 \u00d7 \ud835\udc58 that minimizes certain matrix norm error ( e.g. , Frobenius norm or spectral norm) between LT and C as in Eq. (13), then Eq. (12) is optimized since CC \u22a4 \u2248 LT \u00b7 ( LT ) \u22a4 = LTT \u22a4 L \u22a4 = LL \u22a4 .  As such, the optimization problem in Eq. (11) turns into Eq. (13), which can be efficiently solved as shown shortly. The Frobenius norm \u2225 \u00b7 \u2225 \ud835\udc39 and spectral norm \u2225 \u00b7 \u2225 2 are two popular choices for the matrix norm \u2225 \u00b7 \u2225\u2217 in Eq. (13). In what follows, we develop two fast rounding algorithms, namely FNEM 2 Rounding and SNEM 3 Rounding , to efficiently solve Eq. (13) to get C , when either Frobenius norm or spectral norm is applied. Algorithm 3 illustrates the pseudo-code of FNEM or SNEM rounding, whose input parameters include an initial VCMI C , the \ud835\udc58 -largest eigenvectors L , the total number of iterations \ud835\udc47 , and a parameter URT (short for Updating Rule for T ) to specify which rounding scheme is adopted, i.e. , FNEM or SNEM. FNEM Rounding. We first delineate Algorithm 3 under the FNEM rounding scheme. From Lines 1 to 13, FNEM rounding works in an iterative process to refine T and C in an alternative fashion until C converges (i.e., C remains unchanged) or \ud835\udc47 iterations are completed. In each iteration, we fix one of T and C , and update the other. Now we explain the updating rules in detail. Note that the objective function in Eq. (13) can be regarded as an orthogonal Procrustes problem [22] when C is fixed. To be specific, given two matrices L and C , the orthogonal Procrustes problem asks to find an orthogonal matrix T ( i.e. , TT \u22a4 = I ) which most closely maps L to C such that \u2225 LT -C \u2225 \ud835\udc39 is minimized. By leveraging our result in Lemma 2 Frobenius Norm Error Minimization 3 Spectral Norm Error Minimization such that each column has a unit ; \ud835\udc47 do \u22a4 C and \u2264 C T ; \ud835\udc3f */ to get the left and \ud835\udebf ; */ 2 norm; 7 Renchi Yang and Jieming Shi 4.4, the SVD result of L \u22a4 C can be utilized to infer the optimal T , i.e. , T = \ud835\udebd\ud835\udebf \u22a4 as Lines 5-6 in Algorithm 3. Since L \u22a4 C is a \ud835\udc58 \u00d7 \ud835\udc58 matrix and \ud835\udc58 is usually small, the SVD can be done efficiently. Lemma 4.4. Let \ud835\udebd and \ud835\udebf be the left and right singular vectors of L \u22a4 C , respectively. Then T \u2217 = arg min T \u2225 LT -C \u2225 2 \ud835\udc39 = \ud835\udebd\ud835\udebf \u22a4 . After obtaining T when C is fixed as described above, we then need to fix T and update C . The problem in Eq. (13) turns into  Recall that C is a VCMI matrix defined in Eq. (10), wherein every \ud835\udc56 -th row has only one non-zero entry. Simply, to optimize Eq. (14), we can determine the cluster id \ud835\udc36 \ud835\udc57 \u2217 for each vertex \ud835\udc62 \ud835\udc56 \u2208 U (Lines 8-11 in Algorithm 3), by locating the column \ud835\udc57 \u2217 with the maximum entry ( LT ) \ud835\udc56,\ud835\udc57 \u2217 in the \ud835\udc56 -th row of LT (Line 10) and then setting C \ud835\udc56,\ud835\udc57 \u2217 to 1 (Line 8). After processing all vertices in U , each column of C is \ud835\udc3f 2-normalized at Line 12 so as to ensure Eq. (10). At last, FNEM rounding increases \ud835\udc61 by 1 at Line 13 and executes the next iteration. SNEM Rounding. When spectral norm is considered in Eq. (13) (i.e., URT is set to SNEM) rounding, the optimization problem becomes min T , C \u2225 LT -C \u2225 2 s.t. TT \u22a4 = I . We also adopt the same iterative process for SNEM as in Algorithm 3, where we update T and C alternatively in an iteration. When C is fixed, SNEM rounding is to find matrix T that solves  The optimal solution to Eq. (15) is simply T \u2217 = L \u22a4 C as per our carefully-analyzed result in Lemma 4.5.  In Algorithm 3, in every iteration, when C is fixed, the updating rule of T is to set it as L \u22a4 C for SNEM (Line 7), and meanwhile, the rule for updating C with a given T in SNEM rounding is consistent with that in FNEM rounding. In comparison with FNEM rounding, SNEM rounding solely requires a simple matrix multiplication L \u22a4 C with \ud835\udc42 (|U|\u00b7 \ud835\udc58 ) time for updating T (Line 7 in Algorithm 3), whereas FNEM rounding needs to conduct a full SVD over L \u22a4 C (Line 5) that costs \ud835\udc42 (|U| \u00b7 \ud835\udc58 2 \u00b7 \ud835\udc47 \ud835\udc46 ) time, where \ud835\udc47 \ud835\udc46 is number of iterations needed in SVD and its typical setting could be as large as a few dozens in practice.", "4.4 Complexity Analysis": "Here we analyze the overall complexities of HOPE+. We dub HOPE+ with FNEM and SNEM rounding as HOPE+ (FNEM) and HOPE+ (SNEM), respectively. For FNEM rounding, it takes \ud835\udc42 (|U| \u00b7 \ud835\udc58 2 ) time for the SVD and matrix multiplication at Lines 5-6 of each iteration (Algorithm 3). For SNEM rounding, in each iteration, the matrix T is updated at Line 7 in Algorithm 3, which can be done in \ud835\udc42 (|U| \u00b7 \ud835\udc58 ) time since C is a sparse matrix with |U| non-zero entries. Both HOPE+ (FNEM) and HOPE+ (SNEM) share the same updating rule of C at Lines 8-12 per iteration, with \ud835\udc42 (|U| \u00b7 \ud835\udc58 ) time to inspect the maximum element per row of a |U| \u00d7 \ud835\udc58 matrix. Further, recall that obtaining the top\ud835\udc58 eigenvectors of HH \u22a4 in Section 4.2 takes \ud835\udc42 (|U|\u00b7 \ud835\udefd 2 +|E|\u00b7 \ud835\udefd ) time and \ud835\udc42 (|E|+|U|\u00b7 \ud835\udefd ) space. Therefore, HOPE+ (FNEM) runs in \ud835\udc42 (|E| \u00b7 \ud835\udefd + |U| \u00b7 \ud835\udefd 2 + |U| \u00b7 \ud835\udc58 2 \ud835\udc47 ) time and consumes \ud835\udc42 (|E| + |U| \u00b7 \ud835\udefd ) space; the time complexity and space complexity Table 2: Statistics of bipartite graphs. (K = 10 3 , M = 10 6 , B = 10 9 )", "Table 3: Evaluated methods.": "of HOPE+ (SNEM) are bounded by \ud835\udc42 (|E| \u00b7 \ud835\udefd + |U| \u00b7 \ud835\udefd 2 + |U| \u00b7 \ud835\udc58\ud835\udc47 ) and \ud835\udc42 (|E| + |U| \u00b7 \ud835\udefd ) , respectively.", "5 EXPERIMENTS": "We experimentally evaluate HOPE and HOPE+ with FNEM and SNEM against 13 competitors on 10 real-world bipartite graph datasets, in terms of clustering quality and efficiency. The experiments run atop a Linux machine with 2 Intel(R) Xeon(R) Gold 6330 2.00GHz CPUs with 28 cores and 2 TB RAM. The reported results are averaged over 5 runs. For reproducibility, we publish all the codes and datasets at https://github.com/HKBU-LAGAS/HOPE.", "5.1 Experimental Setup": "Datasets. Table 2 lists the statistics of the 10 datasets in experiments. There are 5 small or medium-sized graphs and 5 large graphs with millions of edges, up to 1.1 billion edges in MAG . Both CORA and CiteSeer datasets [19] contain scientific publications U with edges to the corresponding keywords V in the publication, and the publications are in 7 and 6 classes (fields of study), respectively. CORA-F [5] is the full version of the CORA network. In Flickr [26], vertices in U (resp. V ) represent users (resp. tags) and edges specify the interest of users in tags, and users are in groups as clusters. In BlogCatalog [53], U is a set of bloggers, and V are the keywords generated from the bloggers' blogs. The labels of vertices in U signify the topic categories provided by the bloggers. The PubMed [47] dataset consists of scientific publications from the PubMed database pertaining to diabetes, classified into three categories, and each edge weight is the TF/IDF weight of the word in the publication. The MIND [58] dataset contains news articles U and users V , and each edge is a click of a user on a news article, and the clustering labels are the categories of the news [63]. LastFM 8 Efficient High-Quality Clustering for Large Bipartite Graphs Table 4: Clustering quality on small or medium-size datasets. Table 5: Clustering quality on large datasets. (Asia) [45] and LastFM [9] are from the LastFM music website. U (resp. V ) in LastFM (Asia) includes users from Asian countries (resp. artists liked by the users), whereas LastFM contains the play count of each music by each user. The clustering labels in both datasets are the locations of users. The MAG dataset is extracted from the Microsoft Academic Graph [48] by [6], with vertices in U and V representing papers and words in the abstracts, respectively, and each edge weight reflects the word occurrence of a word in a paper [63]. The labels correspond to 8 fine-grained fields of study. Baselines and Parameter Settings. Table 3 summarizes the time complexities of our solutions and 13 competitors (the numbers of iterations in them are regarded as constants) evaluated in our experiments when adopted for \ud835\udc58 -BGC. Specifically, we compare HOPE, HOPE+ (FNEM), and HOPE+ (SNEM) against 5 unipartite graph clustering algorithms LE [39], Girvan-Newman [20], SC [55], NRP [64], and PPR [56], 4 data clustering methods including K-Means [24], K-Medoids [29], Birch [69], and NMF [61], as well as 4 BGC approaches, i.e. , SBC [31], SCC [12], biSBM-KL [32] and biSBM-MCMC [67]. Note that in NRP and PPR, the clusters are obtained by applying K-Means over the node embedding vectors and PPR vectors they generate, respectively. The parameters of all competitors are set as suggested in their respective papers. Unless otherwise specified, we set \ud835\udefc = 0 . 3 and \ud835\udefd = 5 \ud835\udc58 ( \ud835\udc58 is the number of clusters in |U| ) for HOPE and HOPE+. The number \ud835\udc47 of iterations in HOPE+ (FNEM) and HOPE+ (SNEM) is set to 100. Evaluation Metrics. We adopt 4 classic metrics to measure the clustering quality [60], including Clustering Accuracy (Acc), F1 score (F1), Normalized Mutual Information (NMI) [50], and Adjusted Rand Index (ARI) [27]. All metrics are calculated based on the groundtruth clustering labels and predicted clustering labels. Particularly, Acc, F1, and NMI range from 0 to 1 . 0, while ARI ranges from -0 . 5 to 1 . 0. For all of them, the higher values indicate better clustering quality. In terms of clustering efficiency and scalability, we report the running time in seconds (measured in wall-clock time) of each algorithm on each dataset, excluding the time for loading datasets and outputting clusters. A method is excluded if it cannot finish within 2 days.", "5.2 Clustering Quality": "Table 4 and Table 5 report the Acc, F1, NMI, ARI scores, as well as the average performance rankings of all methods on 5 small bipartite graph datasets ( i.e. , CORA , CiteSeer , BlogCatalog , Flickr , and PubMed ) and 5 large datasets with more than a million edges, including CORA-F , LastFM (Asia) , MIND , LastFM , and MAG . We report the best performance of HOPE, HOPE+ (FNEM), and HOPE+ (SNEM) on every bipartite graph data when varying \ud835\udefd from 2 \ud835\udc58 to 9 Renchi Yang and Jieming Shi 10 10 Figure 7: Running time in seconds ( \u2605 marks the competitors with the best clustering quality in Tables 4 and 5). HOPE+ (SNEM) HOPE+ (FNEM) HOPE biSBM-MCMC biSBM-KL SCC SBC Girvan-Newman SC LE K-Means K-Medoids Birch NMF NRP PPR - 2 - 1 10 0 10 1 10 2 10 3 10 4 \u2605 (a) CORA 10 - 1 10 0 10 1 10 2 10 3 10 4 \u2605 (b) CiteSeer 10 - 1 10 0 10 1 10 2 10 3 10 4 \u2605 (c) BlogCatalog 10 - 1 10 0 10 1 10 2 10 3 10 4 \u2605 (d) Flickr 10 - 1 10 0 10 1 10 2 10 3 10 4 \u2605 (e) PubMed 10 0 10 1 10 2 10 3 10 4 10 5 \u2605 \u2605 (f) CORA-F 10 0 10 1 10 2 10 3 10 4 \u2605 (g) LastFM (Asia) 10 1 10 2 10 3 \u2605 (h) MIND 10 2 10 3 10 4 \u2605 (i) LastFM 10 3 10 4 10 5 \u2605 (j) MAG Figure 8: Scalability tests. HOPE HOPE+ (FNEM) HOPE+ (SNEM) 2e+5 4e+5 6e+5 8e+5 1e+6 10 1 10 2 10 3 running time (seconds) (a) Varying #nodes 2e+6 4e+6 6e+6 8e+6 1e+7 10 1 10 2 10 3 running time (seconds) (b) Varying #edges 2 10 50 250 1000 10 0 10 2 10 4 running time (seconds) (c) Varying \ud835\udc58 8 \ud835\udc58 and \ud835\udefc from 0 . 1 to 0 . 9. The best, 2nd-best, and 3rd-best results among all methods are highlighted in blue, and darker shades indicate better scores. The best performance of all existing methods is underlined. As shown in the last column of Tables 4 and 5, our methods, HOPE, HOPE+ (FNEM), and HOPE+ (SNEM), achieve the top-3 best average rank (smaller rank is better) on all datasets. Specifically, our proposed solutions considerably outperform all the competitors under most metrics on all 10 datasets. For instance, compared to existing methods, in Table 4, HOPE+ (SNEM) takes a lead by 12 . 7%, 5 . 5%, 13 . 4%, 3 . 5%, and 1 . 4% in terms of clustering accuracy (Acc) on the 5 small bipartite graphs, respectively. On the 5 large datasets in Table 5, HOPE+ (SNEM) outperforms existing approaches by a large margin of 9 . 5%, 5 . 2%, 9 . 7%, 11 . 7%, and 22 . 1% in terms of Acc, respectively. As for the other 3 metrics ( i.e. , F1, NMI, and ARI), we can make qualitatively analogous observations, except on PubMed , where K-Means and SC obtain the highest NMI and ARI scores. The overall results in Table 4 and Table 5 validate the effectiveness of the proposed clustering objective via HOP vectors, which is then solved by the techniques developed in Sections 3 and 4. In addition, in Tables 4 and 5, observe that HOPE+ (SNEM) has the best performance rank on all datasets, whereas HOPE and HOPE+ (FNEM) attain the second-best average performance rank on the small and large datasets, respectively. First, this indicates that HOPE inherits the local optima trap issue caused by the kMeans, and it is accentuated on large bipartite graphs, which is sidestepped by HOPE+ that does not rely on k-Means via a new optimization framework presented in Section 4. Second, HOPE+ (SNEM) outperforms HOPE+ (FNEM) under most cases, which manifests that spectral norm is probably a better choice in Eq. (13) for our methods to handle \ud835\udc58 -BGC.", "5.3 Efficiency and Scalability": "Figure 7 depicts the respective running time of all methods required for clustering on the 10 bipartite graphs. The \ud835\udc66 -axis represents the running time (seconds) in the log-scale. Observe that HOPE+ (SNEM) achieves the highest efficiency on all datasets, outperforming existing methods often by up to orders of magnitude. HOPE+ (FNEM) is also faster than all competitors, except on the smallest CORA . Particularly, on small bipartite graphs in Figure 7(a)-7(e), compared with the competitor with the best clustering quality in Table 4, i.e. , biSBM-MCMC, PPR, SCC, or K-Means, HOPE+ achieves over 270 \u00d7 speedup on CORA , CiteSeer , BlogCatalog , and Flickr , as well as more than 6 . 6 \u00d7 speedup on PubMed . As an example, on BlogCatalog , the best competitor biSBM-MCMC takes 271 . 8 seconds to complete, while both HOPE+ (SNEM) and HOPE+ (FNEM) need only around 0 . 32 seconds, attaining a significant speedup of 850 \u00d7 , respectively, while, as mentioned, the clustering quality of HOPE+ (SNEM) and HOPE+ (FNEM) is better than biSBM-MCMC. Compared with the fastest competitor NMF with inferior quality, HOPE+ (SNEM) is still consistently faster. In Figure 7(f)-7(j) on large datasets, the efficiency improvement of our methods maintains or enlarges over existing methods, particularly on the three largest datasets MIND , LastFM , and MAG , where only our methods HOPE, HOPE+ with SNEM and FNEM, and competitors NRP, NMF survive to return within 2 days. Specifically, our solution HOPE+ (SNEM) is able to gain 9 . 2 \u00d7 , 54 . 7 \u00d7 , and 44 . 4 \u00d7 runtime speedup over the best viable competitor NMF or NRP as shown in Figure 7(h), 7(i), and 7(j), respectively. Notice that in spite of the comparable asymptotic complexities of NMF, SBC, and SCC as shown in Table 3, their efficiency significantly falls short compared to HOPE and HOPE+ due to numerous iterations required and/or time-consuming and complex operations involved in them. The superior efficiency of HOPE+ demonstrates the power of the techniques proposed in Section 4 to significantly reduce computational costs, while achieving the state-of-the-art clustering quality as reported in Section 5.2. HOPE+ (SNEM) is consistently faster than HOPE+ (FNEM) since the former has lower time complexity as analyzed in Section 4.3. HOPE+ methods (Section 4) are more efficient than HOPE (Section 3) since HOPE+ avoids the expensive k-Means that needs many iterations to converge, via novel theoretical analysis and algorithm designs. 10 Efficient High-Quality Clustering for Large Bipartite Graphs Figure 10: Accuracy vs. \ud835\udefd . HOPE HOPE+ (FNEM) HOPE+ (SNEM) 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0.52 0.54 0.56 0.58 0.6 Accuracy (a) CORA 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0 . 55 0 . 6 0 . 65 Accuracy (b) CiteSeer 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0 . 6 0 . 65 0 . 7 0 . 75 Accuracy (c) BlogCatalog 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0 . 5 0 . 6 0 . 7 Accuracy (d) Flickr 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0 . 54 0 . 56 0 . 58 0 . 6 0 . 62 Accuracy (e) PubMed 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 0 . 34 0 . 36 0 . 38 Accuracy (f) CORA-F Figure 9: Accuracy vs. \ud835\udefc . HOPE HOPE+ (FNEM) HOPE+ (SNEM) \ud835\udc58 2 \ud835\udc58 3 \ud835\udc58 4 \ud835\udc58 5 \ud835\udc58 6 \ud835\udc58 7 \ud835\udc58 8 \ud835\udc58 0 . 4 0 . 45 0 . 5 0 . 55 0 . 6 Accuracy (a) CORA \ud835\udc58 2 \ud835\udc58 3 \ud835\udc58 4 \ud835\udc58 5 \ud835\udc58 6 \ud835\udc58 7 \ud835\udc58 8 \ud835\udc58 0 . 5 0 . 55 0 . 6 0 . 65 Accuracy (b) CiteSeer \ud835\udc58 2 \ud835\udc58 3 \ud835\udc58 4 \ud835\udc58 5 \ud835\udc58 6 \ud835\udc58 7 \ud835\udc58 8 \ud835\udc58 0 . 5 0 . 6 0 . 7 Accuracy (c) BlogCatalog \ud835\udc58 2 \ud835\udc58 3 \ud835\udc58 4 \ud835\udc58 5 \ud835\udc58 6 \ud835\udc58 7 \ud835\udc58 8 \ud835\udc58 0 . 5 0 . 6 0 . 7 Accuracy (d) Flickr \ud835\udc58 2 \ud835\udc58 3 \ud835\udc58 4 \ud835\udc58 5 \ud835\udc58 6 \ud835\udc58 7 \ud835\udc58 8 \ud835\udc58 0 . 58 0 . 6 0 . 62 Accuracy (e) PubMed \ud835\udc58 2 \ud835\udc58 3 \ud835\udc58 4 \ud835\udc58 5 \ud835\udc58 6 \ud835\udc58 7 \ud835\udc58 8 \ud835\udc58 0 . 3 0 . 35 Accuracy (f) CORA-F Next, we verify the scalability of HOPE and HOPE+ on synthetic graphs of different sizes by the Erd\u0151s-R\u00e9nyi random graph model [4]. Figure 8(a) shows the running time of HOPE, HOPE+ (FNEM), and HOPE+ (SNEM) on the random graphs generated by fixing the total number of vertices |U| + |V| = 5 \u00d7 10 5 with |U| = |V| , and varying the number of edges |E| in { 2 \u00d7 10 6 , 4 \u00d7 10 6 , 6 \u00d7 10 6 , 8 \u00d7 10 6 , 10 7 } when \ud835\udc58 = 50. Figure 8(b) displays the efficiency when varying the number of vertices |U| + |V| in { 2 \u00d7 10 5 , 4 \u00d7 10 5 , 6 \u00d7 10 5 , 8 \u00d7 10 5 , 10 6 } , while fixing the number of edges |E| = 2 \u00d7 10 6 and \ud835\udc58 = 50. In Figure 8(c), we vary \ud835\udc58 in { 2 , 10 , 50 , 250 , 1000 } to evaluate the scalability, while fixing |E| = 2 \u00d7 10 6 and |U| + |V| = 2 \u00d7 10 5 . Observe that the runtime of our methods increases steadily in proportion to the number of vertices and the number \ud835\udc58 of clusters, but grows modestly as the number of edges increases.", "5.4 Parameter Analysis": "We empirically study the effects of the input parameters of HOPE and HOPE+, including the random walk decay factor \ud835\udefc and the dimensionality \ud835\udefd . Varying \ud835\udefc . Figure 9 illustrates the Acc scores of HOPE, HOPE+ (FNEM), and HOPE+ (SNEM) on 6 datasets, including CORA , CiteSeer , BlogCatalog , Flickr , PubMed , and CORA-F , when \ud835\udefc is varied from 0 . 1 to 0 . 9 with step size 0 . 1. The F1, NMI, and ARI results are qualitatively similar, and thus, are omitted here for the interest of space. From Figure 9, we can see that, on CORA , BlogCatalog , and PubMed , the clustering accuracy scores achieved by HOPE and HOPE+ are stable at first, and then decrease remarkably when \ud835\udefc roughly is beyond 0 . 5. Additionally, the clustering performance of all three methods witnesses a significant drop on CORA-F after \ud835\udefc exceeds 0 . 2. Recall that in Eq. (5), a larger \ud835\udefc results in higher weights ( i.e. , ( 1 -\ud835\udefc ) \ud835\udefc \ud835\udf06 ) to distant vertices in H . Therefore, it can be concluded that on CORA , BlogCatalog , PubMed , and CORA-F , the affinities of the given vertex \ud835\udc62 \ud835\udc56 and its proximal vertices play a more important role in the clustering. Interestingly, on CiteSeer , the performance of both HOPE and HOPE+ increases slightly with HOPE HOPE+ (FNEM) HOPE+ (SNEM) \ud835\udc58 2 \ud835\udc58 3 \ud835\udc58 4 \ud835\udc58 5 \ud835\udc58 6 \ud835\udc58 7 \ud835\udc58 8 \ud835\udc58 10 0 10 1 10 2 running time (seconds) (a) CORA-F \ud835\udc58 2 \ud835\udc58 3 \ud835\udc58 4 \ud835\udc58 5 \ud835\udc58 6 \ud835\udc58 7 \ud835\udc58 8 \ud835\udc58 10 1 10 1 . 5 10 2 running time (seconds) (b) MIND \ud835\udc58 2 \ud835\udc58 3 \ud835\udc58 4 \ud835\udc58 5 \ud835\udc58 6 \ud835\udc58 7 \ud835\udc58 8 \ud835\udc58 10 2 10 3 10 4 running time (seconds) (c) LastFM Figure 11: Running time vs. \ud835\udefd . \ud835\udefc , implying the consideration of more far-reaching vertices benefits the clustering. A similar observation can be made on Flickr for HOPE+, while the accuracy scores of HOPE slump by more than 10% when \ud835\udefc > 0 . 2. Further, Figure 9 reveals that HOPE+ yields better stability over HOPE, particularly on CORA and Flickr , when varying \ud835\udefc . Varying \ud835\udefd . Figure 10 reports the clustering accuracy of our methods when varying \ud835\udefd from \ud835\udc58 to 8 \ud835\udc58 ( \ud835\udc58 is the number of clusters per dataset). Observe that, on most datasets, the clustering accuracy scores attained by HOPE, HOPE+ (FNEM), and HOPE+ (SNEM) initially experience a rapid increase when \ud835\udefd is varied from \ud835\udc58 to 3 \ud835\udc58 , followed by remaining stable with slight fluctuations when \ud835\udefd \u2265 3 \ud835\udc58 . To explain, recall that \ud835\udefd is used as the dimensionality of the lowrank matrix X to approximate H . Intuitively, a larger \ud835\udefd gives a more accurate low-rank approximation of H , thereby leading to higher result quality in \ud835\udc58 -BGC. Furthermore, Figure 11 presents the running time in seconds of HOPE, HOPE+ (FNEM), and HOPE+ (SNEM) when \ud835\udefd is varied from \ud835\udc58 to 8 \ud835\udc58 on 3 representative large datasets CORA-F , MIND , and LastFM . The runtime of HOPE and HOPE+ is roughly proportional to \ud835\udefd , coinciding with our asymptotic analysis of HOPE and HOPE+ in Sections 3 and 4.4, respectively.", "6 RELATED WORK": "This section reviews existing studies germane to the \ud835\udc58 -BGC problem in this paper. A common methodology for \ud835\udc58 -BGC is to first project a bipartite graph G into a unipartite graph G \u2217 , i.e. , a graph composed of a single type of vertices U , by connecting two vertices from U if they share common neighborhoods in G . After that, 11 Renchi Yang and Jieming Shi classic graph clustering algorithms can be applied naturally to G \u2217 . A variety of methods [70, 71] have been proposed for weighting the connections in G \u2217 . Melamed [36] proposed a dual-projection method, which extracts clusters of two one-mode graphs based on the two vertex sets in G independently and then combines the solutions such that the within-community ties are maximized. ComSim [52] detects clusters of one single type of vertex using a similarity measure of common neighbors and maximizes vertices' similarity by identifying cycles of connections. In spite of also relying on projected graphs, our methods differ from previous projectionbased methods. To be more precise, our solutions make use of the high-order affinities between target vertex set U and the vertices in the proposed weighted projected graph GV for dividing U into clusters, whereas prior methods partition vertices in GV based on their direct connections in GV . Recent \ud835\udc58 -BGC solutions propose to simultaneously group vertices in each vertex set of G into clusters. Dhillon [12] extended spectral graph partitioning [44] to bipartite graphs. SBC algorithm [31] finds a blockwise-constant checkerboard matrix as a good approximation of a bipartite graph G for clustering. The state-of-theart solutions to \ud835\udc58 -BGC are based on statistical models. biSBM-KL [32] includes a degree-corrected bipartite stochastic block model for inferring clusters and maximizes the likelihood function using the Kernighan-Lin algorithm [30]. In follow-up work, Yen and Larremore [67] further developed biSBM-MCMC, which adopts a Markov Chain Monte-Carlo sampler for fast optimization. Our methods outperform these approaches, as validated by our experiments, due to our novel designs that efficiently and effectively exploit high-order relationships between vertices. Instead of assuming the number \ud835\udc58 of clusters to be known a priori, another line of research is devoted to discovering \ud835\udc58 automatically during clustering and various techniques have been proposed. Lehmann et al. [33] presented biGcli/q.sc_u.sce for detecting biclique clusters in bipartite graphs by extending the \ud835\udc58 -clique community [41] to bipartite graphs. Considerable efforts have been devoted to extending the notion of modularity [40] in unipartite graphs to bipartite graphs as bi-modularity for jointly clustering two types of vertices based on bi-modularity maximization [2, 23]. Guimera et al. [23] use the cumulative deviation from the random expectation of the number of neighbors shared by vertices in the same cluster to define bi-modularity. Another bi-modularity objective is defined in [2, 3] with the consideration of connectivity of both vertex sets in a bipartite graph, and a BRIM algorithm is presented to solve the objective. Subsequent studies [13, 35, 37, 42, 51, 68] propose more bi-modularity definitions as well as related optimization algorithms. However, these modularity-based methods suffer from the resolution limit issue [18] due to failing to accurately detect small-sized clusters with high modularity scores. In addition, classic graph clustering algorithms [17] and standard data clustering algorithms can be applied to \ud835\udc58 -BGC by considering bipartite graphs as general graphs and data matrices, respectively. Since they are not specially catered for bipartite graphs, these methods cannot capture the unique characteristics of bipartite structures, resulting in a mediocre performance, as shown in Section 5.", "7 CONCLUSION": "In this paper, we propose efficient solutions, HOPE and HOPE+ for high-quality \ud835\udc58 -BGC. HOPE achieves high scalability and clustering quality by formulating the \ud835\udc58 -BGC as an optimization problem based on our proposed HOP vectors and an efficient low-rank approximation of the HOP vectors. HOPE+ further improves over HOPE in terms of both empirical efficiency and clustering accuracy through a novel problem transformation and a carefully-crafted two-stage optimization framework, as demonstrated by our extensive experiments. In the future, we intend to extend HOPE and HOPE+ to handle bipartite graphs with vertex attributes.", "ACKNOWLEDGMENTS": "Renchi Yang is supported by the NSFC YSF grant (No. 62302414) and Hong Kong RGC ECS grant (No. 22202623). Jieming Shi is supported by Hong Kong RGC ECS (No. 25201221) and NSFC 62202404.", "A PROOFS": "Proof of Lemma 2.2. First, we define a matrix \ud835\udec0 \u2208 R | V | \u00d7 | V | where \ud835\udec0 \ud835\udc57,\ud835\udc59 = \u02dd \ud835\udc62 \ud835\udc56 \u2208U \ud835\udc5d ( \ud835\udc63 \ud835\udc57 , \ud835\udc62 \ud835\udc56 ) \u00b7 \ud835\udc5d ( \ud835\udc62 \ud835\udc56 , \ud835\udc63 \ud835\udc59 ) . It can be seen that \ud835\udec0 is a non-negative row-stochastic matrix, i.e., \u02dd \ud835\udc63 \ud835\udc59 \u2208V \ud835\udec0 \ud835\udc57,\ud835\udc59 = 1. As per [1] and the definition of \ud835\udec0 , there exists a probability distribution \ud835\udf45 ( \ud835\udc57 ) , such that lim \ud835\udf06 \u2192\u221e \ud835\udec0 \ud835\udf06 \ud835\udc57 = \ud835\udf45 for 1 \u2264 \ud835\udc57 \u2264 |V| . Next, let \ud835\udeab be a |V| \u00d7 |V| diagonal matrix wherein \ud835\udeab \ud835\udc57,\ud835\udc57 equals to \ud835\udc64\ud835\udc60 ( \ud835\udc63 \ud835\udc57 ) = \u02dd \ud835\udc62 \u210e \u2208U \ud835\udc64 ( \ud835\udc63 \ud835\udc57 , \ud835\udc62 \u210e ) . By Eq. (1) and (4), we can derive  which implies that QQ \u22a4 = \ud835\udeab 1 2 \ud835\udec0\ud835\udeab -1 2 . Thus, each term in Eq. (5) satisfies P ( QQ \u22a4 ) \ud835\udf06 = P \ud835\udeab 1 2 \ud835\udec0 \ud835\udf06 \ud835\udeab -1 2 . Since lim \ud835\udf06 \u2192\u221e \ud835\udec0 \ud835\udf06 \ud835\udc57 = \ud835\udf45 ( \ud835\udc57 ) \u2200 1 \u2264 \ud835\udc57 \u2264 |V| , each row of P ( QQ \u22a4 ) \ud835\udf06 will converge to a vector when \ud835\udf06 \u2192 \u221e . In addition, \ud835\udec0 is a non-negative row-stochastic matrix, then \ud835\udec0 \ud835\udf06 is also a non-negative row-stochastic matrix, meaning that each entry in \ud835\udec0 is not greater than 1. Therefore, ( P ( QQ \u22a4 ) \ud835\udf06 ) \ud835\udc56,\ud835\udc57 = ( P \ud835\udeab 1 2 \ud835\udec0 \ud835\udf06 \ud835\udeab -1 2 ) \ud835\udc56,\ud835\udc57 \u2264 P \ud835\udc56,\ud835\udc57 holds for any \ud835\udf06 \u2265 0, \ud835\udc62 \ud835\udc56 \u2208 U and \ud835\udc63 \ud835\udc57 \u2208 V , which further leads to  Since P ( QQ \u22a4 ) \ud835\udf06 is non-negative, F \ud835\udc56,\ud835\udc57 \u2265 0, completing the proof. \u25a1 Proof of Lemma 3.1. By the definition of SVD, Q = U \ud835\udeba V \u22a4 and right singular vectors V have orthogonal columns, i.e., V \u22a4 V = I . Further, we have QQ \u22a4 = U \ud835\udeba 2 U \u22a4 . Notice that the left singular vectors U also have orthogonal columns, i.e. , U \u22a4 U = I . Hence,  Continuing forth, we prove that the largest singular value of Q is not greater than 1, namely \ud835\udeba 1 , 1 \u2264 1. Firstly, as per Lemma 4.3, the largest singular value of Q is equal to the largest eigenvalue of QQ \u22a4 . Thus, if we can prove that the largest eigenvalue of QQ \u22a4 12 Efficient High-Quality Clustering for Large Bipartite Graphs is less than or equal to 1, then \ud835\udeba 1 , 1 \u2264 1 holds. For any \ud835\udc63 \ud835\udc56 \u2208 V , let \ud835\udc67 \ud835\udc56 ( \ud835\udc62 \ud835\udc59 ) = \u221a\ufe01 \ud835\udc5d ( \ud835\udc63 \ud835\udc56 , \ud835\udc62 \ud835\udc59 ) \u00b7 \ud835\udc5d ( \ud835\udc62 \ud835\udc59 , \ud835\udc63 \ud835\udc56 ) . By Eq. (2), we can write ( QQ \u22a4 ) \ud835\udc56,\ud835\udc57 as  Also, on the basis of Eq. (1), it is easy to prove that  Then, for any vector y \u2208 R | V | , the following inequality holds: y \u00b7 ( I -QQ \u22a4 ) \u00b7 y \u22a4 = \u2211\ufe01 \ud835\udc63 \ud835\udc56 \u2208V y 2 \ud835\udc56 -2 \u2211\ufe01 \ud835\udc63 \ud835\udc56 ,\ud835\udc63 \ud835\udc57 \u2208V y \ud835\udc56 \u00b7 ( QQ \u22a4 ) \ud835\udc56,\ud835\udc57 \u00b7 y \ud835\udc57   - 2 y \u2211\ufe01 \u2211\ufe01 \ud835\udc56 \u00b7 y \ud835\udc57 \u00b7 \ud835\udc67 \ud835\udc57 ( \ud835\udc62 \ud835\udc59 ) \u00b7 \ud835\udc67 \ud835\udc56 ( \ud835\udc62 \ud835\udc59 ) \ud835\udc63 \ud835\udc56 ,\ud835\udc63 \ud835\udc57 \u2208V \ud835\udc62 \ud835\udc59 \u2208U  which indicates that QQ \u22a4 is positive semidefinite, and hence, gives us the following Rayleigh quotient  The above inequality implies that the largest eigenvalue of QQ \u22a4 is less than or equal to 1, and accordingly \ud835\udeba 1 , 1 \u2264 1. Furthermore, we can derive that ( \ud835\udefc \ud835\udeba 2 ) \u221e = 0 and plugging it into Eq. (16) yields  The lemma is proved. \u25a1 Proof of Theorem 3.2. Since the \ud835\udc3f 2 norm of any HOP vector H \ud835\udc56 is 1 (E.q (6)), we then derive that  Likewise, \u2225 X \ud835\udc56 -X \ud835\udc57 \u2225 2 2 = 2 ( 1 -X \ud835\udc56 \u00b7 X \ud835\udc57 ) since each row of X has a unit \ud835\udc3f 2 norm (Line 4 in Algorithm 1). In addition, by Eq. (8) and the fact that \u2225 b X \ud835\udc56 \u2225 2 = \u221a\ufe03 b X \ud835\udc56 \u00b7 b X \ud835\udc56 , we can get X \ud835\udc56 \u00b7 X \ud835\udc57 = b X \ud835\udc56 \u00b7 b X \ud835\udc57 \u2225 b X \ud835\udc56 \u2225 2 \u00b7 \u2225 b X \ud835\udc57 \u2225 2 =   and particularly, FF \u22a4 = PU ( 1 -\ud835\udefc 1 -\ud835\udefc \u00b7 \ud835\udeba 2 ) 2 U \u22a4 P \u22a4 , where U and \ud835\udeba are the full left singular vectors and singular values of Q , respectively. By the fact that every element in P is less than 1, we have  Theorem A.1 (Eckart-Young Theorem [21]). Suppose that M \ud835\udc58 \u2208 R \ud835\udc5b \u00d7 \ud835\udc58 is the rank\ud835\udc58 approximation to M \u2208 R \ud835\udc5b \u00d7 \ud835\udc5b obtained by exact SVD, then min \ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc58 ( b M ) \u2264 \ud835\udc58 \u2225 M -b M \u2225 2 = \u2225 M -M \ud835\udc58 \u2225 2 = \ud835\udf0e \ud835\udc58 + 1 , where \ud835\udf0e \ud835\udc56 represents the \ud835\udc56 -th largest singular value of M . As per the definitions, U ( 1 -\ud835\udefc 1 -\ud835\udefc \u00b7 \ud835\udeba 2 ) 2 U \u22a4 is the rank\ud835\udc58 approximation of U ( 1 -\ud835\udefc 1 -\ud835\udefc \u00b7 \ud835\udeba 2 ) 2 U \u22a4 . By Theorem A.1, Inequality (19) becomes  where \ud835\udf0e = ( 1 -\ud835\udefc 1 -\ud835\udefc \u00b7 \ud835\udeba 2 \ud835\udefd + 1 ,\ud835\udefd + 1 ) 2 and \ud835\udeba \ud835\udefd + 1 ,\ud835\udefd + 1 is the ( \ud835\udefd + 1 ) -th largest singular value of Q . Since for any matrix M , \u2225 M \u2225 max \u2264 \u2225 M \u2225 2, we have \u2225 FF \u22a4 -b X b X \u22a4 \u2225 max \u2264 \ud835\udf0e , leading to | b X \ud835\udc56 \u00b7 b X \ud835\udc57 -F \ud835\udc56 \u00b7 F \ud835\udc57 | \u2264 \ud835\udf0e , \u2200 \ud835\udc62 \ud835\udc56 \u2208 U . Recall that H \ud835\udc56 = F \ud835\udc56 \u2225 F \ud835\udc56 \u2225 2 in Eq. (6). Consequently, we have  Note that \u2225 X \ud835\udc56 -X \ud835\udc57 \u2225 2 2 -\u2225 H \ud835\udc56 -H \ud835\udc57 \u2225 2 2 = 2 ( H \ud835\udc56 \u00b7 H \ud835\udc57 -X \ud835\udc56 \u00b7 X \ud835\udc57 ) . Plugging Eq. (20) into the above equation completes the proof. \u25a1 Proof of Lemma 4.4. First, by the definition of matrix Frobenius norm and matrix trace property,  Suppose that \ud835\udebd\ud835\udeba\ud835\udebf \u22a4 is the exact full SVD of L \u22a4 C , where the left and right singular vectors satisfy \ud835\udebd \u22a4 \ud835\udebd = \ud835\udebf \u22a4 \ud835\udebf = I . Further, by the cyclic property of matrix trace and the above equation, min T \u2225 LT -C \u2225 \ud835\udc39 is equivalent to  Observe that the rows of \ud835\udebd \u22a4 T \ud835\udebf are orthogonal, namely \ud835\udebd \u22a4 T \ud835\udebf \u00b7 ( \ud835\udebd \u22a4 T \ud835\udebf ) \u22a4 = I , meaning that -1 \u2264 ( \ud835\udebd \u22a4 T \ud835\udebf ) \ud835\udc56,\ud835\udc57 \u2264 1 \u2200 1 \u2264 \ud835\udc56, \ud835\udc57 \u2264 \ud835\udc58 . Therefore, we have \u02dd \ud835\udc58 \ud835\udc56 = 1 ( \ud835\udebd \u22a4 T \ud835\udebf ) \ud835\udc56,\ud835\udc56 \u00b7 \ud835\udeba \ud835\udc56,\ud835\udc56 \u2264 \u02dd \ud835\udc58 \ud835\udc56 = 1 \ud835\udeba \ud835\udc56,\ud835\udc56 . In particular, the upper bound \u02dd \ud835\udc58 \ud835\udc56 = 1 \ud835\udeba \ud835\udc56,\ud835\udc56 is attained when \ud835\udebd \u22a4 T \ud835\udebf = I , implying that T = \ud835\udebd\ud835\udebf \u22a4 . Thus, the lemma holds. \u25a1 Proof of Lemma 4.5. Suppose that T \u2217 is the optimal solution to the objective function in Eq. (15). In the first place, it must hold that \u2225 LT \u2217 -C \u2225 2 \u2264 \u2225 LL \u22a4 C -C \u2225 2 since T \u2217 is the minimizer. On the other hand, by the Pythagorean theorem [57], for any vector v ,  and hence \u2225 LT \u2217 -C \u2225 2 \u2265 \u2225 LL \u22a4 C -C \u2225 2. As a consequence, \u2225 LT \u2217 -C \u2225 2 = \u2225 LL \u22a4 C -C \u2225 2 and  Moreover, recall that L is the \ud835\udc58 -largest eigenvectors, which satisfies L \u22a4 L = I . Accordingly, as per Eq. (21), T \u2217 = L \u22a4 LT \u2217 = L \u22a4 LL \u22a4 C = L \u22a4 C , signifying that the optimal such T in Eq. (15) is L \u22a4 C . The proof is completed. \u25a1 13 Renchi Yang and Jieming Shi", "REFERENCES": "[1] Jac M Anthonisse and Henk Tijms. 1977. Exponential convergence of products of stochastic matrices. J. Math. Anal. Appl. 59, 2 (1977), 360-364. Michael J Barber. 2007. Modularity and community detection in bipartite net- [2] works. Physical Review E 76, 6 (2007), 066102. [3] Michael J Barber, Margarida Faria, Ludwig Streit, and Oleg Strogan. 2008. Searching for communities in bipartite networks. In AIP Conference Proceedings , Vol. 1021. American Institute of Physics, 171-182. [4] Vladimir Batagelj and Ulrik Brandes. 2005. Efficient generation of large random networks. Physical Review E 71, 3 (2005), 036113. [5] Aleksandar Bojchevski and Stephan G\u00fcnnemann. 2018. Deep Gaussian Embedding of Graphs: Unsupervised Inductive Learning via Ranking. In International Conference on Learning Representations . https://openreview.net/forum? id=r1ZdKJ-0W [6] Aleksandar Bojchevski, Johannes Klicpera, Bryan Perozzi, Amol Kapoor, Martin Blais, Benedek R\u00f3zemberczki, Michal Lukasik, and Stephan G\u00fcnnemann. 2020. Scaling Graph Neural Networks with Approximate PageRank. In SIGKDD . [7] Gabriel Budel and Piet Van Mieghem. 2020. Detecting the number of clusters in a network. Journal of Complex Networks 8, 6 (2020), cnaa047. [8] Paola Gabriela Pes\u00e1ntez Cabrera. 2018. Bipartite Network Community Detection: Algorithms and Applications . Washington State University. [9] O. Celma. 2010. Music Recommendation and Discovery in the Long Tail . Springer. [10] Yizong Cheng and George M Church. 2000. Biclustering of expression data.. In Ismb , Vol. 8. 93-103. [11] Wenyuan Dai, Gui-Rong Xue, Qiang Yang, and Yong Yu. 2007. Co-clustering based classification for out-of-domain documents. In Proceedings of the 13th ACM SIGKDD international conference on Knowledge discovery and data mining . 210-219. [12] Inderjit S Dhillon. 2001. Co-clustering documents and words using bipartite spectral graph partitioning. In Proceedings of the seventh ACM SIGKDD international conference on Knowledge discovery and data mining . 269-274. [13] Carsten F Dormann and Rouven Strauss. 2014. A method for detecting modules in quantitative bipartite networks. Methods in Ecology and Evolution 5, 1 (2014), 90-98. [14] Jennifer A Dunne, Richard J Williams, and Neo D Martinez. 2002. Network structure and biodiversity loss in food webs: robustness increases with connectance. Ecology letters 5, 4 (2002), 558-567. [15] Ky Fan. 1949. On a theorem of Weyl concerning eigenvalues of linear transformations I. Proceedings of the National Academy of Sciences of the United States of America 35, 11 (1949), 652. [16] Yiling Chen Frederico Fonseca. 2003. A bipartite graph co-clustering approach to ontology mapping. In Proceedings of the Workshop on Semantic Web Technologies for Searching and Retrieving Scientific Data. Colocated with the Second International Semantic Web Conference (ISWC-03), CEUR-WS. org . [17] Santo Fortunato. 2010. Community detection in graphs. Physics reports 486, 3-5 (2010), 75-174. [18] Santo Fortunato and Marc Barthelemy. 2007. Resolution limit in community Proceedings of the national academy of sciences detection. 104, 1 (2007), 36-41. [19] Lise Getoor. 2005. Link-based classification. In Advanced methods for knowledge discovery from complex data . Springer, 189-207. [20] Michelle Girvan and Mark EJ Newman. 2002. Community structure in social and biological networks. Proceedings of the national academy of sciences 99, 12 (2002), 7821-7826. [21] Gene H Golub and Charles F Van Loan. 1996. Matrix computations. Johns Hopkins University, Press (1996). [22] John C Gower and Garmt B Dijksterhuis. 2004. Procrustes problems . Vol. 30. OUP Oxford. [23] Roger Guimera, Marta Sales-Pardo, and Lu\u00eds A Nunes Amaral. 2007. Module identification in bipartite and directed networks. Physical Review E 76, 3 (2007), 036102. [24] John A Hartigan and Manchek A Wong. 1979. Algorithm AS 136: A k-means clustering algorithm. Journal of the royal statistical society. series c (applied statistics) 28, 1 (1979), 100-108. [25] Reinhard Heckel, Michail Vlachos, Thomas Parnell, and Celestine D\u00fcnner. 2017. Scalable and interpretable product recommendations via overlapping co-clustering. In 2017 IEEE 33rd International Conference on Data Engineering (ICDE) . IEEE, 1033-1044. [26] Xiao Huang, Jundong Li, and Xia Hu. 2017. Label informed attributed network embedding. In Proceedings of the tenth ACM international conference on web search and data mining . 731-739. [27] Lawrence Hubert and Phipps Arabie. 1985. Comparing partitions. Journal of classification 2 (1985), 193-218. [28] Pedro Jordano, Jordi Bascompte, and Jens M Olesen. 2003. Invariant properties in coevolutionary networks of plant-animal interactions. Ecology letters 6, 1 (2003), 69-81. [29] Leonard Kaufman and Peter J Rousseeuw. 2009. Finding groups in data: an introduction to cluster analysis . Vol. 344. John Wiley & Sons. [30] Brian W Kernighan and Shen Lin. 1970. An efficient heuristic procedure for partitioning graphs. The Bell system technical journal 49, 2 (1970), 291-307. [31] Yuval Kluger, Ronen Basri, Joseph T Chang, and Mark Gerstein. 2003. Spectral biclustering of microarray data: coclustering genes and conditions. Genome research 13, 4 (2003), 703-716. [32] Daniel B Larremore, Aaron Clauset, and Abigail Z Jacobs. 2014. Efficiently inferring community structure in bipartite networks. Physical Review E 90, 1 (2014), 012805. [33] Sune Lehmann, Martin Schwartz, and Lars Kai Hansen. 2008. Biclique communities. Physical review E 78, 1 (2008), 016108. [34] Yvonne Y Li and Steven JM Jones. 2012. Drug repositioning for personalized medicine. Genome medicine 4 (2012), 1-14. [35] Xin Liu and Tsuyoshi Murata. 2010. Community detection in large-scale bipartite networks. Transactions of the Japanese Society for Artificial Intelligence 25, 1 (2010), 16-24. [36] David Melamed. 2014. Community structures in bipartite networks: A dualprojection approach. PloS one 9, 5 (2014), e97823. [37] Tsuyoshi Murata. 2009. Detecting communities from bipartite networks based on bipartite modularities. In 2009 International Conference on Computational Science and Engineering , Vol. 4. IEEE, 50-57. [38] Jose C Nacher and Jean-Marc Schwartz. 2012. Modularity in protein complex and drug interactions reveals new polypharmacological properties. PloS one 7, 1 (2012), e30028. [39] Mark EJ Newman. 2006. Finding community structure in networks using the eigenvectors of matrices. Physical review E 74, 3 (2006), 036104. [40] Mark EJ Newman and Michelle Girvan. 2004. Finding and evaluating community structure in networks. Physical review E 69, 2 (2004), 026113. [41] Gergely Palla, Imre Der\u00e9nyi, Ill\u00e9s Farkas, and Tam\u00e1s Vicsek. 2005. Uncovering the overlapping community structure of complex networks in nature and society. nature 435, 7043 (2005), 814-818. [42] Paola Pes\u00e1ntez-Cabrera and Ananth Kalyanaraman. 2017. Efficient detection of communities in biological bipartite networks. IEEE/ACM transactions on computational biology and bioinformatics 16, 1 (2017), 258-271. [43] Pascal Pons and Matthieu Latapy. 2005. Computing communities in large networks using random walks. In International symposium on computer and information sciences . Springer, 284-293. [44] Alex Pothen, Horst D Simon, and Kang-Pu Liou. 1990. Partitioning sparse matrices with eigenvectors of graphs. SIAM journal on matrix analysis and applications 11, 3 (1990), 430-452. [45] Benedek Rozemberczki and Rik Sarkar. 2020. Characteristic Functions on Graphs: Birds of a Feather, from Statistical Descriptors to Parametric Models. In Proceedings of the 29th ACM International Conference on Information and Knowledge Management (CIKM '20) . ACM, 1325-1334. [46] Risa D Sargent and David D Ackerly. 2008. Plant-pollinator interactions and the assembly of plant communities. Trends in Ecology & Evolution 23, 3 (2008), 123-130. [47] Prithviraj Sen, Galileo Namata, Mustafa Bilgic, Lise Getoor, Brian Galligher, and Tina Eliassi-Rad. 2008. Collective classification in network data. AI magazine 29, 3 (2008), 93-93. [48] Arnab Sinha, Zhihong Shen, Yang Song, Hao Ma, Darrin Eide, and Kuansan Wang. 2015. An Overview of Microsoft Academic Service (MAS) and Applications. In The WebConf . [49] Gilbert Strang, Gilbert Strang, Gilbert Strang, and Gilbert Strang. 1993. Introduction to linear algebra . Vol. 3. Wellesley-Cambridge Press. [50] Alexander Strehl and Joydeep Ghosh. 2002. Cluster ensembles-a knowledge reuse framework for combining multiple partitions. Journal of machine learning research 3, Dec (2002), 583-617. [51] Kenta Suzuki and Ken Wakita. 2009. Extracting multi-facet community structure from bipartite networks. In 2009 International Conference on Computational Science and Engineering , Vol. 4. IEEE, 312-319. [52] Raphael Tackx, Fabien Tarissan, and Jean-Loup Guillaume. 2018. ComSim: a bipartite community detection algorithm using cycle and node's similarity. In Complex Networks & Their Applications VI: Proceedings of Complex Networks 2017 (The Sixth International Conference on Complex Networks and Their Applications) . Springer, 278-289. [53] Lei Tang and Huan Liu. 2009. Relational learning via latent social dimensions. In Proceedings of the 15th ACM SIGKDD international conference on Knowledge discovery and data mining . 817-826. [54] Hanghang Tong, Christos Faloutsos, and Jia-Yu Pan. 2006. Fast random walk with restart and its applications. In Sixth international conference on data mining (ICDM'06) . IEEE, 613-622. [55] Ulrike Von Luxburg. 2007. A tutorial on spectral clustering. Statistics and computing 17, 4 (2007), 395-416. [56] Sibo Wang, Renchi Yang, Xiaokui Xiao, Zhewei Wei, and Yin Yang. 2017. FORA: simple and effective approximate single-source personalized pagerank. In Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining . 505-514. 14 Efficient High-Quality Clustering for Large Bipartite Graphs [57] David P Woodruff. 2014. Sketching as a Tool for Numerical Linear Algebra. (2014). [58] Fangzhao Wu, Ying Qiao, Jiun-Hung Chen, Chuhan Wu, Tao Qi, Jianxun Lian, Danyang Liu, Xing Xie, Jianfeng Gao, Winnie Wu, and Ming Zhou. 2020. MIND: A Large-scale Dataset for News Recommendation. In ACL . 3597-3606. [59] Yao Wu, Xudong Liu, Min Xie, Martin Ester, and Qing Yang. 2016. CCCF: Improving collaborative filtering via scalable user-item co-clustering. In Proceedings of the ninth ACM international conference on web search and data mining . 73-82. [60] Rongkai Xia, Yan Pan, Lei Du, and Jian Yin. 2014. Robust multi-view spectral clustering via low-rank and sparse decomposition. In Proceedings of the AAAI conference on artificial intelligence , Vol. 28. [61] Wei Xu, Xin Liu, and Yihong Gong. 2003. Document clustering based on nonnegative matrix factorization. In SIGIR . 267-273. [62] Renchi Yang. 2022. Efficient and Effective Similarity Search over Bipartite Graphs. In Proceedings of the ACM Web Conference 2022 . 308-318. [63] Renchi Yang, Jieming Shi, Keke Huang, and Xiaokui Xiao. 2022. Scalable and Effective Bipartite Network Embedding. In Proceedings of the 2022 International Conference on Management of Data . 1977-1991. [64] Renchi Yang, Jieming Shi, Xiaokui Xiao, Yin Yang, and Sourav S Bhowmick. 2020. Homogeneous network embedding for massive graphs via reweighted personalized PageRank. Proceedings of the VLDB Endowment 13, 5 (2020), 670683. [65] Renchi Yang, Jieming Shi, Yin Yang, Keke Huang, Shiqi Zhang, and Xiaokui Xiao. 2021. Effective and scalable clustering on massive attributed graphs. In Proceedings of the Web Conference 2021 . 3675-3687. [66] Mao Ye, Dong Shou, Wang-Chien Lee, Peifeng Yin, and Krzysztof Janowicz. 2011. On the semantic annotation of places in location-based social networks. In Proceedings of the 17th ACM SIGKDD international conference on Knowledge discovery and data mining . 520-528. [67] Tzu-Chi Yen and Daniel B Larremore. 2020. Community detection in bipartite networks with stochastic block models. Physical Review E 102, 3 (2020), 032309. [68] Weihua Zhan, Zhongzhi Zhang, Jihong Guan, and Shuigeng Zhou. 2011. Evolutionary method for finding communities in bipartite networks. Physical review E 83, 6 (2011), 066120. [69] Tian Zhang, Raghu Ramakrishnan, and Miron Livny. 1996. BIRCH: an efficient data clustering method for very large databases. SIGMOD (1996), 103-114. [70] Tao Zhou, Jie Ren, Mat\u00fa\u0161 Medo, and Yi-Cheng Zhang. 2007. Bipartite network projection and personal recommendation. Physical review E 76, 4 (2007), 046115. [71] Katharina Anna Zweig and Michael Kaufmann. 2011. A systematic approach to the one-mode projection of bipartite graphs. Social Network Analysis and Mining 1 (2011), 187-218. 15"}
