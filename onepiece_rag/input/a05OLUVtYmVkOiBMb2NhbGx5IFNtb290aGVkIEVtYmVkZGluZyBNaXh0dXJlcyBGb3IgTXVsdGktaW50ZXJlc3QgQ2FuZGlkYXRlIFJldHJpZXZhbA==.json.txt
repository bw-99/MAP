<h1>abstract</h1> <p>Candidate retrieval is the first stage in recommendation systems, where a light-weight system is used to retrieve potentially relevant items for an input user. These candidate items are then ranked and pruned in later stages of recommender systems using a more complex ranking model. As the top of the recommendation funnel, it is important to retrieve a high-recall candidate set to feed into downstream ranking models. A common approach is to leverage approximate nearest neighbor (ANN) search from a single dense query embedding; however, this approach this can yield a low-diversity result set with many near duplicates. As users often have multiple interests, candidate retrieval should ideally return a diverse set of candidates reflective of the user's multiple interests. To this end, we introduce kNN-Embed, a general approach to improving diversity in dense ANN-based retrieval. kNN-Embed represents each user as a smoothed mixture over learned item clusters that represent distinct "interests" of the user. By querying each of a user's mixture component in proportion to their mixture weights, we retrieve a high-diversity set of candidates reflecting elements from each of a user's interests. We experimentally compare kNN-Embed to standard ANN candidate retrieval, and show significant improvements in overall recall and improved diversity across three datasets. Accompanying this work, we open source a large Twitter follow-graph dataset1, to spur further research in graph-mining and representation learning for recommender systems. </p><h1>sections</h1><h2>heading</h2> <p>Introduction </p><h2>text</h2> <p>Recommendation systems for online services such as e-commerce or social networks present users with suggestions in the form of ranked lists of items [5]. </p><h2>publication_ref</h2> <p>['b4'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Related Works </p><h2>text</h2> <p>Traditionally, techniques for candidate retrieval rely on fast, scalable approaches to search large collections for similar sparse vectors [3,1]. Approaches apply indexing and optimization strategies to scale sparse similarity search. One such strategy builds a static clustering of the entire collection of items; clusters are retrieved based on how well their centroids match the query [25,20]. These methods either (1) match the query against clusters of items and rank clusters based on similarity to query or (2) utilize clusters as a form of item smoothing.
For embedding-based recommender systems [28], large-scale dense similarity search has been applied for retrieval. Some approaches proposed utilize hashing-based techniques such as mapping input and targets to discrete partitions and selecting targets from the same partitions as inputs [26]. With the advent of fast approximate nearest-neighbor search [21,13], dense nearest neighbor has been applied by recommender systems for candidate retrieval [5].
When utilizing graph-based embeddings for recommender systems [8], some methods transform single-mode embeddings to multiple modes by clustering user actions [23]. Our method extends upon this idea by incorporating nearest neighbor smoothing to address the sparsity problem of generating mixtures of embeddings for users with few engagements.
Smoothing via k-nearest-neighbor search has been applied for better language modeling [16] and machine translation [15]. We smooth low-engagement user representations by leveraging engagements from similar users. </p><h2>publication_ref</h2> <p>['b2', 'b0', 'b24', 'b19', 'b27', 'b25', 'b20', 'b12', 'b4', 'b7', 'b22', 'b15', 'b14'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>kNN-Embed </p><h2>text</h2> <p> </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Preliminaries </p><h2>text</h2> <p>Let U = u 1 , u 2 , . . . u n  be the set of source entities (i.e., users in a recommender system) and I = i 1 , i 2 , . . . i m  be the set of target entities (i.e., items in a recommender system). Let G constitute a bipartite graph representing the engagements between users (U) and items (I). For each user and item, we define a "relevance" variable in 0, 1 indicating an item's relevance to a particular user. An item is considered relevant to a particular user if a user, presented with an item, will engage with said item. Based on the engagements in G, each user, u j , is associated with a d-dimensional embedding vector u j ∈ R d ; similarly each target item i k is associated with an embedding vector i k ∈ R d . We call these the unimodal embeddings, and assume that they model user-item relevance p(relevance|u j , i k ) = f (u j , i k ) for a suitable function f .
Given the input user-item engagement graph, our goal is to learn mixtures of embeddings representations of users that better capture the multiple interests of a user as evidenced by higher recall in a candidate retrieval task. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Unimodal User and Item Embeddings: </p><h2>text</h2> <p>While kNN-Embed presupposes a set of co-embedded user and item embeddings and is agnostic to the exact embedding technique used (the only constraint is that the embeddings must satisfy p(i k |u j ) = g(u j T i k ) for monotone g), for completeness we describe a simple approach we applied to co-embed users and items into the same space. We form a bipartite graph G of users and items, where an edge represents relevance (e.g., user follows content producer). We seek to learn an embedding vector (i.e., vector of learnable parameters) for each user (u j ) and item (i k ) in this bipartite graph; we denote these learnable embeddings for users and items as u j and i k respectively. A user-item pair is scored with a scoring function of the form f (u j , i k ). Our training objective seeks to learn u and i parameters that maximize a log-likelihood constructed from the scoring function for (u, i) ∈ G and minimize for (u, i) / ∈ G. For simplicity, we apply a dot product comparison between user and item representations. For a user-item pair e = (u j , i), this is defined by:
f (e) = f (u j , i k ) = u j ⊺ i k(1)
As seen in Equation 1, we co-embed users and items by scoring their respective embedded representations via dot product and perform edge (or link) prediction. We consume the input bipartite graph G as a set of user-item pairs of the form (u, i) which represent positive engagements between a user and item. The embedding training objective is to find user and item representations that are useful for predicting which users and items are linked via an engagement. While a softmax is a natural formulation to predict a user-item engagement, it is impractical due to the cost of computing the normalization over a large vocabulary of items. Following previous methods [22,10], negative sampling, a simplification of noise-contrastive estimation, can be used to learn the parameters u and i. We maximize the following negative sampling objective:
arg max u,i e∈G   log σ(f (e)) + e ′ ∈N (e) log σ(-f (e ′ ))  (2)
where:
N (u, i) = (u, i ′ ) : i ′ ∈ I ∪ (u ′ , i) : u ′ ∈ U . Equation 2 represents
the log-likelihood of predicting a binary "real" (edges in the network) or "fake" (negatively sampled edges) label. To maximize the objective, we learn u and i parameters to differentiate positive edges from negative, unobserved edges. Negative edges are sampled by corrupting positive edges via replacing either the user or item in an edge pair with a negatively sampled user or item. Following previous approaches, negative sampling is performed both uniformly and proportional to node prevalence in the training graph [4,18]. </p><h2>publication_ref</h2> <p>['b21', 'b9', 'b3', 'b17'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Smoothed Mixture of Embeddings </p><h2>text</h2> <p>To use embeddings for candidate retrieval, we need a method of selecting relevant items given the input user. Ideally, we would like to construct a full distribution over all items for each user p(i k |u j ) and draw samples from it. The sheer number of items makes this difficult to do efficiently, especially when candidate retrieval strategies are meant to be light-weight. In practice, the most common method is to greedily select the top few most relevant items using an ANN search with the unimodal user embedding as query. A significant weakness of this greedy selection is that, by its nature, ANN search will return items that are similar not only to the user embedding, but also to each other; this drastically reduces the diversity of the returned items. This reduction in diversity is a side-effect of the way embeddings are trained -typically, the goal of training embeddings is to put users and relevant items close in Euclidean space; however, this also places similar users close in space, as well as similar items. We will repeatedly exploit this "locality implies similarity" property of embeddings in this paper to resolve this diversity issue.
Clustering Items: Since neighboring items are similar in the embedding space, if we apply a distance-based clustering to items, we can arrive at groupings that represent individual user preferences well. As such, we first cluster items using spherical k-means [6] where cluster centroids are placed on a high-dimensional sphere with radius one. Given these item clusters, instead of immediately collapsing the distribution p(i k |u j ) to a few items as ANN search does, we can write the full distribution p(i k |u j ) as a mixture over item clusters:
p(i k |u j ) = c p(c|u j ) • p(i k |u j , c)
where in each cluster, we learn a separate distribution over the items in the cluster p(i k |u j , c). Thus, we are modeling each user's higher level interests p(c|u), and then within each interest c, we can apply an efficient ANN-search strategy as before. In effect, we are interpolating between sampling the full preference distribution p(i k |u j ) and greedily selecting a few items in an ANN. </p><h2>publication_ref</h2> <p>['b5'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Mixture of Embeddings via Cluster Engagements: </p><h2>text</h2> <p>After clustering target entities, we learn p(c|u j ) through its maximum likelihood estimator (MLE):
p mle (c|u j ) = count(u i , c)/ c ′ ∈Mj count(u j , c ′ )(3)
where, count(u j , c) is the number of times u j has a relevant item in cluster c. For computational efficiency, we take M j to be u j 's top m most relevant clusters. We normalize these counts to obtain a proper cluster-relevance distribution.
Nearest Neighbor Smoothing: Unfortunately, we typically have few user-item engagements on a per-user basis; thus, while the MLE is unbiased and asymptotically efficient, it can also be high variance. To this end, we introduce a smoothing technique that once again exploits locality in the ANN search, this time for users. Figure 1 illustrates identifying k nearest-neighbors (K j ) to the query user u j 's, and leveraging the information from the neighbors' cluster engagements to augment the user's cluster relevance. We compute this distribution over item clusters by averaging the MLE probability for each nearest neighbor (item clusters that are not engaged with by a retrieved neighbor have zero probability).
p k N N (c|u j ) = 1 |K j | u ′ ∈Kj p mle (c|u ′ )(4)
We apply Jelinik-Mercer smoothing to interpolate between a user's MLE distribution with the aggregated nearest neighbor distribution [12].
p smoothed (c|u j ) = (1 -λ)p mle (c|u j ) + λp k N N (c|u j ),(5)
where λ ∈ [0, 1] represents how much smoothing is applied. It can be manually set or tuned on a downstream extrinsic task. Fig. 1: Example of retrieving two candidates. In an ANN, items 4 and 5 would be deterministically returned for user 1. In our proposed kNN-Embed, even though the distances to cluster 2 are larger, smoothing means that we will sometimes return items from that cluster, yielding more diverse items. Note in this case, we don't even require that user 1 has previously relevant items in cluster 2.
Sampling within Clusters Within each cluster there are many ways to retrieve items on a per user basis. A simple, but appealing, strategy is to represent each user as a normalized centroid of their relevant items in that cluster:
centroid(c, u j ) = m∈R(c,uj ) i m ∥ m∈R(c,uj ) i m ∥ ,(6)
where R(c, u j ) is the set of relevant items for user u j in cluster c. However, since we are applying smoothing to the cluster probabilities p(c|u j ), it may be case that u j has zero relevant items in a given cluster. Hence, we smooth the user centroid using neighbor infomation to obtain the final user representation u c j :
u c j = (1 -λ) centroid(c, u j ) + λ |K j | u ′ ∈Kj p mle (c|u ′ ) centroid(c, u ′ )(7)
Equation 7 shows the kNN-smoothed user-specific embedding for cluster c. This embedding takes the user-specific cluster representations from Equation 6, and performs a weighted averaging proportionate to each user's contribution to p smoothed (c|u j ). The final vector is once again normalized to unit norm. </p><h2>publication_ref</h2> <p>['b11'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Evaluation Datasets and Metrics </p><h2>text</h2> <p>We evaluate on three datasets which we describe below: </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>HEP-TH Citation Graph: </p><h2>text</h2> <p>This paper citation network is collected from Arxiv preprints from the High Energy Physics category [9]. The dataset consists of: 34,546 papers and 421,578 citations. </p><h2>publication_ref</h2> <p>['b8'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>DBLP Citation Graph: </p><h2>text</h2> <p>This paper citation network is collected from DBLP [24] and consists of 5,354,309 papers and 48,227,950 citation relationships.
Twitter Follow Graph: We curate Twitter user-follows-user (available via API) by first selecting a number of 'highly-followed' users that we refer to as 'content producers'; these content producers serve as 'items' in our recommender systems terminology. We then sampled users that follow these content producer accounts. All users are anonymized with no other personally identifiable information (e.g., demographic features) present. Additionally, the timestamp of each follow edge was mapped to an integer that respects date ordering, but does not provide any information about the date that follow occurred. In total, we have 261M edges and 15.5M vertices, with a max-degree of 900K and a min-degree of 5. We hope that this dataset will be of useful to the community as a test-bed for large-scale retrieval research. </p><h2>publication_ref</h2> <p>['b23'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Metrics: </p><h2>text</h2> <p>We evaluate kNN-Embed on three aspects: (1) the recall (2) diversity and (3) goodness of fit of retrieved candidates. Below, we formalize these metrics. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Recall@K: </p><h2>text</h2> <p>The most natural (and perhaps most important) metric for computing the efficacy of various candidate retrieval strategies is Recall@K. This metric is given by considering a fixed number of top candidates yield by a retrieval system (up to size K) and measuring what percent of these candidates are heldout relevant candidates. The purpose of most candidate retrieval systems is to collect a high-recall pool of items for further ranking, and thus recall is a relevant metric to consider. Additionally, recall provides an indirect way to measure diversity -to achieve high recall, one is obliged to return a large fraction of all relevant documents, which simple greedy ANN searches can struggle with. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Diversity: </p><h2>text</h2> <p>To evaluate the diversity among the retrieved candidates, we measure the spread in the embeddings of the retrieved candidates by calculating the average distance retrieved candidates are from their centroid. The underlying idea is that when 'locality implies similarity'; as a corollary, if candidates are further in Euclidean distance, then they are likely to be different. As such, for a given set of candidates C, we compute diversity D as follows:
D(C) = 1 |C| i k ∈C ∥i k -î∥(8)
where C denotes the set of retrieved candidates and î = i k ∈C i k /|C| is the mean of the unimodal embeddings of the retrieved candidates. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Goodness of Fit: </p><h2>text</h2> <p>In addition to diversity of retrieved items, we need to ensure that a user's mixture representation is an accurate model of their intereststhat is the mixture of embeddings identifies points in the embedding space where relevant items lie. Thus, we compare held out relevant items to the user's mixture representation we use to query. We measure this "goodness of fit" by computing the Earth Mover's Distance (EMD) [19] between a uniform distribution over a user's relevant items and the user's mixture distribution. The EMD measures the distance between two probability distributions over a metric space [17,7]. We measure the distance between a user's cluster distribution (e.g., Equation 3 and Equation 4), to a uniform distribution over a held-out set of relevant items: p(i|u j ) over a Euclidean space. We compute EMD by soft assigning all held-out relevant items of a user to clusters, minimizing the sum of item-cluster distances, with the constraint that the sum over soft assignments matches p(c|u j ). As seen in Figure 2, with standard unimodal representations, a single embedding vector is compared to the held-out items and the goodness of fit is the distance between the item embeddings and the singular user embedding. In comparison, for mixture representations (Figure 2, each user multiple user embeddings who each have fractional probability mass that in total sums to 1. The goodness of fit is then the distance achieved by allocating the mass in each item to the closest user embedding cluster with available probability mass. Observing unimodal representations in Fig. 2, a single unimodal embedding is situated in the embedding space and compared to held-out relevant items.
As shown, some held-out items are close to the unimodal embedding, while others are further away. In contrast, for mixture representations, each user has multiple user-embeddings and each of these embeddings lies close to a cluster of relevant items. The intuition is that if a user has multiple item clusters they are interested in, multiple user embeddings can better capture these interests.   </p><h2>publication_ref</h2> <p>['b18', 'b16', 'b6'] </p><h2>figure_ref</h2> <p>['fig_0', 'fig_0', 'fig_0'] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Experiments </p><h2>text</h2> <p>Experimental Setup: For our underlying ANN-based candidate retrieval system, we start by creating a bipartite graph between source entities and target entities for each dataset, with each edge representing explicit relevance between items (e.g., citing paper cites cited paper or user follows content producer). We then learn unimodal 100-dimensional embeddings for users and items by training over 20 epochs and cluster them via spherical k-means over 20 epochs [2].
Evaluation Task: We evaluate three candidate retrieval strategies -baseline ANN with unimodal embeddings (which is how most ANN-based candidate retrieval systems work), mixture of embeddings with no smoothing [23], and mixture of embeddings with smoothing (i.e., kNN-Embed). For each strategy, we compute the Recall@K, diversity, and fit in a link prediction task. </p><h2>publication_ref</h2> <p>['b1', 'b22'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Research Hypotheses: </p><h2>text</h2> <p>We explore two research hypotheses (as well as achieve some understanding of the hyperparameters): (1) Unimodal embeddings miss many relevant items due to the similarity of retrieved items. Mixtures yield more diverse and higher recall candidates. ( 2) Smoothing, by using information from neighboring users, further improves the recall of retrieved items. Approach R@10 R@20 R@50 R@10 R@20 R@50 R@10 R@20 R@50 Unimodal 20.0% 30.0% 45.7% 9.4% 13.9% 21.6% 0.58% Recall of unimodal vs mixture vs kNN-Embed-higher is better. HEP-TH (λ = 0.8, 2000 clusters, 5 embeddings). DBLP (λ = 0.8, 10000 clusters, 5 embeddings). Twitter-Follow (λ = 0.8, 40000 clusters, 5 embeddings). </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Recall: </p><h2>text</h2> <p>In Table 1, we report results when evaluating recall on citation prediction tasks. Results support the first hypothesis that unimodal embeddings may miss relevant items if they don't lie close to the user in the shared embedding space. Mixture of embeddings with no smoothing, yields a 14% relative improvement in R@10 for for HEP-TH, and 16% relative improvement for DBLP. Our second hypothesis (2) posits that data sparsity can lead to sub-optimal mixtures of embeddings, and that nearest-neighbor smoothing can mitigate this. Our experiments support this hypothesis, as we see a 25% relative improvement for HEP-TH in R@10, and 35% for DBLP and when using kNN-Embed. We see similar significant improvements over baselines in R@20 and R@50. For Twitter-Follow, the improvements in recall are dramatic -534% in relative terms going from unimodal embeddings to a mixture of embeddings in R@10. We suspect this significant improvement is because Twitter-Follow simultaneously has a much higher average degree than HEP-TH and DBLP and the number of unique nodes is much larger. It is a more difficult task to embed so many items, from many different interest clusters, in close proximity to a user. As such, we see a massive improvement by explicitly querying from each user's interest clusters. Applying smoothing provides an additional 74% in relative terms, and similar behaviours are observed in R@20 and R@50. </p><h2>publication_ref</h2> <p>['b1'] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>['tab_2'] </p><h2>heading</h2> <p>Diversity: </p><h2>text</h2> <p>We apply Equation 8 to retrieved candidates and measure the spread of retrieved candidates' embedding vectors. As seen in Table 2, the candidates from unimodal retrieval are less diverse than candidates retrieved via multiple queries from mixture representations. This verifies our first research hypothesis that unimodal embeddings may retrieve many items that are clustered closely together as a by-product of ANN retrieval (i.e., diversity and recall is low). However, multiple queries from mixtures of embeddings broadens the search spatially; retrieved items are from different clusters, which are more spread out from each other. kNN-Embed (i.e., smooth mixture retrieval) results in slightly less diverse candidates than unsmoothed mixture retrieval. We posit that this is due to the high-variance of the maximum likelihood estimator of the p mle (c|u j ) multinomial (Equation 3). While this high-variance may yield more diverse candidates, this yields less relevant candidates as seen in Table 1 where kNN-Embed consistently yields better recall than unsmoothed mixture retrieval. While high diversity is necessary for high recall, it is insufficient on its own.  </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>['tab_4', 'tab_2'] </p><h2>heading</h2> <p>Goodness of Fit: </p><h2>text</h2> <p>We evaluate how well unimodal, mixture, and smoothed mixture embeddings model a user's interests. The main idea is that the better fit a user representation is, the closer it will be to the distribution of held out relevant items for that user. As seen in Table 3, the results validate the idea that unimodal user embeddings do not model user interests as well as mixtures over multiple embeddings. Multiple embeddings yield a significant EMD improvement over a single embedding vector when evaluated on held-out items. Smoothing further decreases the EMD which we posit is due to the smoothed embedding mixtures being lower-variance estimates as they leverage engagement data from similar users in constructing the representations. These results suggest that the higher recall of smoothed mixtures is due to better user preferences modeling.  </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>['tab_5'] </p><h2>heading</h2> <p>Hyper-parameter Sensitivity Analysis: </p><h2>text</h2> <p>We focus on recall as the sine qua non of candidate retrieval problems and analyze hyper-parameters on HEP-TH. In Figure 3a, we vary the smoothing parameter λ (same parameter for both the mixture probabilities and the cluster centroids) and see heavy smoothing improves performance significantly. This likely stems from the sparsity of HEP-TH where most papers have only a few citations. In Figure 3b, we vary the number of embeddings (i.e., the mixture size) and notice improved performance saturating at six mixture components. Out of all the hyperparameters, this seems to be the critical one in achieving high recall. In practice, latency constraints can be considered when selecting the number of embeddings per user, explicitly making the trade-off between diversity and latency.    </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>['fig_3', 'fig_3'] </p><h2>table_ref</h2> <p>[] </p><h2>heading</h2> <p>Conclusions </p><h2>text</h2> <p>We present kNN-Embed, a method of transforming single user dense embeddings, into mixtures of embeddings, with the goal of better modeling user interests, increasing retrieval recall and diversity. This multi-embedding scheme represents a source entity with multiple distinct topical affinities by globally clustering items and aggregating the source entity's engagements with clusters. Recognizing that user-item engagements may often be sparse, we propose a nearest-neighbor smoothing to enrich these mixture representation. Our smoothed mixture representation better models user preferences retrieving a diverse set of candidate items reflective of a user's multiple interests. This significantly improves recall on candidate retrieval tasks on three datasets including Twitter-Follow, a dataset we curate and release to the community. </p><h2>publication_ref</h2> <p>[] </p><h2>figure_ref</h2> <p>[] </p><h2>table_ref</h2> <p>[] </p>